import 'dart:convert';
import 'dart:io';

import 'package:archive/archive.dart';
import 'package:audiolearn/models/audio.dart';
import 'package:audiolearn/models/picture.dart';
import 'package:audiolearn/viewmodels/audio_download_vm.dart';
import 'package:audiolearn/viewmodels/audio_player_vm.dart';
import 'package:audiolearn/viewmodels/comment_vm.dart';
import 'package:audiolearn/viewmodels/date_format_vm.dart';
import 'package:audiolearn/viewmodels/picture_vm.dart';
import 'package:audiolearn/viewmodels/playlist_list_vm.dart';
import 'package:audiolearn/viewmodels/warning_message_vm.dart';
import 'package:audiolearn/views/widgets/audio_sort_filter_dialog.dart';
import 'package:audiolearn/views/widgets/set_value_to_target_dialog.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:intl/intl.dart';
import 'package:path/path.dart' as path;
import 'package:audiolearn/main.dart' as app;

import 'package:audiolearn/constants.dart';
import 'package:audiolearn/models/playlist.dart';
import 'package:audiolearn/services/json_data_service.dart';
import 'package:audiolearn/services/settings_data_service.dart';
import 'package:audiolearn/utils/dir_util.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../test/services/mock_shared_preferences.dart';
import '../test/viewmodels/mock_audio_download_vm.dart';
import 'integration_test_util.dart';
import 'mock_file_picker.dart';

void main() {
  // Necessary to avoid FatalFailureException (FatalFailureException: Failed
  // to perform an HTTP request to YouTube due to a fatal failure. In most
  // cases, this error indicates that YouTube most likely changed something,
  // which broke the library.
  // If this issue persists, please report it on the project's GitHub page.
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Search icon button test', () {
    group('Audio search word selection', () {
      testWidgets('''First, select the existing 'janco' sort/filter
          parms in the SF dropdown button. Then enter the search word 'La' in the
          'Youtube Link''', (WidgetTester tester) async {
        // Link or Search' text field. After entering 'L', verify that the search
        // icon button is now enabled. Then, enter 'La' search word, click on the
        // enabled search icon button and verify the reduced displayed audio list.
        // After that, delete the 'a' letter from the 'La' search word and verify
        // the changed displayed audio list. Since the search button was used,
        // modifying the search text applies at each search text change. Then,
        // select the 'default' dropdon icon button and verify that now, as the
        // search button was tapped, applying the 'default' sort filter parms
        // is impacted by the still existing search word. Then, enters a https URL
        // in youtubeUrlOrSearchTextField and verify that the search icon button
        // is disabled. and that the download single video button is enabled. Then,
        // tap on the delete button to delete the URL in the search text word and
        // verify that the search icon button is disabled and that the download
        // single video button is disabled. Finally, verify that the search text
        // field is empty and that the displayed audio list is the same as the one
        // before entering the search word.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
          tapOnPlaylistToggleButton: false,
        );

        // Verify that the download single video button is
        // now disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // Select 'janco' dropdown button item to apply the existing
        // 'janco' sort/filter parms
        final Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        final Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'janco' sort/filter item
        String sortFilterParmsTitle = 'janco';
        Finder sortFilterParmsDropDownTextFinder =
            find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify the presence of the disabled stop button
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr:
              'stopDownloadingButton', // this button is disabled if the
          //                                     'Youtube Link or Search' dosn't
          //                                     contain a search word or sentence
        );

        // Now enter the first letter of the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'L',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Verify the presence of the delete button
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr:
              'clearPlaylistUrlOrSearchButtonKey', // this button is disabled if the
          //                                     'Youtube Link or Search' dosn't
          //                                     contain a search word or sentence
        );

        // Ensure that since the search icon button was not yet pressed,
        // the displayed audio list is the same as the one before entering
        // the first letter of the search word.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Enter the second letter of the 'La' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the second letter of the 'La' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'La',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Ensure that since the search icon button was not yet pressed,
        // the displayed audio list is the same as the one before entering
        // the first letter of the search word.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Now verify the order of the reduced playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now remove the second letter of the 'La' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'L',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // And verify the order of the playlist audio titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was used,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Then reenter the second search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'La',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the reduced playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'default' sort/filter item
        sortFilterParmsTitle = 'default';
        sortFilterParmsDropDownTextFinder = find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Now entering a URL in the search text word

        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'https://www.youtube.com/watch?v=ctD3mbQ7RPk',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify that the download single video button is
        // now enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // Verify the presence of the delete button
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr:
              'clearPlaylistUrlOrSearchButtonKey', // this button is disabled if the
          //                                     'Youtube Link or Search' dosn't
          //                                     contain a search word or sentence
        );

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now tap on the delete button to delete the URL in the search
        // text word
        await tester.tap(
          find.byKey(
            const Key('clearPlaylistUrlOrSearchButtonKey'),
          ),
        );
        await tester.pumpAndSettle();

        // Verify that the stop text button replaced the
        // delete icon button, but is disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'stopDownloadingButton',
        );

        // Verify that the download single video button is
        // now disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // And verify that the search text field is empty
        expect(
          (find.byKey(const Key('youtubeUrlOrSearchTextField'))),
          findsOneWidget,
        );

        // And verify the order of the playlist audio titles
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Finish by reducing, then emptying the search word. First, select the
           existing 'janco' sort/filter parms in the SF dropdown button. Then enter
           the search word 'La' in the 'Youtube ''',
          (WidgetTester tester) async {
        // Link or Search' text field. After entering 'La', verify that the search
        // icon button is now enabled and click on it. Then, reduce the search word
        // to one letter ('L') and verify that the audio liat was updatefd. Then,
        // select the 'default' dropdon icon
        // button and verify that now, as the search button was tapped, applying
        // the 'default' sort filter parms is impacted by the still existing search
        // word. Then, empty the search word and verify that the search icon button
        // is disabled.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
          tapOnPlaylistToggleButton: false,
        );

        // Select 'janco' dropdown button item to apply the existing
        // 'janco' sort/filter parms
        final Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        final Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'janco' sort/filter item
        String sortFilterParmsTitle = 'janco';
        Finder sortFilterParmsDropDownTextFinder =
            find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now enter the 2 letters of the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'La',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now reduce the search word to 1 letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'L',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify the order of the playlist audio titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now re-enter the 2 letters of the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'La',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // And verify the order of the playlist audio titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'default' sort/filter item
        sortFilterParmsTitle = 'default';
        sortFilterParmsDropDownTextFinder = find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Now emptying the search text word

        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Finish by entering a http (not https) URL. First, select the existing
          'janco' sort/filter parms in the SF dropdown button. Then enter the search
           word 'La' in the 'Youtube Link''', (WidgetTester tester) async {
        // Link or Search' text field. After entering 'L', verify that the search
        // icon button is now enabled. Then, select the 'default' dropdon icon
        // button and verify that now, as the search button was tapped, applying
        // the 'default' sort filter parms is impacted by the still existing search
        // word. Then, http URL and verify that the search icon button
        // is disabled.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
          tapOnPlaylistToggleButton: false,
        );

        // Select 'janco' dropdown button item to apply the existing
        // 'janco' sort/filter parms
        final Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        final Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'janco' sort/filter item
        String sortFilterParmsTitle = 'janco';
        Finder sortFilterParmsDropDownTextFinder =
            find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now enter the first letter of the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'La',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the 'default' sort/filter item
        sortFilterParmsTitle = 'default';
        sortFilterParmsDropDownTextFinder = find.text(sortFilterParmsTitle);

        await tester.tap(sortFilterParmsDropDownTextFinder);
        await tester.pumpAndSettle();

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Now emptying the search text word

        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // And verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Playlist search word selection', () {
      testWidgets('''First, enter the search word 'al' in the 'Youtube Link or
           Search' text field.''', (WidgetTester tester) async {
        // After entering 'a', verify that the search icon button is now enabled.
        // Then, enter 'al' search word, click on the enabled search icon button
        // and verify the reduced displayed playlist list list. Finally, add '_'
        // to the search word and verify the changed displayed playlist list.
        //
        // After that, delete the '_' letter from the 'al_' search word and verify
        // the changed displayed audio list. Since the search button was used,
        // modifying the search text applies at each search text change. Then,
        // delete the 'l' letter, then, empty the youtubeUrlOrSearchTextField
        // and verify that the search icon button is disabled. Then, enters a
        // letter and verify it has no impact since the search button was not
        // pressed again. Finally, re-enter the 2 first letters of the 'al' search
        // word, verify the reduced displayed playlist list then click on the
        // delete button and verify the result.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify the presence of the disabled stop button
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr:
              'stopDownloadingButton', // this button is disabled if the
          //                                     'Youtube Link or Search' dosn't
          //                                     contain a search word or sentence
        );

        // Now add the first 2 letters of the 'al' search word and tap
        // on the search icon button. Then verify that the search icon
        // button is now enabled and active
        List<String> playlistsTitles =
            await _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord(
          tester: tester,
        );

        // Verify the presence of the delete button
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr:
              'clearPlaylistUrlOrSearchButtonKey', // this button is disabled if the
          //                                     'Youtube Link or Search' dosn't
          //                                     contain a search word or sentence
        );

        // Now add the third letter of the 'al_' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al_',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // And verify the order of the playlist titles.

        playlistsTitles = [
          "local_2",
        ];

        // Ensure that since the search icon button was used,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Then erase the third search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Then erase the second search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'a',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now emptying the search text word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now re-enter the first 2 letters of the 'al' search word and tap
        // on the search icon button. Then verify that the search icon
        // button is now enabled and active
        await _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord(
          tester: tester,
        );

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now tap on the delete button to empty the search text
        // field
        await tester.tap(
          find.byKey(
            const Key('clearPlaylistUrlOrSearchButtonKey'),
          ),
        );
        await tester.pumpAndSettle();

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Instead of emptying, add https URL. First, enter the search
           word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'a', verify that the search icon button is now enabled.
        // Then, enter 'al' search word, click on the enabled search icon button
        // and verify the reduced displayed playlist list list. Finally, add '_'
        // to the search word and verify the changed displayed playlist list.
        //
        // After that, delete the '_' letter from the 'al_' search word and verify
        // the changed displayed audio list. Since the search button was used,
        // modifying the search text applies at each search text change. Then,
        // delete the 'l' letter, then, enter an https URL in the
        // youtubeUrlOrSearchTextField and verify that the search icon button is
        // disabled. Finally, enters a
        // letter and verify it has no impact since the search button was not
        // pressed again.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now add the first 2 letters of the 'al' search word and tap
        // on the search icon button. Then verify that the search icon
        // button is now enabled and active
        List<String> playlistsTitles =
            await _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord(
          tester: tester,
        );

        // Now add the third letter of the 'al_' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '_',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // And verify the order of the playlist titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        playlistsTitles = [
          "local_2",
        ];

        // Ensure that since the search icon button was used,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Then erase the third search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Then erase the second search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'a',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now entering https URL instead of search text word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'https://www.youtube.com/watch?v=ctD3mbQ7RPk',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify that the delete button is now enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'clearPlaylistUrlOrSearchButtonKey',
        );

        // Now, click on the delete button to empty the search
        // text field
        await tester.tap(
          find.byKey(
            const Key('clearPlaylistUrlOrSearchButtonKey'),
          ),
        );
        await tester.pumpAndSettle();

        // Verify that the search icon button is disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify that the stop text button replaced the
        // delete icon button, but is disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'stopDownloadingButton',
        );

        // And verify that the search text field is empty
        expect(
          (find.byKey(const Key('youtubeUrlOrSearchTextField'))),
          findsOneWidget,
        );

        // Then re-enter a two letters search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Verify that the delete button is enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'clearPlaylistUrlOrSearchButtonKey',
        );

        // Verify that the playlist titles list was not modified
        // since the search icon button was not pressed

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''First, enter 'http' as search word in the 'Youtube Link or
          Search' text field. This selects the 'http_local' playlist.''',
          (WidgetTester tester) async {
        // Then add ':/' to the search sentence. No more playlist are selected,
        // but the search icon button is still enabled as well as the delete
        // button. Then, add '/' to the search sentence. The search icon button
        // is now disabled and the delete button is still enabled. All the
        // playlist are now displayed since the search button is disabled.
        // Finally, click on the delete button and verify that the search
        // sentence is empty and the search icon button is disabled.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_two_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Verify the disabled state of the search icon button
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now add the 'http' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'http',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledInactive,
        );

        // Verify that the delete icon button is enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'clearPlaylistUrlOrSearchButtonKey',
        );

        // Verify that the download single video button is
        // disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // And verify the order of the playlist titles
        // before tapping on the search icon button.

        List<String> playlistsTitles = [
          "local",
          "http_local",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the playlist titles
        // after tapping on the search icon button.

        playlistsTitles = [
          "http_local",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now add the ':/' to the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'http:/',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now enabled and active
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.enabledActive,
        );

        // Verify that the delete icon button is enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'clearPlaylistUrlOrSearchButtonKey',
        );

        // Verify that the download single video button is
        // disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // And verify the order of the playlist titles
        // before tapping on the search icon button.

        playlistsTitles = [];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now add the second '/' to the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'http://',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify that the delete icon button is enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'clearPlaylistUrlOrSearchButtonKey',
        );

        // Verify that the download single video button is
        // now enabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'downloadSingleVideoButton',
        );

        // And verify the order of the playlist titles
        // before tapping on the search icon button.

        playlistsTitles = [
          "local",
          "http_local",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now, click on the delete button to empty the search
        // text field
        await tester.tap(
          find.byKey(
            const Key('clearPlaylistUrlOrSearchButtonKey'),
          ),
        );
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Verify that the stop text button replaced the
        // delete icon button, but is disabled
        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'stopDownloadingButton',
        );

        // And verify that the search text field is empty
        expect(
          (find.byKey(const Key('youtubeUrlOrSearchTextField'))),
          findsOneWidget,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Selecting searched playlist found by applying search word', () {
      testWidgets('''First, enter the search word 'al' in the 'Youtube Link or
           Search' text field.''', (WidgetTester tester) async {
        // Click on the enabled search icon button and verify the reduced
        // displayed playlist list list, the currently selected playlist title
        // and its audio list.
        //
        // Then, select one of the filtered playlist and verify the updated
        // selected playlist title as well as its audio list.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Now add the first 2 letters of the 'al' search word and tap
        // on the search icon button. Then verify that the search icon
        // button is now enabled and active
        List<String> playlistsTitles =
            await _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord(
          tester: tester,
        );

        // Verify the currently selected playlist title

        Text selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'S8 audio',
        );

        // Select the local playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: playlistsTitles[0],
        );

        // since a local playlist is selected, verify that
        // some buttons are enabled and some are disabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_up_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_down_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'download_sel_playlists_button',
        );

        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'audio_quality_checkbox',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'audio_popup_menu_button',
        );

        // Verify the newly selected playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local',
        );

        // verify the newly selected playlist audio titles

        List<String> audioTitles = [
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''First, select a local playlist. Then, enter the search word
          'S8' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // Click on the enabled search icon button and verify the modified
        // displayed playlist list list, the currently selected playlist title
        // and its audio list.
        //
        // Then, select the Youtube filtered playlist and verify the updated
        // selected playlist title as well as its audio list.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Select the local playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'local',
        );

        // some buttons are enabled and some are disabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_up_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_down_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'download_sel_playlists_button',
        );

        IntegrationTestUtil.verifyWidgetIsDisabled(
          tester: tester,
          widgetKeyStr: 'audio_quality_checkbox',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'audio_popup_menu_button',
        );

        // Verify the newly selected playlist title

        Text selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local',
        );

        // verify the local selected playlist audio titles

        List<String> playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        List<String> audioTitles = [
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        playlistsTitles =
            await enteringFirstAndSecondLetterOfYoutubePlaylistSearchWord(
          tester: tester,
        );

        // Verify the currently selected playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local',
        );

        // Select the Youtube playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'S8 audio',
        );

        // since a Youtube playlist is selected, verify that
        // some buttons are enabled and some are disabled
        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_up_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'move_down_playlist_button',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'download_sel_playlists_button',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'audio_quality_checkbox',
        );

        IntegrationTestUtil.verifyWidgetIsEnabled(
          tester: tester,
          widgetKeyStr: 'audio_popup_menu_button',
        );

        // Verify the newly selected playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'S8 audio',
        );

        // verify the youtube selected playlist audio titles

        playlistsTitles = [
          "S8 audio",
        ];

        audioTitles = [
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group(
        'Selecting and moving searched playlist found by applying search word',
        () {
      testWidgets('''First, enter the search word 'al' in the 'Youtube Link or
           Search' text field.''', (WidgetTester tester) async {
        // Click on the enabled search icon button and verify the reduced
        // displayed playlist list.
        //
        // Then, select one of the filtered playlist and click on the move
        // up icon button to reposition the selected playlist. Verify the
        // updated selected playlist title as well as its audio list.
        // Then click again on the move up icon button to reposition the
        // selected playlist. Remove the search word and verify the playlist
        // titles order.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Now add the first 2 letters of the 'al' search word and tap
        // on the search icon button. Then verify that the search icon
        // button is now enabled and active
        List<String> playlistsTitles =
            await _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord(
          tester: tester,
        );

        // Verify the currently selected playlist title

        Text selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'S8 audio',
        );

        // Select the local playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: playlistsTitles[1], // local_2
        );

        // Verify the newly selected playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local_2',
        );

        // Now tap on the move up icon button to reposition the selected
        // playlist

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        // Verify the selected moved playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local_2',
        );

        // verify the order of the reduced playlist titles

        playlistsTitles = [
          "local_2",
          "local",
        ];

        List<String> audioTitles = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Now re-tap on the move up icon button to reposition the selected
        // playlist

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        // Verify the selected moved playlist title

        selectedPlaylistTitleText =
            tester.widget(find.byKey(const Key('selectedPlaylistTitleText')));

        expect(
          selectedPlaylistTitleText.data,
          'local_2',
        );

        // verify the order of the reduced playlist titles

        playlistsTitles = [
          "local_2",
          "local",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Finally, clear the search text word

        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // verify the order of the complete playlist titles

        playlistsTitles = [
          "local_2",
          "S8 audio",
          "local",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Audio search word to playlist selection', () {
      testWidgets('''First, enter the search word 'al' in the
          'Youtube Link or Search' text field.''', (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the "Playlists" button in
        // order to display playlists and verify that the list of displayed
        // playlists corresponds to the search tet field. Then modify the search
        // word and finally empty it.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 2 letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is enabled and active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Now verify the order of the reduced playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now tap on the "Playlists" button
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the order of the reduced playlist titles

        List<String> playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now add the third letter of the 'al_' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '_',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is still enabled
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // And verify the order of the playlist titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        playlistsTitles = [
          "local_2",
        ];

        // Ensure that since the search icon button was used,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now remove the third and second letter of the 'al_' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'a',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is still enabled
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Then erase the second search word letter
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'a',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now verify the order of the augmented playlist titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now emptying the search text word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Playlist search word to audio selection', () {
      testWidgets('''First, enter the search word 'al' in the
          'Youtube Link or Search' text field.''', (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed playlist list. After that, click on the "Playlists" button in
        // order to hide the playlists and expand the audio list and verify that
        // the list of displayed audio corresponds to the search text field. Then
        // modify the search word and finally empty it.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 2 letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled butb inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the order of the reduced playlist titles

        List<String> playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now tap on the "Playlists" button to reduce the list
        // of playlists
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced selected playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now replace the second letter 'l' of 'al' by 'u' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'au',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is still enabled
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // And verify the order of the playlist titles. Since
        // the search icon button was used, modifying the search text
        // is applied at each search text change

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was used,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now empty the search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group(
        '''Audio search word set in playlist download view, then go to audio player
           view and back to playlist download view''', () {
      testWidgets(
          '''First, enter the search word 'al' in the 'Youtube Link or Search'
                     text field.''', (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio player view button
        // and then click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now we tap on the AudioPlayerView icon button to open
        // AudioPlayerView screen

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('audioPlayerViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button is now disabled,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''At end, clicking on audio play button. First, enter the
           search word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio play button to
        // start playing the audio and open the AudioPlayerView screen and then
        // click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        String remainingAudioTitle =
            "La surpopulation mondiale par Jancovici et Barrau";
        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          remainingAudioTitle,
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now we tap on the remaining audio play icon button to play the audio
        // and to open the AudioPlayerView screen

        final Finder lastDownloadedAudioListTileInkWellFinder =
            IntegrationTestUtil.findAudioItemInkWellWidget(
          audioTitle: remainingAudioTitle,
        );

        await tester.tap(lastDownloadedAudioListTileInkWellFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the reduced playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Clicking on audio title. First, enter the
           search word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio play button to
        // start playing the audio and open the AudioPlayerView screen and then
        // click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        String remainingAudioTitle =
            "La surpopulation mondiale par Jancovici et Barrau";
        List<String>
            audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          remainingAudioTitle,
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Now we tap on the remaining audio title to open the AudioPlayerView
        // screen

        // widget finder and tap on it
        final Finder lastDownloadedAudioListTileTextWidgetFinder =
            find.text(remainingAudioTitle);

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the reduced playlist audio titles

        audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst:
              audioTitlesSortedDownloadDateDescendingDefaultSortFilterParms,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group(
        'Playlist search word to audio player view and back to playlist download view',
        () {
      testWidgets('''Clicking on audio player view button. First, enter the
           search word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio player view button
        // and then click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is enabled and active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Now verify the order of the reduced playlist audio titles

        List<String> playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now we tap on the AudioPlayerView icon button to open
        // AudioPlayerView screen

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('audioPlayerViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the reduced playlist audio titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Clicking on audio play button. First, enter the
           search word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio play button to
        // start playing the audio and open the AudioPlayerView screen and then
        // click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        String remainingAudioTitle = "Les besoins artificiels par R.Keucheyan";

        List<String> playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlists list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now we tap on the remaining audio play icon button to play the audio
        // and to open the AudioPlayerView screen

        final Finder lastDownloadedAudioListTileInkWellFinder =
            IntegrationTestUtil.findAudioItemInkWellWidget(
          audioTitle: remainingAudioTitle,
        );

        await tester.tap(lastDownloadedAudioListTileInkWellFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the reduced playlist audio titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Clicking on audio title. First, enter the
           search word 'al' in the 'Youtube Link or Search' text field.''',
          (WidgetTester tester) async {
        // After entering 'al', verify that the search icon button is now enabled.
        // Then, click on the enabled search icon button and verify the reduced
        // displayed audio list. After that, click on the audio play button to
        // start playing the audio and open the AudioPlayerView screen and then
        // click on the playlist download view button.
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: true,
        );

        // Enter the two letters of the 'al' search word. The crazy integration
        // test does not always update the test field. To fix this bug, first
        // select the text field and then enter the text.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the two letters of the 'al' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'al',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        String remainingAudioTitle = "Les besoins artificiels par R.Keucheyan";
        List<String> playlistsTitles = [
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now we tap on the remaining audio title to open the AudioPlayerView
        // screen

        // widget finder and tap on it
        final Finder lastDownloadedAudioListTileTextWidgetFinder =
            find.text(remainingAudioTitle);

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // And return to the playlist download view
        Finder playlistDownloadViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(playlistDownloadViewNavButton);
        await tester.pumpAndSettle();

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
          tester: tester,
          searchIconButtonState: SearchIconButtonState.disabled,
        );

        // Now verify the order of the reduced playlist audio titles

        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group(
        '''Click and un-click on search icon button. This added functionality enables to
            use the search sentence on other playlists.''', () {
      testWidgets(
          '''First, enter the search word 'mo' in the 'Youtube Link or Search' text
            field. Then click and un-click on the search icon button, select another
            playlist and select a sort filter item ...''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.disabled);

        // Enter the two letters of the 'mo' search word.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 2 letters of the 'mo' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'mo',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled, but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is now active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Now verify the order of the reduced playlist audio titles

        List<String> playlistDisplayedAudioTitles = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // Now verify the order of the no longer reduced playlist
        // audio titles

        playlistDisplayedAudioTitles = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the order of the normal playlist titles

        List<String> playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // Now select the 'local' playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'local',
        );

        // Verify that the search text field content was conserved
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // Now tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // And verify the order of the default playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Tap on the search icon button to activate it on the 'local'
        // playlist
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the filtered playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
        ];

        // Ensure that since the search icon button was pressed,
        // the displayed audio is filtered.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Then, tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // And verify the order of the default playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        List<String> playlistDisplayedAudioTitlesLst = [
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Really short video",
          "morning _ cinematic video",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        await _selectAndApplySortFilterParms(
          tester: tester,
          playlistDisplayedAudioTitlesLst: playlistDisplayedAudioTitlesLst,
          sfParmsName: 'asc listened',
          textFieldContentStr: 'mo',
        );

        // Now tap on the search icon button to activate it on the 'local'
        // playlist
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the filtered playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
        ];

        // Then, re-tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // And verify the order of the 'asc listened' playlist audio
        // titles

        playlistDisplayedAudioTitles = [
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Really short video",
          "morning _ cinematic video",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the 'asc listened'
        // list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Re-tap on the search icon button to re-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And tap on the 'Toggle List' button to display the list
        // of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // Verify that the search icon button is enabled and active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Verify that the list of playlists is empty since the search
        // text field is applied to the playlist list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
          firstAudioListTileIndex: 6,
        );

        // Now tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the displayed playlist titles order
        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // And select the 'S8 audio' playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'S8 audio',
        );

        // Tap on the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        playlistDisplayedAudioTitlesLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        await _selectAndApplySortFilterParms(
          tester: tester,
          playlistDisplayedAudioTitlesLst: playlistDisplayedAudioTitlesLst,
          sfParmsName: 'asc listened',
          textFieldContentStr: 'mo',
        );

        // Re-tap on the search icon button to re-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the reduced playlist audio titles

        playlistDisplayedAudioTitles = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''First, select a sort filter item. Then, enter the search word 'mo' in the
           'Youtube Link or Search' text field. Then click and un-click on the search icon
           button, select another playlist ...''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        List<String> playlistDisplayedAudioTitlesLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        await _selectAndApplySortFilterParms(
          tester: tester,
          playlistDisplayedAudioTitlesLst: playlistDisplayedAudioTitlesLst,
          sfParmsName: 'asc listened',
          textFieldContentStr: '',
        );

        // Enter the two letters of the 'mo' search word.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 2 letters of the 'mo' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'mo',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Now verify the order of the reduced playlist audio titles

        List<String> playlistDisplayedAudioTitles = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now tap the 'Toggle List' button to show the list of playlist's.
        // Since the search icon button was pressed, the displayed playlist
        // list is empty since no playlist title contains the 'mo' search
        // word.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the order of the normal playlist titles

        List<String> playlistsTitles = [];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlist list is empty.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
          firstAudioListTileIndex: 5,
        );

        // And verify the displayd audio titles list
        playlistDisplayedAudioTitlesLst = [
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Since the displayed playlist list is empty due to the applied search
        // word, the displayed audio titles list is not filtered.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitlesLst,
        );

        // Now tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the displayed playlist titles list
        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // And verify the displayd audio titles list
        playlistDisplayedAudioTitlesLst = [
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Since the displayed playlist list is not filtered due to the
        // fact that the search icon button was un-pressed, the displayed
        // audio titles list start at index 3.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitlesLst,
          firstAudioListTileIndex: 3,
        );

        // Now re-tap on the search icon button to re-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And tap on the 'Toggle List' button to reduce the list of
        // playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the filtered audio titles list
        playlistDisplayedAudioTitles = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Now re-tap on the search icon button to de-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And tap on the 'Toggle List' button to redisplay the list of
        // playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now select the 'local' playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'local',
        );

        // Verify that the search text field content was conserved
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // Now tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // And verify the order of the default playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Tap on the search icon button to activate it on the 'local'
        // playlist
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the filtered playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Then, tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // And verify the order of the default playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
          "Really short video",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        playlistDisplayedAudioTitlesLst = [
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Really short video",
          "morning _ cinematic video",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        await _selectAndApplySortFilterParms(
          tester: tester,
          playlistDisplayedAudioTitlesLst: playlistDisplayedAudioTitlesLst,
          sfParmsName: 'asc listened',
          textFieldContentStr: 'mo',
        );

        // Now tap on the search icon button to activate it on the 'local'
        // playlist
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the filtered playlist audio titles

        playlistDisplayedAudioTitles = [
          "morning _ cinematic video",
        ];

        // Then, re-tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // And verify the order of the 'asc listened' playlist audio
        // titles

        playlistDisplayedAudioTitles = [
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Really short video",
          "morning _ cinematic video",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Ensure that since the search icon button was un-pressed,
        // the displayed audio list returned to the default list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Re-tap on the search icon button to re-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And tap on the 'Toggle List' button to display the list
        // of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the search text field content was not changed
        IntegrationTestUtil.verifyTextFieldContent(
          tester: tester,
          textFieldKeyStr: 'youtubeUrlOrSearchTextField',
          expectedTextFieldContent: 'mo',
        );

        // Verify that the search icon button is enabled and active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Verify that the list of playlists is empty since the search
        // text field is applied to the playlist list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
          firstAudioListTileIndex: 6,
        );

        // Now tap on the search icon button to deactivate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the displayed playlist titles order
        playlistsTitles = [
          "S8 audio",
          "local",
          "local_2",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
        );

        // And select the 'S8 audio' playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'S8 audio',
        );

        // Tap on the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        playlistDisplayedAudioTitlesLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
        ];

        // Now select the 'asc listened' sort/filter item in the dropdown
        // button items list

        // Tap on the current dropdown button item to open the dropdown
        // button items list

        await _selectAndApplySortFilterParms(
          tester: tester,
          playlistDisplayedAudioTitlesLst: playlistDisplayedAudioTitlesLst,
          sfParmsName: 'asc listened',
          textFieldContentStr: 'mo',
        );

        // Re-tap on the search icon button to re-activate it
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // And verify the order of the reduced playlist audio titles

        playlistDisplayedAudioTitles = [
          "La surpopulation mondiale par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''First, click on audio item to select it and go to the audio player view.
            Then, return to the playlist download view and enter the search word 'no'
            in the 'Youtube Link or Search' text field. Then click on the search icon
            button, then click on the 'Toggle List' button to show the empty list of
            playlists ...''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName:
              'sort_and_filter_audio_dialog_widget_three_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Verify that the search icon button is now disabled
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.disabled);

        // Click on "Jancovici m'explique l’importance des ordres de
        // grandeur face au changement climatique"
        await tester.tap(find.text(
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
        ));
        await tester.pumpAndSettle();

        // Then return to playlist download view
        Finder applicationViewNavButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(applicationViewNavButton);
        await tester.pumpAndSettle();

        // Enter the two letters of the 'no' search word.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 2 letters of the 'mo' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'no',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Verify that the search icon button is enabled, but inactive
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledInactive);

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the search icon button is now active
        IntegrationTestUtil.validateSearchIconButton(
            tester: tester,
            searchIconButtonState: SearchIconButtonState.enabledActive);

        // Now verify the order of the reduced playlist audio titles

        List<String> playlistDisplayedAudioTitles = [
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Ensure that since the search icon button was now pressed,
        // the displayed audio list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitles,
        );

        // Now tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the order of the filtered playlist titles

        List<String> playlistsTitles = [];

        // Ensure that since the search icon button was now pressed,
        // the displayed playlist list is modified.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistsTitles,
          firstAudioListTileIndex: 4,
        );

        // And verify the displayd audio titles list
        List<String> playlistDisplayedAudioTitlesLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Since the displayed playlist list is empty due to the applied search
        // word, the displayed audio titles list is not filtered.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitlesLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group(
        '''Use a search word to select audio's and start moving or copying one audio
          verifying the displayed target playlists is not filtered by the search
          sentence.''', () {
      testWidgets(
          '''Verifying the displayed target playlists is not filtered by the search
            sentence.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'copy_move_audio_integr_test_data',
          tapOnPlaylistToggleButton: false,
        );

        // Change the app language to English

        // Open the appbar right menu
        await tester.tap(find.byKey(const Key('appBarRightPopupMenu')));
        await tester.pumpAndSettle();

        // And tap on 'Select English' to change the language
        await tester.tap(find.text('Anglais'));
        await tester.pumpAndSettle();

        // Tap on the 'Toggle List' button to display the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Open the add playlist dialog by tapping the add playlist
        // button
        await tester.tap(find.byKey(const Key('addPlaylistButton')));
        await tester.pumpAndSettle();

        const String localTwoPlaylistTitle = 'local_two';

        // Enter the title of the local playlist
        await tester.enterText(
          find.byKey(const Key('playlistLocalTitleConfirmDialogTextField')),
          localTwoPlaylistTitle,
        );
        await tester.pumpAndSettle();

        // Confirm the addition by tapping the confirmation button in
        // the AlertDialog
        await tester
            .tap(find.byKey(const Key('addPlaylistConfirmDialogAddButton')));
        await tester.pumpAndSettle();

        // Close the warning dialog by tapping the ok button
        await tester.tap(find.byKey(const Key('warningDialogOkButton')));
        await tester.pumpAndSettle();

        // Enter the 'two' search word.

        // Select the text field
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();

        // Enter the 'two' search word
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'two',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the search sentence application

        List<String> playlistsTitles = [
          "local_two",
        ];

        List<String> audioTitles = [
          "audio learn test short video two",
          "audio learn test short video one",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Now tap on the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the search sentence application

        playlistsTitles = [];

        audioTitles = [
          "audio learn test short video two",
        ];

        IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
          tester: tester,
          playlistTitlesOrderedLst: playlistsTitles,
          audioTitlesOrderedLst: audioTitles,
        );

        // Verify that the target playlist list is not filtered
        // by the search sentence after tapping on the audio
        // item  move menu

        await _verifyTargetListTitles(
          tester: tester,
          moveOrCopyMenuKeyStr: 'popup_menu_move_audio_to_playlist',
        );

        // Verify that the target playlist list is not filtered
        // by the search sentence after tapping on the audio
        // item copy menu

        await _verifyTargetListTitles(
          tester: tester,
          moveOrCopyMenuKeyStr: 'popup_menu_copy_audio_to_playlist',
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });
  group('Rewind all playlist audio to start position test', () {
    testWidgets('''Rewind playlist audio for selected playlist''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistToRewindTitle = 'S8 audio';

      // Verify the play/pause icon button format and color of
      // all audio of the selected playlist

      List<String> audioTitles = [
        "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
        "La surpopulation mondiale par Jancovici et Barrau",
        "La résilience insulaire par Fiona Roche",
        "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        "Les besoins artificiels par R.Keucheyan",
        "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
      ];

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[0],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            kDarkAndLightEnabledIconColor, // not played icon color
        expectedIconBackgroundColor: Colors.black,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[1],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            kDarkAndLightEnabledIconColor, // not played icon color
        expectedIconBackgroundColor: Colors.black,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[2],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            Colors.white, // currently playing or paused icon color
        expectedIconBackgroundColor: kDarkAndLightEnabledIconColor,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[3],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            kDarkAndLightEnabledIconColor, // not played icon color
        expectedIconBackgroundColor: Colors.black,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[4],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            kSliderThumbColorInDarkMode, // Fully played audio item play icon color
        expectedIconBackgroundColor: Colors.black,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[5],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            Colors.white, // currently playing or paused icon color
        expectedIconBackgroundColor: kDarkAndLightEnabledIconColor,
      );

      IntegrationTestUtil.validateInkWellButton(
        tester: tester,
        audioTitle: audioTitles[6],
        expectedIcon: Icons.play_arrow,
        expectedIconColor:
            kSliderThumbColorInDarkMode, // Fully played audio item play icon color
        expectedIconBackgroundColor: Colors.black,
      );

      // Go to audio player view to verify the playlist current
      // audio position (La résilience insulaire par Fiona Roche)
      Finder appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Verify the current audio position
      Text audioPositionText = tester
          .widget<Text>(find.byKey(const Key('audioPlayerViewAudioPosition')));
      expect(audioPositionText.data, '2:34');

      Finder audioTitlePositionTextFinder =
          find.text("La résilience insulaire par Fiona Roche\n13:35");
      expect(audioTitlePositionTextFinder, findsOneWidget);

      // Return to playlist download view
      appScreenNavigationButton =
          find.byKey(const ValueKey('playlistDownloadViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Rewind all 'S8 audio" playlist audio's to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 4,
      );

      // Return to audio player view to verify the playlist current
      // audio position set to start (La résilience insulaire par Fiona Roche)
      appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Verify the current audio position
      audioPositionText = tester
          .widget<Text>(find.byKey(const Key('audioPlayerViewAudioPosition')));
      expect(audioPositionText.data, '0:00');

      // Go back to playlist download view
      appScreenNavigationButton =
          find.byKey(const ValueKey('playlistDownloadViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Tap the 'Toggle List' button to reduce the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      _verifyAllNowUnplayedAudioPlayPauseIconColor(
        tester: tester,
        audioTitles: audioTitles,
      );

      // Now play then pause "Les besoins artificiels par R.Keucheyan"
      // before rewinding the playlist audio to start position
      await _rewindPlaylistAfterPlayThenPauseAnAudio(
        tester: tester,
        appScreenNavigationButton: appScreenNavigationButton,
        doExpandPlaylistList: true,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        audioToPlayTitle:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        audioToPlayTitleAndDuration:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau\n6:29",
      );

      // Now play then pause "Ce qui va vraiment sauver notre espèce
      // par Jancovici et Barrau" before rewinding the playlist audio
      // to start position after having clicked on another audio item.
      await _rewindPlaylistAfterPlayThenPauseAnAudio(
        tester: tester,
        appScreenNavigationButton: appScreenNavigationButton,
        doExpandPlaylistList: false,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        audioToPlayTitle:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        audioToPlayTitleAndDuration:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau\n6:29",
        otherAudioTitleToTapOnBeforeRewinding:
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        otherAudioTitleToTapOnBeforeRewindingDuration:
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)\n20:32",
      );

      // Now play then pause "Ce qui va vraiment sauver notre espèce
      // par Jancovici et Barrau" before rewinding the playlist audio
      // to start position after having clicked on the same audio item,
      // which sets its position to 0 and so causes the rewind number
      // to be 0.
      await _rewindPlaylistAfterPlayThenPauseAnAudio(
        tester: tester,
        appScreenNavigationButton: appScreenNavigationButton,
        doExpandPlaylistList: false,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        audioToPlayTitle:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        audioToPlayTitleAndDuration:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau\n6:29",
        otherAudioTitleToTapOnBeforeRewinding:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        otherAudioTitleToTapOnBeforeRewindingDuration:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau\n6:29",
      );

      // Rewind again all playlist audio to start position. Since
      // the playlist was already rewinded, 0 audio will be rewinded !
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 0,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets('''After rewinding playlist audio for selected playlist, play
        then pause an audio, then select another audio and rewind again. Ensure
        the last selected audio remains being the current aidio. Bug fix check.''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: true,
      );

      const String youtubePlaylistToRewindTitle = 'S8 audio';

      // Rewind all 'S8 audio" playlist audio's to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 4,
      );

      // Tap the 'Toggle List' button to reduce the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      Finder appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));

      // Now play then pause "Ce qui va vraiment sauver notre espèce
      // par Jancovici et Barrau" before rewinding the playlist audio
      // to start position after having clicked on another audio item.
      await _rewindPlaylistAfterPlayThenPauseAnAudio(
        tester: tester,
        appScreenNavigationButton: appScreenNavigationButton,
        doExpandPlaylistList: true,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        audioToPlayTitle:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        audioToPlayTitleAndDuration:
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau\n6:29",
        otherAudioTitleToTapOnBeforeRewinding:
            "Les besoins artificiels par R.Keucheyan",
        otherAudioTitleToTapOnBeforeRewindingDuration:
            "Les besoins artificiels par R.Keucheyan\n19:05",
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Rewind playlist audio for unselected playlist. No other playlist
        is selected.''', (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistToRewindTitle = 'S8 audio';

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Deelect the Youtube playlist

      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: youtubePlaylistToRewindTitle,
      );

      // Rewind all unselected playlist audio to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets('''Rewind playlist audio for unselected playlist, other selected
        playlist exist''', (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistToRewindTitle = 'S8 audio';
      const String localPlaylistToSelectTitle = 'local';

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Select another playlist than the one whose audio will be
      // rewinded to start position

      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: localPlaylistToSelectTitle,
      );

      // Rewind all unselected playlist audio to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Rewind local playlist audio for unselected playlist, other selected
        playlist exist''', (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String localPlaylistToSelectTitle = 'local';

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Rewind all local playlist audio to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: localPlaylistToSelectTitle,
        numberOfRewindedAudio: 4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets('''Rewind local selected playlist audio to start position''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String localPlaylistToSelectTitle = 'local';

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Select another playlist than the one whose audio will be
      // rewinded to start position

      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: localPlaylistToSelectTitle,
      );

      // Rewind all unselected playlist audio to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: localPlaylistToSelectTitle,
        numberOfRewindedAudio: 4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''On audio player view, rewind playlist audio for selected playlist''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistToRewindTitle = 'S8 audio';

      // Verify the play/pause icon button format and color of
      // all audio of the selected playlist

      // Go to audio player view to test rewinding current playlist
      // audio position
      Finder appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Tap the 'Toggle List' button to show the list of playlist's.
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Rewind all playlist audio to start position
      await _tapOnRewindPlaylistAudioToStartPositionMenu(
        tester: tester,
        playlistToRewindTitle: youtubePlaylistToRewindTitle,
        numberOfRewindedAudio: 4,
      );

      // Verify the current audio position
      Text audioPositionText = tester
          .widget<Text>(find.byKey(const Key('audioPlayerViewAudioPosition')));
      expect(audioPositionText.data, '0:00');

      // Go back to playlist download view
      appScreenNavigationButton =
          find.byKey(const ValueKey('playlistDownloadViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      List<String> audioTitles = [
        "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
        "La surpopulation mondiale par Jancovici et Barrau",
        "La résilience insulaire par Fiona Roche",
        "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        "Les besoins artificiels par R.Keucheyan",
        "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
      ];

      _verifyAllNowUnplayedAudioPlayPauseIconColor(
        tester: tester,
        audioTitles: audioTitles,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Change application date format using the date format selection dialog',
      () {
    testWidgets(
        '''Check application date format set to the 3 available date formats
        and verify the effect everywhere in the application where the date format
        is applied. Then, the application will be restarted ...''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'date_format_dialog_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistTitle = 'S8 audio';

      List<String> audioSubTitles = [
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
      ];

      List<String> audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52 Audio downl duration: 0:00:00",
      ];

      List<String> audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 07/09/2025 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 19/08/2024 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 07/09/2025 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      List<String> audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 07/09/2025 at 17:22",
        "0:00:38.9 Listened on 07/09/2025 at 17:21",
        "0:13:39.0 Listened on 19/08/2024 at 14:46",
        "0:06:29.0 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Not listened",
      ];

      List<String> audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      List<String> audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 00/00/0000",
        "0:00:38.9 Video upload date: 00/00/0000",
        "0:06:29.0 Video upload date: 23/09/2023",
        "0:13:39.0 Video upload date: 10/09/2023",
        "0:06:29.0 Video upload date: 12/06/2022",
      ];

      List<String> audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      DateTime now = DateTime.now();

      // Verifying initial dd/MM/yyyy date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "12/06/2022",
        audioDownloadDateTime: "08/01/2024 16:35",
        playlistLastDownloadDateTime: "07/09/2025 16:55",
        commentCreationDate: '12/10/24',
        commentUpdateDate: '01/11/24',
        datePickerDateStr: DateFormat('dd/MM/yyyy').format(now),
        savePlaylistsAudioMp3DateFormat: "dd/MM/yyyy",
        savePlaylistsAudioMp3OldestDate: "26/12/2023",
        latestAudioDownloadDate: "07/09/2025",
      );

      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "mm/dd/yyyy",
        dateFormatToSelect: "MM/dd/yyyy",
        previouslySelectedDateFormat: "dd/MM/yyyy",
      );

      audioSubTitles = [
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
      ];

      audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52 Audio downl duration: 0:00:00",
      ];

      audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 09/07/2025 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 08/19/2024 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 09/07/2025 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 03/16/2024 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 09/07/2025 at 17:22",
        "0:00:38.9 Listened on 09/07/2025 at 17:21",
        "0:13:39.0 Listened on 08/19/2024 at 14:46",
        "0:06:29.0 Listened on 03/16/2024 at 17:09",
        "0:06:29.0 Not listened",
      ];

      audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
      ];

      audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 00/00/0000",
        "0:00:38.9 Video upload date: 00/00/0000",
        "0:06:29.0 Video upload date: 09/23/2023",
        "0:13:39.0 Video upload date: 09/10/2023",
        "0:06:29.0 Video upload date: 06/12/2022",
      ];

      audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
      ];

      // Verifying initial MM/dd/yyyy date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "06/12/2022",
        audioDownloadDateTime: "01/08/2024 16:35",
        playlistLastDownloadDateTime: "09/07/2025 16:55",
        commentCreationDate: '10/12/24',
        commentUpdateDate: '11/01/24',
        datePickerDateStr: DateFormat('MM/dd/yyyy').format(now),
        savePlaylistsAudioMp3DateFormat: "MM/dd/yyyy",
        savePlaylistsAudioMp3OldestDate: "12/26/2023",
        latestAudioDownloadDate: "09/07/2025",
      );

      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "yyyy/mm/dd",
        dateFormatToSelect: "yyyy/MM/dd",
        previouslySelectedDateFormat: "MM/dd/yyyy",
      );

      audioSubTitles = [
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
      ];

      audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52 Audio downl duration: 0:00:00",
      ];

      audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 2025/09/07 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 2024/08/19 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 2025/09/07 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 2024/03/16 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 2025/09/07 at 17:22",
        "0:00:38.9 Listened on 2025/09/07 at 17:21",
        "0:13:39.0 Listened on 2024/08/19 at 14:46",
        "0:06:29.0 Listened on 2024/03/16 at 17:09",
        "0:06:29.0 Not listened",
      ];

      audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
      ];

      audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 0000/00/00",
        "0:00:38.9 Video upload date: 0000/00/00",
        "0:06:29.0 Video upload date: 2023/09/23",
        "0:13:39.0 Video upload date: 2023/09/10",
        "0:06:29.0 Video upload date: 2022/06/12",
      ];

      audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
      ];

      // Verifying initial yyyy/MM/dd date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "2022/06/12",
        audioDownloadDateTime: "2024/01/08 16:35",
        playlistLastDownloadDateTime: "2025/09/07 16:55",
        commentCreationDate: '24/10/12',
        commentUpdateDate: '24/11/01',
        datePickerDateStr: DateFormat('yyyy/MM/dd').format(now),
        savePlaylistsAudioMp3DateFormat: "yyyy/MM/dd",
        savePlaylistsAudioMp3OldestDate: "2023/12/26",
        latestAudioDownloadDate: "2025/09/07",
      );

      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "dd/mm/yyyy",
        dateFormatToSelect: "dd/MM/yyyy",
        previouslySelectedDateFormat: "yyyy/MM/dd",
      );

      audioSubTitles = [
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
      ];

      audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52 Audio downl duration: 0:00:00",
      ];

      audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 07/09/2025 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 19/08/2024 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 07/09/2025 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 07/09/2025 at 17:22",
        "0:00:38.9 Listened on 07/09/2025 at 17:21",
        "0:13:39.0 Listened on 19/08/2024 at 14:46",
        "0:06:29.0 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Not listened",
      ];

      audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 00/00/0000",
        "0:00:38.9 Video upload date: 00/00/0000",
        "0:06:29.0 Video upload date: 23/09/2023",
        "0:13:39.0 Video upload date: 10/09/2023",
        "0:06:29.0 Video upload date: 12/06/2022",
      ];

      audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      // Verifying initial dd/MM/yyyy date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "12/06/2022",
        audioDownloadDateTime: "08/01/2024 16:35",
        playlistLastDownloadDateTime: "07/09/2025 16:55",
        commentCreationDate: '12/10/24',
        commentUpdateDate: '01/11/24',
        datePickerDateStr: DateFormat('dd/MM/yyyy').format(now),
        savePlaylistsAudioMp3DateFormat: "dd/MM/yyyy",
        savePlaylistsAudioMp3OldestDate: "26/12/2023",
        latestAudioDownloadDate: "07/09/2025",
      );

      // Setting date format to mm/dd/yyyy before restarting the
      // application
      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "mm/dd/yyyy",
        dateFormatToSelect: "MM/dd/yyyy",
        previouslySelectedDateFormat: "dd/MM/yyyy",
      );
    });
    testWidgets(
        '''After restarting the application, verify the application date format
        set in previous testWidgets() function to the 'MM/dd/yyyy' and verify the
        effect everywhere in the application where the date format is applied. Then,
        set date format to 'yyyy/MM/dd' and restart the application ...''',
        (WidgetTester tester) async {
      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Restarting the app
      await app.main();
      await tester.pumpAndSettle();

      DateTime now = DateTime.now();

      // The app was restarted after that 'mm/dd/yyyy' date format was set

      const String youtubePlaylistTitle = 'S8 audio';

      List<String> audioSubTitles = [
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
      ];

      List<String> audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52 Audio downl duration: 0:00:00",
      ];

      List<String> audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 09/07/2025 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 08/19/2024 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 09/07/2025 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 03/16/2024 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      List<String> audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 09/07/2025 at 17:22",
        "0:00:38.9 Listened on 09/07/2025 at 17:21",
        "0:13:39.0 Listened on 08/19/2024 at 14:46",
        "0:06:29.0 Listened on 03/16/2024 at 17:09",
        "0:06:29.0 Not listened",
      ];

      List<String> audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
      ];

      List<String> audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 00/00/0000",
        "0:00:38.9 Video upload date: 00/00/0000",
        "0:06:29.0 Video upload date: 09/23/2023",
        "0:13:39.0 Video upload date: 09/10/2023",
        "0:06:29.0 Video upload date: 06/12/2022",
      ];

      List<String> audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 01/07/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/08/2024 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 12/26/2023 at 09:45",
        "0:00:06.9 55 KB converted on 09/07/2025 at 16:55",
        "0:00:38.9 311 KB imported on 09/07/2025 at 16:52",
      ];

      // Verifying initial MM/dd/yyyy date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "06/12/2022",
        audioDownloadDateTime: "01/08/2024 16:35",
        playlistLastDownloadDateTime: "09/07/2025 16:55",
        commentCreationDate: '10/12/24',
        commentUpdateDate: '11/01/24',
        datePickerDateStr: DateFormat('MM/dd/yyyy').format(now),
        savePlaylistsAudioMp3DateFormat: "MM/dd/yyyy",
        savePlaylistsAudioMp3OldestDate: "12/26/2023",
        latestAudioDownloadDate: "09/07/2025",
      );

      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "yyyy/mm/dd",
        dateFormatToSelect: "yyyy/MM/dd",
        previouslySelectedDateFormat: "MM/dd/yyyy",
      );
    });
    testWidgets(
        '''After restarting the application, verify the application date format
        set in previous testWidgets() function to the ''yyyy/MM/dd'' and verify the
        effect everywhere in the application where the date format is applied.''',
        (WidgetTester tester) async {
      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Restarting the app
      await app.main();
      await tester.pumpAndSettle();

      DateTime now = DateTime.now();

      // The app was restarted after that 'yyyy/mm/dd' date format was set

      const String youtubePlaylistTitle = 'S8 audio';

      List<String> audioSubTitles = [
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
      ];

      List<String> audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52 Audio downl duration: 0:00:00",
      ];

      List<String> audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 2025/09/07 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 2024/08/19 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 2025/09/07 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 2024/03/16 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      List<String> audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 2025/09/07 at 17:22",
        "0:00:38.9 Listened on 2025/09/07 at 17:21",
        "0:13:39.0 Listened on 2024/08/19 at 14:46",
        "0:06:29.0 Listened on 2024/03/16 at 17:09",
        "0:06:29.0 Not listened",
      ];

      List<String> audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
      ];

      List<String> audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 0000/00/00",
        "0:00:38.9 Video upload date: 0000/00/00",
        "0:06:29.0 Video upload date: 2023/09/23",
        "0:13:39.0 Video upload date: 2023/09/10",
        "0:06:29.0 Video upload date: 2022/06/12",
      ];

      List<String> audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 2024/01/07 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 2024/01/08 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 2023/12/26 at 09:45",
        "0:00:06.9 55 KB converted on 2025/09/07 at 16:55",
        "0:00:38.9 311 KB imported on 2025/09/07 at 16:52",
      ];

      // Verifying initial yyyy/MM/dd date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "2022/06/12",
        audioDownloadDateTime: "2024/01/08 16:35",
        playlistLastDownloadDateTime: "2025/09/07 16:55",
        commentCreationDate: '24/10/12',
        commentUpdateDate: '24/11/01',
        datePickerDateStr: DateFormat('yyyy/MM/dd').format(now),
        savePlaylistsAudioMp3DateFormat: "yyyy/MM/dd",
        savePlaylistsAudioMp3OldestDate: "2023/12/26",
        latestAudioDownloadDate: "2025/09/07",
      );

      await _selectDateFormat(
        tester: tester,
        dateFormatToSelectLowCase: "dd/mm/yyyy",
        dateFormatToSelect: "dd/MM/yyyy",
        previouslySelectedDateFormat: "yyyy/MM/dd",
      );
    });
    testWidgets(
        '''After restarting the application, verify the application date format
        set in previous testWidgets() function to the 'dd/MM/yyyy' and verify the
        effect everywhere in the application where the date format is applied.''',
        (WidgetTester tester) async {
      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Restarting the app
      await app.main();
      await tester.pumpAndSettle();

      // The app was restarted after that 'dd/mm/yyyy' date format was set

      const String youtubePlaylistTitle = 'S8 audio';

      List<String> audioSubTitles = [
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
      ];

      List<String> audioSubTitlesWithAudioDownloadDuration = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45 Audio downl duration: 0:00:01",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35 Audio downl duration: 0:00:01",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55 Audio downl duration: 0:00:00",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52 Audio downl duration: 0:00:00",
      ];

      List<String> audioSubTitlesWithAudioRemainingDuration = [
        "0:00:06.9 Remaining 00:00:03 Listened on 07/09/2025 at 17:22",
        "0:13:39.0 Remaining 00:00:04 Listened on 19/08/2024 at 14:46",
        "0:00:38.9 Remaining 00:00:34 Listened on 07/09/2025 at 17:21",
        "0:06:29.0 Remaining 00:00:38 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Remaining 00:06:29 Not listened",
      ];

      List<String> audioSubTitlesLastListenedDateTimeDescending = [
        "0:00:06.9 Listened on 07/09/2025 at 17:22",
        "0:00:38.9 Listened on 07/09/2025 at 17:21",
        "0:13:39.0 Listened on 19/08/2024 at 14:46",
        "0:06:29.0 Listened on 16/03/2024 at 17:09",
        "0:06:29.0 Not listened",
      ];

      List<String> audioSubTitlesTitleAsc = [
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      List<String> audioSubTitlesVideoUploadDate = [
        "0:00:06.9 Video upload date: 00/00/0000",
        "0:00:38.9 Video upload date: 00/00/0000",
        "0:06:29.0 Video upload date: 23/09/2023",
        "0:13:39.0 Video upload date: 10/09/2023",
        "0:06:29.0 Video upload date: 12/06/2022",
      ];

      List<String> audioSubTitlesWithAudioDownloadSpeed = [
        "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16",
        "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
        "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
        "0:00:06.9 55 KB converted on 07/09/2025 at 16:55",
        "0:00:38.9 311 KB imported on 07/09/2025 at 16:52",
      ];

      DateTime now = DateTime.now();

      // Verifying initial dd/MM/yyyy date format application
      await _verifyDateFormatApplication(
        tester: tester,
        audioSubTitles: audioSubTitles,
        audioSubTitlesWithAudioDownloadDuration:
            audioSubTitlesWithAudioDownloadDuration,
        audioSubTitlesWithAudioRemainingDuration:
            audioSubTitlesWithAudioRemainingDuration,
        audioSubTitlesLastListenedDateTimeDescending:
            audioSubTitlesLastListenedDateTimeDescending,
        audioSubTitlesTitleAsc: audioSubTitlesTitleAsc,
        audioSubTitlesVideoUploadDate: audioSubTitlesVideoUploadDate,
        audioSubTitlesWithAudioDownloadSpeed:
            audioSubTitlesWithAudioDownloadSpeed,
        playlistTitle: youtubePlaylistTitle,
        videoUploadDate: "12/06/2022",
        audioDownloadDateTime: "08/01/2024 16:35",
        playlistLastDownloadDateTime: "07/09/2025 16:55",
        commentCreationDate: '12/10/24',
        commentUpdateDate: '01/11/24',
        datePickerDateStr: DateFormat('dd/MM/yyyy').format(now),
        savePlaylistsAudioMp3DateFormat: "dd/MM/yyyy",
        savePlaylistsAudioMp3OldestDate: "26/12/2023",
        latestAudioDownloadDate: "07/09/2025",
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Scrolling audio or playlists test', () {
    group('Scrolling audio test', () {
      testWidgets('''Automatic scrolling audio to display current audio.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Setting to this field the currently selected playlist title
        String localPlaylistToSelectTitle = 'local_2';

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Unselect the current playlist to verify no available audio
        // are handled correctly by the audio scroll determination

        // First, find the Playlist ListTile Text widget
        Finder localPlaylistToSelectListTileTextWidgetFinder =
            find.text(localPlaylistToSelectTitle);

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        Finder localPlaylistToSelectListTileWidgetFinder = find.ancestor(
          of: localPlaylistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        Finder localPlaylistToSelectListTileCheckboxWidgetFinder =
            find.descendant(
          of: localPlaylistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Tap the ListTile Playlist checkbox to unselect it: This ensure
        // a bug was solved
        await tester.tap(localPlaylistToSelectListTileCheckboxWidgetFinder);
        await tester.pumpAndSettle();

        // Select the empty local_5 playlist to verify no available audio
        // are handled correctly by the audio scroll determination

        localPlaylistToSelectTitle = 'local_5';

        // First, find the Playlist ListTile Text widget
        localPlaylistToSelectListTileTextWidgetFinder =
            find.text(localPlaylistToSelectTitle);

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        localPlaylistToSelectListTileWidgetFinder = find.ancestor(
          of: localPlaylistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        // and tap on it to select the playlist
        localPlaylistToSelectListTileCheckboxWidgetFinder = find.descendant(
          of: localPlaylistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Tap the ListTile Playlist checkbox to select it: This ensure
        // another bug was solved
        await tester.tap(localPlaylistToSelectListTileCheckboxWidgetFinder);
        await tester.pumpAndSettle();

        // Reselect the local_2 playlist

        localPlaylistToSelectTitle = 'local_2';

        // First, find the Playlist ListTile Text widget
        localPlaylistToSelectListTileTextWidgetFinder =
            find.text(localPlaylistToSelectTitle);

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        localPlaylistToSelectListTileWidgetFinder = find.ancestor(
          of: localPlaylistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        // and tap on it to select the playlist
        localPlaylistToSelectListTileCheckboxWidgetFinder = find.descendant(
          of: localPlaylistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Scrolling up the playlists list to display the local_2 playlist
        await tester.drag(
          find.byKey(const Key('expandable_playlist_list')),
          const Offset(0, 100), // Positive value for vertical drag to scroll up
        );
        await tester.pumpAndSettle();

        // Tap the ListTile Playlist checkbox to select it: This ensure
        // another bug was solved
        await tester.tap(localPlaylistToSelectListTileCheckboxWidgetFinder);
        await tester.pumpAndSettle();

        String newAudioToSelectTitle =
            '6-audio learn test short video two 23-06-10';
        String newAudioToSelectSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:23';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          newAudioTitle: newAudioToSelectTitle,
        );

        // Scrolling down the audios list in order to display the commented
        // audio title to delete

        // Find the audio list widget using its key
        final Finder listFinder = find.byKey(const Key('audio_list'));

        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, 100));
        await tester.pumpAndSettle();

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: newAudioToSelectSubTitle,
        );

        newAudioToSelectTitle = '7-audio learn test short video two 23-06-10';
        String newAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:22';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: '6-audio learn test short video two 23-06-10',
          newAudioTitle: newAudioToSelectTitle,
        );

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: newAudioSubTitle,
        );

        newAudioToSelectTitle = '3-audio learn test short video two 23-06-10';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: '7-audio learn test short video two 23-06-10',
          newAudioTitle: newAudioToSelectTitle,
          offsetValue: 500.0,
        );

        currentAudioSubTitle = '0:00:09.8 61 Ko importé le 30/10/2024 à 08:26';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Playlist list not displayed, automatic scrolling audio to display current
              audio.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: true, // playlists list not expanded
        );

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        String newAudioToSelectTitle =
            '8-audio learn test short video two 23-06-10';
        String newAudioToSelectSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:21';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          newAudioTitle: newAudioToSelectTitle,
        );

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: newAudioToSelectSubTitle,
        );

        newAudioToSelectTitle = '5-audio learn test short video two 23-06-10';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: '8-audio learn test short video two 23-06-10',
          newAudioTitle: newAudioToSelectTitle,
          offsetValue: 300.0,
        );

        currentAudioSubTitle = '0:00:09.8 61 Ko importé le 30/10/2024 à 08:24';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        newAudioToSelectTitle = '3-audio learn test short video two 23-06-10';

        // Go to audio player view to select another audio
        await _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView(
          tester: tester,
          currentAudioTitle: '5-audio learn test short video two 23-06-10',
          newAudioTitle: newAudioToSelectTitle,
          offsetValue: 100.0,
        );

        currentAudioSubTitle = '0:00:09.8 61 Ko importé le 30/10/2024 à 08:26';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Searching playlist and select it, verifying automatic scrolling
           audio displaying selected playlist current audio.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Setting to this field the currently selected playlist title
        String playlistToSelectTitle = 'local_2';

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Now enter the playlist search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'jeu',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Select the 'Jeunes pianistes extraordinaires' playlist

        playlistToSelectTitle = 'Jeunes pianistes extraordinaires';

        // First, find the Playlist ListTile Text widget
        Finder playlistToSelectListTileTextWidgetFinder =
            find.text(playlistToSelectTitle);

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        Finder playlistToSelectListTileWidgetFinder = find.ancestor(
          of: playlistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        // and tap on it to select the playlist
        Finder playlistToSelectListTileCheckboxWidgetFinder = find.descendant(
          of: playlistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Tap the ListTile Playlist checkbox to select it: This ensure
        // another bug was solved
        await tester.tap(playlistToSelectListTileCheckboxWidgetFinder);
        await tester.pumpAndSettle();

        String newAudioToSelectTitle =
            'EMOTIONAL AUDITION! young piano prodigy makes the Judges CRY and gets the GOLDEN BUZZER  FGT 2022';

        String newAudioSubTitle =
            '0:10:14.0 3.75 Mo à 1.64 Mo/sec le 03/11/2024 à 15:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: newAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Changing sort/filter parameter, automatic scrolling audio to display current
              audio.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: true, // playlists list not expanded
        );

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Now, selecting 'Défaut' dropdown button item to apply the
        // default sort/filter parms
        final Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        final Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        // Tap on the current dropdown button item to open the dropdown
        // button items list
        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // And select the default sort/filter item
        String defaultFrenchTitle = 'défaut';
        final Finder defaultDropDownTextFinder = find.text(defaultFrenchTitle);
        await tester.tap(defaultDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Setting searching audio word, automatic scrolling audio to display
              current audio whose title contains the search word.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: true, // playlists list not expanded
        );

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Now enter the audio search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '9-audio',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Selecting playlist in AudioPlayerView select it, verifying automatic scrolling
           audio displaying selected playlist current audio.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Setting to this field the currently selected playlist title
        String playlistToSelectTitle = 'local_2';

        // Setting to this variables the currently selected audio title of the
        // 'local_2' playlist
        String currentAudioTitle =
            '99-audio learn test short video two 23-06-10';
        String currentAudioSubTitle =
            '0:00:09.8 61 Ko importé le 30/10/2024 à 08:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Go to the audio player view
        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('audioPlayerViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Display the selectable playlists
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'Jeunes pianistes extraordinaires' playlist

        playlistToSelectTitle = 'Jeunes pianistes extraordinaires';

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitle,
        );

        // Now return to the playlist download view
        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        String newAudioToSelectTitle =
            'EMOTIONAL AUDITION! young piano prodigy makes the Judges CRY and gets the GOLDEN BUZZER  FGT 2022';

        String newAudioSubTitle =
            '0:10:14.0 3.75 Mo à 1.64 Mo/sec le 03/11/2024 à 15:19';

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: newAudioToSelectTitle,
          currentAudioSubTitle: newAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Scrolling playlist test', () {
      testWidgets(
          '''In playlist download view, selecting every available playlist and verifying
             it was scrolled correctly.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Now enter the playlist search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'jeu',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Select the 'Jeunes pianistes extraordinaires' playlist

        String playlistToSelectTitle = 'Jeunes pianistes extraordinaires';

        // First, find the Playlist ListTile Text widget
        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitle,
          verifyIfCheckboxIsChecked: false,
          tapOnCheckbox: true,
        );

        // Now remove the playlist search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitle,
          verifyIfCheckboxIsChecked: true,
          tapOnCheckbox: false,
        );

        // Now selecting and verifying all the next scrolled selected
        // playlists

        List<String> playlistTitleList = [
          'local_1',
          'local_2',
          'local_3',
          'local_4',
          'local_5',
          'local_6',
          'local_7',
          'local_8',
          'local_9',
          'local_10',
        ];

        for (String playlistToSelectTitle in playlistTitleList) {
          await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
            tester: tester,
            playlistToSelectTitle: playlistToSelectTitle,
            verifyIfCheckboxIsChecked: false,
            tapOnCheckbox: true,
          );

          await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
            tester: tester,
            playlistToSelectTitle: playlistToSelectTitle,
            verifyIfCheckboxIsChecked: true,
            tapOnCheckbox: false,
          );
        }

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''With search '_1' in playlist download view, selecting available playlist
             and verifying it was scrolled correctly.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Now enter the '_1' search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          '_1',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Verify the 'local_10' is correctly scrolled so that it is
        // visible
        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: 'local_10',
          verifyIfCheckboxIsChecked: true,
          tapOnCheckbox: false,
        );

        await _executeSearchWordScrollTest(
          tester: tester,
          playlistTitle: 'local_1',
          scrollUpOrDownPlaylistsList: 1000,
        );

        await _executeSearchWordScrollTest(
          tester: tester,
          playlistTitle: 'local_13',
          scrollUpOrDownPlaylistsList: -1000,
        );

        await _executeSearchWordScrollTest(
          tester: tester,
          playlistTitle: 'local_15',
          scrollUpOrDownPlaylistsList: -1000,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''In audio player view, selecting every available playlist and verifying
             it was scrolled correctly in playlist download view.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Now enter the playlist search word
        await tester.tap(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
        );
        await tester.pumpAndSettle();
        await tester.enterText(
          find.byKey(
            const Key('youtubeUrlOrSearchTextField'),
          ),
          'jeu',
        );
        await tester.pumpAndSettle(const Duration(milliseconds: 200));

        // Now tap on the search icon button
        await tester.tap(find.byKey(const Key('search_icon_button')));
        await tester.pumpAndSettle();

        // Select the 'Jeunes pianistes extraordinaires' playlist

        String playlistToSelectTitleInPlaylistDownloadView =
            'Jeunes pianistes extraordinaires';

        // First, find the Playlist ListTile Text widget
        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitleInPlaylistDownloadView,
          verifyIfCheckboxIsChecked: false,
          tapOnCheckbox: true,
        );

        await _onAudioPlayerViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistDownloadViewCurrentlySelectedPlaylistTitle:
              playlistToSelectTitleInPlaylistDownloadView,
          playlistToSelectTitleInAudioPlayerView: 'local_1',
        );

        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: 'local_1',
          verifyIfCheckboxIsChecked: true,
          tapOnCheckbox: false,
        );

        // Now selecting and verifying all the next scrolled selected
        // playlists

        List<String> playlistTitleList = [
          'local_1',
          'local_2',
          'local_3',
          'local_4',
          'local_5',
          'local_6',
          'local_7',
          'local_8',
          'local_9',
          'local_10',
        ];

        for (int i = 0; i < playlistTitleList.length - 2; i++) {
          String playlistToSelectTitle = playlistTitleList[i];
          String playlistToSelectTitleNext = playlistTitleList[i + 1];
          await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
            tester: tester,
            playlistToSelectTitle: playlistToSelectTitle,
            verifyIfCheckboxIsChecked: true,
            tapOnCheckbox: false,
          );

          await _onAudioPlayerViewCheckOrTapOnPlaylistCheckbox(
            tester: tester,
            playlistDownloadViewCurrentlySelectedPlaylistTitle:
                playlistToSelectTitle,
            playlistToSelectTitleInAudioPlayerView: playlistToSelectTitleNext,
          );
        }

        await _onAudioPlayerViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistDownloadViewCurrentlySelectedPlaylistTitle: 'local_9',
          playlistToSelectTitleInAudioPlayerView: 'local_10',
        );

        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: 'local_10',
          verifyIfCheckboxIsChecked: true,
          tapOnCheckbox: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''In playlist download view, move down a playlist located at bottom of
             the list of playlists by clicking on the move down icon button. This
             positions the moved playlist at top of the list of playlists. Then,
             verifying that it was scrolled correctly and it is visible.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Scrolling down the playlists list in order to make accessible
        // the lowest positioned playlist

        // Find the playlist list widget using its key
        final Finder listFinder =
            find.byKey(const Key('expandable_playlist_list'));

        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, -2000));
        await tester.pumpAndSettle();

        // Select the 'local_10' playlist

        String playlistToSelectTitle = 'local_10';

        // First, find the Playlist ListTile Text widget
        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitle,
          verifyIfCheckboxIsChecked: false,
          tapOnCheckbox: true,
        );

        // Tap on the move down playlist icon button in order to move
        // the lowest positioned playlist to top of the list of playlists
        await tester.tap(find.byKey(Key('move_down_playlist_button')));
        await tester.pumpAndSettle();

        // Now verify that the moved playlist is visible

        Finder playlistToSelectListTileTextWidgetFinder =
            find.text(playlistToSelectTitle).last;

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        Finder playlistToSelectListTileWidgetFinder = find.ancestor(
          of: playlistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        // and tap on it to select the playlist
        Finder playlistToSelectListTileCheckboxWidgetFinder = find.descendant(
          of: playlistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Verify that the Playlist ListTile checkbox is checked
        final Checkbox checkboxWidget = tester
            .widget<Checkbox>(playlistToSelectListTileCheckboxWidgetFinder);

        expect(checkboxWidget.value!, true);

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''In playlist download view, move up a playlist located at top of
             the list of playlists by clicking on the move up icon button. This
             positions the moved playlist at bottom of the list of playlists. Then,
             verifying that it was scrolled correctly and it is visible.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'scrolling_audio_and_playlists_test',
          tapOnPlaylistToggleButton: false,
        );

        // Select the 'Jeunes pianistes extraordinaires' top
        // playlist

        String playlistToSelectTitle = 'Jeunes pianistes extraordinaires';

        // First, find the Playlist ListTile Text widget
        await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
          tester: tester,
          playlistToSelectTitle: playlistToSelectTitle,
          verifyIfCheckboxIsChecked: false,
          tapOnCheckbox: true,
        );

        // Tap on the move up playlist icon button in order to move
        // the highest positioned playlist to bottom of the list of
        // playlists
        await tester.tap(find.byKey(Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        // Now verify that the moved playlist is visible

        Finder playlistToSelectListTileTextWidgetFinder =
            find.text(playlistToSelectTitle).last;

        // Then obtain the Playlist ListTile widget enclosing the Text widget
        // by finding its ancestor
        Finder playlistToSelectListTileWidgetFinder = find.ancestor(
          of: playlistToSelectListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the Checkbox widget located in the Playlist ListTile
        // and tap on it to select the playlist
        Finder playlistToSelectListTileCheckboxWidgetFinder = find.descendant(
          of: playlistToSelectListTileWidgetFinder,
          matching: find.byKey(const Key('playlist_checkbox_key')),
        );

        // Verify that the Playlist ListTile checkbox is checked
        final Checkbox checkboxWidget = tester
            .widget<Checkbox>(playlistToSelectListTileCheckboxWidgetFinder);

        expect(checkboxWidget.value!, true);

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });
  group('Delete filtered audio from playlist test', () {
    group('Delete filtered uncommented audio from playlist test', () {
      testWidgets(
          '''Select a filter SF parms and apply it. Then, click on the 'Delete
           Filtered Audio' playlist menu and verify the audio suppression as
           well as the audio selection.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'.
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder listenedNoComDropDownTextFinder =
            find.text(sortFilterParmName).last;
        await tester.tap(listenedNoComDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToDeleteBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToDeleteBeforeDeletionLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be deleted

        List<String> audioFileNameToDeleteLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne:
              "Delete audio's filtered by \"$sortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\"",
          confirmDialogMessage:
              "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            false,
          );
        }

        // Verify that the other files were not deleted

        List<String> remainingAudioFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 5);

        List<String> audioTitleAfterDeletionLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterDeletion in audioTitleAfterDeletionLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterDeletion),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been moved, the list is
        // empty.

        // Verify the empty displayed audio list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        listenedNoComDropDownTextFinder = find.text('default').last;
        await tester.tap(listenedNoComDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having deleted the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterDeletionLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "La résilience insulaire par Fiona Roche";
        currentAudioSubTitle =
            "0:13:35.0 4.97 MB at 2.67 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Select a fully listened commented audio located in default SF parms
           lower than the filtered SF audio which will be deleted (was downloaded
           before them). Then select a filter SF parms and apply it. Then, click
           on the 'Delete Filtered Audio' playlist menu and verify the audio
           suppression as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'.
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        String firstDownloadedAudioTitle =
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)";

        // Then, tap on the first downloaded Audio ListTile Text
        // widget finder to select this audio. This switch to the
        // audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder =
            find.text(firstDownloadedAudioTitle);

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Now, go back to the playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist
        String firstDownloadedAudioSubTitle =
            "0:20:32.0 7.51 MB at 2.44 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: firstDownloadedAudioTitle,
          currentAudioSubTitle: firstDownloadedAudioSubTitle,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToDeleteBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToDeleteBeforeDeletionLst,
        );

        // Verify the presence of the audio files which will be deleted

        List<String> audioFileNameToDeleteLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne:
              "Delete audio's filtered by \"$sortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\"",
          confirmDialogMessage:
              "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            false,
          );
        }

        // Verify that the other files were not deleted

        List<String> remainingAudioFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 5);

        List<String> audioTitleAfterDeletionLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterDeletion in audioTitleAfterDeletionLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterDeletion),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been deleted, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'listenedNoCom' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having deleted the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterDeletionLst,
        );

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: firstDownloadedAudioTitle,
          currentAudioSubTitle: firstDownloadedAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Select a partially listened not commented audio located in default SF
           parms lower than the filtered SF audio which will be deleted (was downloaded
           before them). Then select a filter SF parms and apply it. Then, click
           on the 'Delete Filtered Audio' playlist menu and verify the audio
           suppression as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'.
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        String partiallyListenedAudioTitle =
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau";

        // Then, tap on the previously downloaded Audio ListTile Text
        // widget finder to select this audio. This switch to the
        // audio player view
        final Finder previouslyDownloadedAudioListTileTextWidgetFinder =
            find.text(partiallyListenedAudioTitle);

        await tester.tap(previouslyDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Now, go back to the playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist
        String partiallyListenedAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: partiallyListenedAudioTitle,
          currentAudioSubTitle: partiallyListenedAudioSubTitle,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToDeleteBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToDeleteBeforeDeletionLst,
        );

        // Verify the presence of the audio files which will be deleted

        List<String> audioFileNameToDeleteLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne:
              "Delete audio's filtered by \"$sortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\"",
          confirmDialogMessage:
              "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            false,
          );
        }

        // Verify that the other files were not deleted

        List<String> remainingAudioFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 5);

        List<String> audioTitleAfterDeletionLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterDeletion in audioTitleAfterDeletionLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterDeletion),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been deleted, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'listenedNoCom' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having deleted the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterDeletionLst,
        );

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: partiallyListenedAudioTitle,
          currentAudioSubTitle: partiallyListenedAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Select a partially listened not commented audio located in default SF
           parms higher than the filtered SF audio which will be deleted (was downloaded
           after them). Then select a filter SF parms and apply it. Then, click
           on the 'Delete Filtered Audio' playlist menu and verify the audio
           suppression as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'.
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        // Scrolling up the audios list in order to display the last
        // downloaded audio title
        // Find the audio list widget using its key
        final Finder listFinder = find.byKey(const Key('audio_list'));

        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, 500));
        await tester.pumpAndSettle();

        String fullyThenPartiallyListenedAndFinallySelectedAudioTitle =
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";

        // Then, tap on the first downloaded Audio ListTile Text
        // widget finder to select this audio. This switch to the
        // audio player view. Since the audio is currently fully
        // played, it will be transformed to partially played.
        final Finder firstDownloadedAudioListTileTextWidgetFinder =
            find.text(fullyThenPartiallyListenedAndFinallySelectedAudioTitle);

        await tester.tap(firstDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tapping 2 times on the backward 1 minute icon button. Now, the
        // last downloaded audio of the playlist is partially listened.
        for (int i = 0; i < 5; i++) {
          await tester
              .tap(find.byKey(const Key('audioPlayerViewRewind1mButton')));
          await tester.pumpAndSettle();
        }

        // Now, go back to the playlist download view
        Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist
        String fullyThenPartiallyListenedAndFinallySelectedAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle:
              fullyThenPartiallyListenedAndFinallySelectedAudioTitle,
          currentAudioSubTitle:
              fullyThenPartiallyListenedAndFinallySelectedAudioSubTitle,
        );

        String partiallyThenFullyListenedAudioTitle =
            "La résilience insulaire par Fiona Roche";

        // Then, tap on the third downloaded Audio ListTile Text
        // widget finder to select this partially played audio.
        // This switch to the audio player view.
        final Finder thirdDownloadedAudioListTileTextWidgetFinder =
            find.text(partiallyThenFullyListenedAudioTitle);

        await tester.tap(thirdDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Now skip to the end of the audio to set it as fully played
        await tester
            .tap(find.byKey(const Key('audioPlayerViewSkipToEndButton')));
        await tester.pumpAndSettle();

        // Now, go back to the playlist download view
        audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist
        String partiallyThenFullyListenedAudioSubTitle =
            "0:13:35.0 4.97 MB at 2.67 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: partiallyThenFullyListenedAudioTitle,
          currentAudioSubTitle: partiallyThenFullyListenedAudioSubTitle,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToDeleteBeforeDeletionLst = [
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToDeleteBeforeDeletionLst,
        );

        // Verify the presence of the audio files which will be deleted

        List<String> audioFileNameToDeleteLst = [
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne:
              "Delete audio's filtered by \"$sortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\"",
          confirmDialogMessage:
              "Audio's to delete number: 2,\nCorresponding total file size: 9.96 MB,\nCorresponding total duration: 00:27:14.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            false,
          );
        }

        // Verify that the other files were not deleted

        List<String> remainingAudioFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 5);

        List<String> audioTitleAfterDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterDeletion in audioTitleAfterDeletionLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterDeletion),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been deleted, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'listenedNoCom' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having deleted the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterDeletionLst,
        );

        // Verify the currently selected audio title/subTitle of the
        // 'S8 audio' playlist

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle:
              fullyThenPartiallyListenedAndFinallySelectedAudioTitle,
          currentAudioSubTitle:
              fullyThenPartiallyListenedAndFinallySelectedAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Delete filtered commented audio from playlist test', () {
      testWidgets(
          '''Select the 'FullyListened' SF parms and apply it. Then, click on the 'Delete
           Filtered Audio' playlist menu and verify the displayed warning as well
           as the suppression of all playlist fully listened audio as well as their
           comments.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'FullyListened'
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        String sortFilterParmName = 'FullyListened';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'FullyListened' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'FullyListened'
        // sort/filter parms
        List<String> audioTitleToDeleteBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToDeleteBeforeDeletionLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later deleted

        List<String> audioFileNameToDeleteLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Verify the presence of the audio comment files which will be later
        // deleted or not

        List<String> audioCommentFileNameToDeleteLst = [
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.json",
        ];

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToDelete
            in audioCommentFileNameToDeleteLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToDelete),
            true,
          );
        }

        // Verify the presence of the audio picture json files which will be
        // later deleted or not

        List<String> availableAudioPictureFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.json",
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.json",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
        ];

        List<String> listPictureJpgFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'json',
        );

        expect(
          listPictureJpgFileNames,
          availableAudioPictureFileNameLst,
        );

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne: 'WARNING: you are going to',
          confirmDialogTitleTwo:
              "delete COMMENTED and uncommented audio's filtered by \"$sortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\". Watch the help to solve the problem ...",
          confirmDialogMessage:
              "Total audio's to delete number: 4,\nCOMMENTED audio's to delete number: 2,\nCorresponding total file size: 21.86 MB,\nCorresponding total duration: 00:59:45.",
          isHelpIconPresent: true,
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            false,
          );
        }

        // Verify that the audio comment files were deleted

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToDelete
            in audioCommentFileNameToDeleteLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToDelete),
            false,
          );
        }

        // Verify in source playlist directory that the audio picture
        // files were deleted

        List<String> audioPictureFileNameToDeleteLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.jpg",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        for (String audioPictureFileNameToDelete
            in audioPictureFileNameToDeleteLst) {
          expect(
            listCommentJsonFileNames.contains(audioPictureFileNameToDelete),
            false,
          );
        }

        // Verify that the other files were not deleted

        List<String> remainingAudioFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify that the other audio comment files were not deleted

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        final List<String> audioCommentFileNameNotDeletedLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
        ];

        for (String audioCommentFileNameNotDeleted
            in audioCommentFileNameNotDeletedLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameNotDeleted),
            true,
          );
        }

        // Verify that the other audio picture files were not deleted

        List<String> audioPictureFileNameNotDeletedLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'json',
        );

        for (String audioPictureFileNameNotDeleted
            in audioPictureFileNameNotDeletedLst) {
          expect(
            listCommentJsonFileNames.contains(audioPictureFileNameNotDeleted),
            true,
          );
        }

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 3);

        List<String> audioTitleAfterDeletionLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterDeletion in audioTitleAfterDeletionLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterDeletion),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been deleted, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'listenedNoCom' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having deleted the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterDeletionLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "La résilience insulaire par Fiona Roche";
        currentAudioSubTitle =
            "0:13:35.0 4.97 MB at 2.67 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''SF parms 'default' is applied. Then, click on the 'Delete Filtered
           Audio' playlist menu and verify the displayed warning as well as
           the suppression of all playlist fully listened audio as well as their
           comments.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String youtubePlaylistTitle = 'S8 audio';

        List<String> audioTitleBeforeDeletionLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeDeletionLst,
        );

        String defaultSortFilterParmName =
            'default'; // SF parm when opening the app

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later deleted

        List<String> audioFileNameToDeleteLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToDelete in audioFileNameToDeleteLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToDelete),
            true,
          );
        }

        // Verify the presence of the audio comment files which will be later
        // deleted

        List<String> audioCommentFileNameToDeleteLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.json",
        ];

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToDelete
            in audioCommentFileNameToDeleteLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToDelete),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          defaultSortFilterParmName,
        );

        // Now test deleting the filtered audio

        // Open the delete filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Delete Filtered Audio ...' sub-menu item
        await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistSubMenuKeyStr: 'popup_menu_delete_filtered_audio',
        );

        // Verifying and closing the confirm dialog message

        await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
          tester: tester,
          confirmDialogTitleOne: 'WARNING: you are going to',
          confirmDialogTitleTwo:
              "delete COMMENTED and uncommented audio's filtered by \"$defaultSortFilterParmName\" parms from playlist \"$youtubePlaylistTitle\". Watch the help to solve the problem ...",
          confirmDialogMessage:
              "Total audio's to delete number: 7,\nCOMMENTED audio's to delete number: 3,\nCorresponding total file size: 31.99 MB,\nCorresponding total duration: 01:27:27.",
          isHelpIconPresent: true,
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Verify that the audio files were deleted

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        expect(
          listMp3FileNames.isEmpty,
          true,
        );

        // Verify that the audio comment files were deleted

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        expect(
          listCommentJsonFileNames.isEmpty,
          true,
        );

        // Verify the 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(youtubePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToDelete in audioTitleBeforeDeletionLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToDelete),
            true,
          );
        }

        expect(
          loadedPlaylist.playableAudioLst.isEmpty,
          true,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the audioTitles content list is empty.

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });
  group('Move filtered audio from playlist test', () {
    group('Move filtered uncommented audio from playlist test', () {
      testWidgets('''Apply the 'listenedNoCom' SF parms. Then, click on the
          'Move Filtered Audio' playlist menu and verify the audio moved as well
          as the audio selection.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        List<String> audioTitleBeforeMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeMovingLst,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToMoveBeforeMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later moved

        List<String> audioFileNameToMoveLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test moving the filtered audio

        // Open the move filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Move Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: true,
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // moved from

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            false,
          );
        }

        // Verify that the other files were not moved

        List<String> remainingAudioFileNameLst = [
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify that the audio comment files were not moved

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        final List<String> audioCommentFileNameNotMovedLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.json",
        ];

        for (String audioCommentFileNameNotMoved
            in audioCommentFileNameNotMovedLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameNotMoved),
            true,
          );
        }

        // Verify the source 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(sourcePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToMove in audioTitleBeforeMovingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToMove),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 5);

        List<String> audioTitleAfterMovingLst = [
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterMoving in audioTitleAfterMovingLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterMoving),
            true,
          );
        }

        // Verify the target playlist directory in which the audio files
        // were moved

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle",
          fileExtension: 'mp3',
        );

        for (String audioFileNameMoved in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameMoved),
            true,
          );
        }

        // Verify in target playlist directory in which no audio
        // comment files were moved

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        expect(listCommentJsonFileNames.isEmpty, true);

        // Verify the target 'temp' playlist json file

        loadedPlaylist = loadPlaylist(targetPlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 3);

        downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToMove in audioTitleToMoveBeforeMovingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToMove),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 3);

        playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToMove in audioTitleToMoveBeforeMovingLst) {
          expect(
            playableAudioLst.contains(audioTitleToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been moved, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'default' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "La résilience insulaire par Fiona Roche";
        currentAudioSubTitle =
            "0:13:35.0 4.97 MB at 2.67 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the moved audioTitles displayed by applying the
        // 'default' SF parms

        audioTitleToMoveBeforeMovingLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Select a fully listened commented audio located in default
           SF parms lower than the filtered SF audio which will be moved (was downloaded
           before them). Then select 'listenedNoCom' SF parms and apply it. Then,
           click on the 'Move Filtered Audio' playlist menu and verify the audio
           move as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a fully listened audio downloaded before the
        // audio which will be moved
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)");

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Go back to playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToMoveBeforeMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Verify the presence of the audio files which will be later moved

        List<String> audioFileNameToMoveLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test moving the filtered audio

        // Open the move filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Move Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: true,
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // moved from

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            false,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)";
        String currentAudioSubTitle =
            "0:20:32.0 7.51 MB at 2.44 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Select a partially listened not commented audio located in default SF
           parms lower than the filtered SF audio which will be moved (was downloaded
           before them). Then select 'listenedNoCom' SF parms and apply it. Then,
           click  on the 'Move Filtered Audio' playlist menu and verify the audio
           move as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a partially listened audio downloaded before the
        // audio which will be moved
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        );

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on the comment icon button to open the comment add list
        // dialog
        final Finder commentInkWellButtonFinder = find.byKey(
          const Key('commentsInkWellButton'),
        );

        await tester.tap(commentInkWellButtonFinder);
        await tester.pumpAndSettle();

        // Now tap on the delete comment icon button to delete the comment
        await tester.tap(find.byKey(const Key('deleteCommentIconButton')));
        await tester.pumpAndSettle();

        // Confirm the deletion of the comment
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToMoveBeforeMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Verify the presence of the audio files which will be later moved

        List<String> audioFileNameToMoveLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test moving the filtered audio

        // Open the move filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Move Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: true,
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // moved from

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            false,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau";
        String currentAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Select a partially listened not commented audio located in
           default SF parms higher than the filtered SF audio which will be moved
           (was downloaded after them). Then copy a fully listened not commented
           audio to the target playlist. Then select 'listenedNoCom' SF parms and
           apply it. Then, click on the 'Move Filtered Audio' playlist menu and
           verify the audio move as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a fully listened and commented audio downloaded
        // before the audio which will be moved and delete its comment in
        // order for it to be able to be moved. Then copy it to the target
        // playlist so that it won't be moved.
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder firstDownloadedAudioListTileTextWidgetFinder = find.text(
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        );

        await tester.tap(firstDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on the comment icon button to open the comment add list
        // dialog
        final Finder commentInkWellButtonFinder = find.byKey(
          const Key('commentsInkWellButton'),
        );

        await tester.tap(commentInkWellButtonFinder);
        await tester.pumpAndSettle();

        // Now tap on the delete comment icon button to delete the comment
        await tester.tap(find.byKey(const Key('deleteCommentIconButton')));
        await tester.pumpAndSettle();

        // Confirm the deletion of the comment
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Now, copy this audio to the target playlist so that when
        // moving the uncommented and fully listened audio, this audio
        // won't be moved.

        // Now we want to tap the popup menu of the Audio ListTile
        // "3 fois où un économiste m'a ouvert les yeux (Giraud,
        // Lefournier, Porcher)"

        // Then obtain the Audio ListTile widget enclosing the Text widget by
        // finding its ancestor
        Finder sourceAudioListTileWidgetFinder = find.ancestor(
          of: firstDownloadedAudioListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the leading menu icon button of the Audio ListTile
        // and tap on it
        Finder sourceAudioListTileLeadingMenuIconButton = find.descendant(
          of: sourceAudioListTileWidgetFinder,
          matching: find.byIcon(Icons.menu),
        );

        // Tap the leading menu icon button to open the popup menu
        await tester.tap(sourceAudioListTileLeadingMenuIconButton);
        await tester.pumpAndSettle();

        // Now find the copy audio popup menu item and tap on it
        final Finder popupCopyMenuItem =
            find.byKey(const Key("popup_menu_copy_audio_to_playlist"));

        await tester.tap(popupCopyMenuItem);
        await tester.pumpAndSettle();

        // Find the RadioListTile target playlist to which the audio
        // will be copied

        final Finder targetPlaylistRadioListTile = find
            .ancestor(
              of: find.text(targetPlaylistTitle),
              matching: find.byType(ListTile),
            )
            .last;

        // Tap the target playlist RadioListTile to select it
        await tester.tap(targetPlaylistRadioListTile);
        await tester.pumpAndSettle();

        // Now find the confirm button and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now find the ok button of the confirm dialog
        // and tap on it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')));
        await tester.pumpAndSettle();

        // Scrolling up the audios list in order to display the last
        // downloaded audio title

        // Find the audio list widget using its key
        final Finder listFinder = find.byKey(const Key('audio_list'));

        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, 400));
        await tester.pumpAndSettle();

        // Now, select a fully listened audio downloaded after the
        // audio which will be moved and transform it to partially
        // played audio
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
        );

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on back 1 minute button to set it partially played
        await tester
            .tap(find.byKey(const Key('audioPlayerViewRewind1mButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder dropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(dropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToMoveBeforeMovingLst = [
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Verify the presence of the audio files which will be later
        // tried to be moved

        List<String> audioFileNameToMoveLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now test moving the filtered audio

        // Open the move filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Move Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: true,
          movedOrCopiedAudioNumber: 1,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 1,
        );

        // Verify in source playlist directory that the audio file were
        // moved from. Only one was moved since the other was copied before
        // on the target playlist

        List<String> audioFileNameMovedLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameMovedLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            false,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        dropDownTextFinder = find.text('default').last;
        await tester.tap(dropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";
        String currentAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the moved audioTitles displayed by applying the
        // 'default' SF parms

        audioTitleToMoveBeforeMovingLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Move filtered commented audio from playlist test', () {
      testWidgets('''Select the 'toMoveOrCopy' SF parms and apply it. Then,
           click on the 'Move Filtered Audio' playlist menu and verify the displayed
           warning as well as the move of all playlist fully listened audio as well
           as their comments. Verification done on source as well as target playlists.''',
          (WidgetTester tester) async {
        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        List<String> audioTitleBeforeMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'toMoveOrCopy'
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeMovingLst,
        );

        String sortFilterParmName = 'toMoveOrCopy';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'toMoveOrCopy' sort/filter item
        Finder toMoveOrCopyDropDownTextFinder =
            find.text(sortFilterParmName).last;
        await tester.tap(toMoveOrCopyDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'toMoveOrCopy'
        // sort/filter parms
        const String audioTitleOne =
            "La surpopulation mondiale par Jancovici et Barrau";
        const String audioTitleTwo =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        const String audioTitleThree =
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)";

        List<String> audioTitleToMoveBeforeMovingLst = [
          audioTitleOne,
          audioTitleTwo,
          audioTitleThree,
        ];

        // Verify the displayed audio list after selecting the 'toMoveOrCopy'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later moved

        List<String> audioFileNameToMoveLst = [
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Verify the presence of the audio comment files which will be later
        // moved

        List<String> audioCommentFileNameToMoveLst = [
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
        ];

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToMove
            in audioCommentFileNameToMoveLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToMove),
            true,
          );
        }

        // Verify the presence of the application audio picture files which
        // will be not be moved

        List<String> availableAudioPictureFileNameLst = [
          "Barrau.jpg",
          "Jancovici.jpg",
          "Prière.jpg",
        ];

        List<String> listPictureJpgFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        expect(
          listPictureJpgFileNames,
          availableAudioPictureFileNameLst,
        );

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test moving the filtered audio

        // Open the move filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Move Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: true,
          movedOrCopiedAudioNumber: 3,
          commentedAudioNumber: 1,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // moved from

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            false,
          );
        }

        // Verify in source playlist directory that the audio comment files
        // were moved from

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToMove
            in audioCommentFileNameToMoveLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToMove),
            false,
          );
        }

        // Verify in source playlist directory that the audio json picture
        // files were moved from

        List<String> audioPictureJsonFileNameToMoveLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.json",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'json',
        );

        for (String audioPictureFileNameToMove
            in audioPictureJsonFileNameToMoveLst) {
          expect(
            listCommentJsonFileNames.contains(audioPictureFileNameToMove),
            false,
          );
        }

        // Verify that the other files were not moved

        List<String> remainingAudioFileNameLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094546-La résilience insulaire par Fiona Roche 24-01-03.mp3",
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.mp3",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.mp3",
        ];

        for (String remainingAudioFileName in remainingAudioFileNameLst) {
          expect(
            listMp3FileNames.contains(remainingAudioFileName),
            true,
          );
        }

        // Verify that the other audio comment files were not moved

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        final List<String> audioCommentFileNameNotMovedLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
        ];

        for (String audioCommentFileNameNotMoved
            in audioCommentFileNameNotMovedLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameNotMoved),
            true,
          );
        }

        // Verify that the other audio picture files were not moved

        List<String> audioPictureFileNameNotMovedLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'json',
        );

        for (String audioPictureFileNameNotMoved
            in audioPictureFileNameNotMovedLst) {
          expect(
            listCommentJsonFileNames.contains(audioPictureFileNameNotMoved),
            true,
          );
        }

        // Verify the source 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(sourcePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToMove in audioTitleBeforeMovingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToMove),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 4);

        List<String> audioTitleAfterMovingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La résilience insulaire par Fiona Roche",
          "Les besoins artificiels par R.Keucheyan",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterMoving in audioTitleAfterMovingLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterMoving),
            true,
          );
        }

        // Verify the target playlist directory in which the audio files
        // were moved

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle",
          fileExtension: 'mp3',
        );

        for (String audioFileNameMoved in audioFileNameToMoveLst) {
          expect(
            listMp3FileNames.contains(audioFileNameMoved),
            true,
          );
        }

        // Verify in target playlist directory in which the audio comment
        // files were moved

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameMoved
            in audioCommentFileNameToMoveLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameMoved),
            true,
          );
        }

        // Verify the target playlist directory in which the audio picture json
        // files were moved

        final String tempPlaylistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kPictureDirName";

        listPictureJpgFileNames = DirUtil.listFileNamesInDir(
          directoryPath: tempPlaylistPictureDir,
          fileExtension: 'json',
        );

        for (String audioPictureFileNameMoved
            in audioPictureJsonFileNameToMoveLst) {
          expect(
            listPictureJpgFileNames.contains(audioPictureFileNameMoved),
            true,
          );
        }

        // Verify the target 'temp' playlist json file

        loadedPlaylist = loadPlaylist(targetPlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 4);

        downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleMoved in audioTitleToMoveBeforeMovingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleMoved),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 4);

        playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleMoved in audioTitleToMoveBeforeMovingLst) {
          expect(
            playableAudioLst.contains(audioTitleMoved),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'toMoveOrCopy'
        // sort/filter parms. Since they have been moved, the list is
        // empty.

        // Verify the empty displayed audio list before selecting the
        // 'default' Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: [],
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        toMoveOrCopyDropDownTextFinder = find.text('default').last;
        await tester.tap(toMoveOrCopyDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleAfterMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "La résilience insulaire par Fiona Roche";
        currentAudioSubTitle =
            "0:13:35.0 4.97 MB at 2.67 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the moved audioTitles displayed by applying the
        // 'default' SF parms

        audioTitleToMoveBeforeMovingLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToMoveBeforeMovingLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the moved audio's to which a picture is associated

        const String pictureFileNameOne =
            "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json";
        const String pictureFileNameTwo =
            "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.json";

        final String pictureFilePathNameOne =
            "$tempPlaylistPictureDir${path.separator}$pictureFileNameOne";
        final String pictureFilePathNameTwo =
            "$tempPlaylistPictureDir${path.separator}$pictureFileNameTwo";
        const String audioTitleOneDurationStr = '7:38';
        const String audioTitleTwoDurationStr = '13:39';

        List<String> movedAudioPictureFileNameLst = [
          pictureFileNameTwo,
          pictureFileNameOne,
        ];

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: tempPlaylistPictureDir,
          pictureFileNameOne: pictureFilePathNameOne,
          audioForPictureTitle: audioTitleOne, // La surpopulation mondiale ...
          audioForPictureTitleDurationStr: audioTitleOneDurationStr,
          playlistAudioPictureJsonFileNameLst: movedAudioPictureFileNameLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Now, go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: tempPlaylistPictureDir,
          pictureFileNameOne: pictureFilePathNameTwo,
          audioForPictureTitle:
              audioTitleTwo, // Le Secret de la RÉSILIENCE  ...
          audioForPictureTitleDurationStr: audioTitleTwoDurationStr,
          playlistAudioPictureJsonFileNameLst: movedAudioPictureFileNameLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      group('Move default filtered commented audio from playlist test', () {
        testWidgets(
            '''SF parms 'default'. Move Youtube->local. Then, click on the
           'Move Filtered Audio' playlist menu and verify the displayed warning
           indicating that the move operation can not be done when 'default'
           is applyed.''', (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'S8 audio';
          const String targetPlaylistTitle = 'temp';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test moving the filtered audio

          // Open the move filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Move Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_move_filtered_audio',
          );

          // Select the target 'temp' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be moved

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be moved from Youtube playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'temp' target playlist

          // Select the 'temp' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no moved audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: ["morning _ cinematic video"],
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'S8 audio' playlist
          String currentAudioTitle = "morning _ cinematic video";
          String currentAudioSubTitle =
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''SF parms 'default'. Move Youtube->Youtube. Then, click on the
           'Move Filtered Audio' playlist menu and verify the displayed warning
           indicating that the move operation can not be done when 'default'
           is applyed.''', (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: true,
          );

          const String sourcePlaylistTitle = 'S8 audio';
          const String targetPlaylistTitle = 'Maria Valtorta';

          // Tap the 'Toggle List' button to show the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test moving the filtered audio

          // Open the move filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Move Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_move_filtered_audio',
          );

          // Select the target 'Maria Valtorta' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be moved

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be moved from Youtube playlist "$sourcePlaylistTitle" to Youtube playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'Maria Valtorta' target playlist

          // Select the 'Maria Valtorta' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no moved audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: [
              "What place Maria Valtorta takes in your spiritual journey",
            ],
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'Maria Valtorta' playlist
          String currentAudioTitle =
              "What place Maria Valtorta takes in your spiritual journey";
          String currentAudioSubTitle =
              "0:06:01.3 2.20 MB at 595 KB/sec on 03/06/2025 at 16:48";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''SF parms 'default'. Move local->Youtube. Then, click on the
           'Move Filtered Audio' playlist menu and verify the displayed warning
           indicating that the move operation can not be done when 'default'
           is applyed.''', (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'temp';
          const String targetPlaylistTitle = 'S8 audio';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test moving the filtered audio

          // Open the move filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Move Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_move_filtered_audio',
          );

          // Select the target 'temp' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be moved

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be moved from local playlist "$sourcePlaylistTitle" to Youtube playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'temp' target playlist

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no moved audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: [
              "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
            ],
            firstAudioListTileIndex: 3,
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'S8 audio' playlist
          String currentAudioTitle =
              "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
          String currentAudioSubTitle =
              '0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16';

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets('''SF parms 'default'. Move local->local. Then, click on the
           'Move Filtered Audio' playlist menu and verify the displayed warning
           indicating that the move operation can not be done when 'default'
           is applyed.''', (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'temp';
          const String targetPlaylistTitle = 'local';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test moving the filtered audio

          // Open the move filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Move Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_move_filtered_audio',
          );

          // Select the target 'temp' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be moved

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be moved from local playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'local' target playlist

          // Select the 'local' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no moved audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: [
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique"
            ],
            firstAudioListTileIndex: 1,
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'local' playlist
          String currentAudioTitle =
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";

          String currentAudioSubTitle =
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
      });
    });
  });
  group('Copy filtered audio from playlist test', () {
    group('Copy filtered uncommented audio from playlist test', () {
      testWidgets('''Apply the 'listenedNoCom' SF parms. Then, click
          on the 'Copy Filtered Audio' playlist menu and verify the audio copied
          as well as the audio selection.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        List<String> audioTitleBeforeCopyingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'listenedNoCom'
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeCopyingLst,
        );

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToCopyLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later copied

        List<String> audioFileNameToCopyLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test copying the filtered audio

        // Open the copy filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: false,
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files
        // are present after they have been copied

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Verify the source 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(sourcePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToCopy in audioTitleBeforeCopyingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToCopy),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 7);

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterCopying in audioTitleBeforeCopyingLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterCopying),
            true,
          );
        }

        // Verify the target playlist directory in which the audio files
        // were copied

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle",
          fileExtension: 'mp3',
        );

        for (String audioFileNameCopied in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameCopied),
            true,
          );
        }

        // Verify in target playlist directory in which no audio
        // comment files were copied

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        expect(listCommentJsonFileNames.isEmpty, true);

        // Verify the target 'temp' playlist json file

        loadedPlaylist = loadPlaylist(targetPlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 3);

        downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToCopy in audioTitleToCopyLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToCopy),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 3);

        playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToCopy in audioTitleToCopyLst) {
          expect(
            playableAudioLst.contains(audioTitleToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        // The source playlist is selected.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'listenedNoCom'
        // sort/filter parms. Since they have been copied, the list was
        // not changed.

        // Verify the filtered audio list before selecting the 'default'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having copied the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeCopyingLst,
        );

        // Setting to this variables the currently selected audio
        // title/subTitle of the 'S8 audio' playlist
        currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the moved audioTitles displayed by applying the
        // 'default' SF parms

        audioTitleToCopyLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Setting to this variables the currently selected audio
        // title/subTitle of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Using very long playlist list. This test only verifies that the unique
             playlist selection dialog can display a very long playlist list.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'playlist_selectable_dialog_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau";

        // Now we want to tap the popup menu of the Audio ListTile
        // "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau"

        // First, find the Audio sublist ListTile Text widget
        Finder sourceAudioListTileTextWidgetFinder =
            find.text(currentAudioTitle);

        // Then obtain the Audio ListTile widget enclosing the Text widget by
        // finding its ancestor
        Finder sourceAudioListTileWidgetFinder = find.ancestor(
          of: sourceAudioListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the leading menu icon button of the Audio ListTile
        // and tap on it
        Finder sourceAudioListTileLeadingMenuIconButton = find.descendant(
          of: sourceAudioListTileWidgetFinder,
          matching: find.byIcon(Icons.menu),
        );

        // Tap the leading menu icon button to open the popup menu
        await tester.tap(sourceAudioListTileLeadingMenuIconButton);
        await tester.pumpAndSettle();

        // Now find the copy audio popup menu item and tap on it
        Finder popupCopyMenuItem =
            find.byKey(const Key("popup_menu_copy_audio_to_playlist"));

        await tester.tap(popupCopyMenuItem);
        await tester.pumpAndSettle();

        // Check the value of the select one playlist AlertDialog
        // dialog title
        Text alertDialogTitle = tester.widget(
            find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
        expect(alertDialogTitle.data, 'Select a Playlist');

        // Find the RadioListTile target playlist to which the audio
        // will be copied

        String longPlaylistTitle =
            "Add padding or margins To prevent the content from touching the edges of the dialog";
        String lastPlaylistTitle = "lo20";

        Finder targetPlaylistRadioListTile = find
            .ancestor(
              of: find.text(longPlaylistTitle),
              matching: find.byType(ListTile),
            )
            .last;

        expect(targetPlaylistRadioListTile, findsOneWidget);

        // Dropdown the list of playlists in the select one playlist
        // dialog

        // Find the playlist list widget using its key
        final listFinder = find.byKey(const Key('selectable_playlist_list'));
        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, -1000));
        await tester.pumpAndSettle();

        targetPlaylistRadioListTile = find
            .ancestor(
              of: find.text(lastPlaylistTitle),
              matching: find.byType(ListTile),
            )
            .last;

        expect(targetPlaylistRadioListTile, findsOneWidget);

        // Tap the target playlist RadioListTile to select it
        await tester.tap(targetPlaylistRadioListTile);
        await tester.pumpAndSettle();

        // Now find the confirm button and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now verifying the confirm dialog message
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              'Audio "$currentAudioTitle" copied from Youtube playlist "$sourcePlaylistTitle" to local playlist "$lastPlaylistTitle".',
          isWarningConfirming: true,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Select a fully listened commented audio located
           in default SF parms lower than the filtered SF audio which will be copied
           (was downloaded before them). Then select 'listenedNoCom' SF parms and
           apply it. Then, click on the 'Copy Filtered Audio' playlist menu and
           verify the audio copy as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a fully listened audio downloaded before the
        // audio which will be copied
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)");

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Go back to playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToCopyLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Verify the presence of the audio files which will be later copied

        List<String> audioFileNameToCopyLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test copying the filtered audio

        // Open the copy filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: false, // Copy
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // not deleted since they were copied

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having copied the filtered audio

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)";
        String currentAudioSubTitle =
            "0:20:32.0 7.51 MB at 2.44 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Select a partially listened not commented audio located
           in default SF parms lower than the filtered SF audio which will be copied
           (was downloaded before them). Then select 'listenedNoCom' SF parms and
           apply it. Then, click on the 'Copy Filtered Audio' playlist menu and
           verify the audio copy as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a partially listened audio downloaded before the
        // audio which will be copied
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        );

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on the comment icon button to open the comment add list
        // dialog
        final Finder commentInkWellButtonFinder = find.byKey(
          const Key('commentsInkWellButton'),
        );

        await tester.tap(commentInkWellButtonFinder);
        await tester.pumpAndSettle();

        // Now tap on the delete comment icon button to delete the comment
        await tester.tap(find.byKey(const Key('deleteCommentIconButton')));
        await tester.pumpAndSettle();

        // Confirm the deletion of the comment
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        final Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> audioTitleToCopyLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Verify the presence of the audio files which will be later copied

        List<String> audioFileNameToCopyLst = [
          "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test moving the filtered audio

        // Open the copy filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: false, // Copy
          movedOrCopiedAudioNumber: 2,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the audio files were
        // not moved

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having copied the filtered audio

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau";
        String currentAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''After copy, select a partially listened not commented audio
           located in default SF parms higher than the filtered SF audio which will
           be copied (was downloaded after them). Then copy a fully listened not
           commented audio to the target playlist. Then select 'listenedNoCom' SF
           parms and apply it. Then, click on the 'Copy Filtered Audio' playlist
           menu and verify the audio copy as well as the audio selection.''',
          (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        // First, select a fully listened and commented audio downloaded
        // before the audio which will be copied and delete its comment in
        // order for it to be able to be copied. Then copy it to the target
        // playlist so that it won't be copied when executing the filtered
        // audio copy operation.
        //
        // Get the ListTile Text widget finder and tap on it to go to audio
        // player view
        final Finder firstDownloadedAudioListTileTextWidgetFinder = find.text(
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        );

        await tester.tap(firstDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on the comment icon button to open the comment add list
        // dialog
        final Finder commentInkWellButtonFinder = find.byKey(
          const Key('commentsInkWellButton'),
        );

        await tester.tap(commentInkWellButtonFinder);
        await tester.pumpAndSettle();

        // Now tap on the delete comment icon button to delete the comment
        await tester.tap(find.byKey(const Key('deleteCommentIconButton')));
        await tester.pumpAndSettle();

        // Confirm the deletion of the comment
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        Finder audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        // Now, copy this audio to the target playlist so that when
        // copying the uncommented and fully listened audio, this audio
        // won't be copied.

        // Now we want to tap the popup menu of the Audio ListTile
        // "3 fois où un économiste m'a ouvert les yeux (Giraud,
        // Lefournier, Porcher)"

        // Then obtain the Audio ListTile widget enclosing the Text widget
        // by finding its ancestor
        Finder sourceAudioListTileWidgetFinder = find.ancestor(
          of: firstDownloadedAudioListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the leading menu icon button of the Audio ListTile
        // and tap on it
        Finder sourceAudioListTileLeadingMenuIconButton = find.descendant(
          of: sourceAudioListTileWidgetFinder,
          matching: find.byIcon(Icons.menu),
        );

        // Tap the leading menu icon button to open the popup menu
        await tester.tap(sourceAudioListTileLeadingMenuIconButton);
        await tester.pumpAndSettle();

        // Now find the copy audio popup menu item and tap on it
        final Finder popupCopyMenuItem =
            find.byKey(const Key("popup_menu_copy_audio_to_playlist"));

        await tester.tap(popupCopyMenuItem);
        await tester.pumpAndSettle();

        // Find the RadioListTile target playlist to which the audio
        // will be copied

        Finder targetPlaylistRadioListTile = find
            .ancestor(
              of: find.text(targetPlaylistTitle),
              matching: find.byType(ListTile),
            )
            .last;

        // Tap the target playlist RadioListTile to select it
        await tester.tap(targetPlaylistRadioListTile);
        await tester.pumpAndSettle();

        // Now find the confirm button and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Now find the ok button of the confirm dialog and tap on it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')));
        await tester.pumpAndSettle();

        // Scrolling up the audios list in order to display the last
        // downloaded audio title

        // Find the audio list widget using its key
        final Finder listFinder = find.byKey(const Key('audio_list'));

        // Perform the scroll action
        await tester.drag(listFinder, const Offset(0, 400));
        await tester.pumpAndSettle();

        // Now, select a fully listened audio downloaded after the
        // audio which will be copied and transform it to partially
        // played audio
        //
        // Get the ListTile Text widget finder and tap on it to go
        // to audio player view
        final Finder lastDownloadedAudioListTileTextWidgetFinder = find.text(
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
        );

        await tester.tap(lastDownloadedAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Tap on back 1 minute button to set it partially played
        await tester
            .tap(find.byKey(const Key('audioPlayerViewRewind1mButton')));
        await tester.pumpAndSettle();

        // Go back to playlist download view
        audioPlayerNavButtonFinder =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(audioPlayerNavButtonFinder);
        await tester.pumpAndSettle();

        String sortFilterParmName = 'listenedNoCom';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'listenedNoCom' sort/filter item
        Finder dropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(dropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'listenedNoCom'
        // sort/filter parms
        List<String> filteredAudioTitleToCopyLst = [
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
        ];

        // Verify the displayed audio list after selecting the 'listenedNoCom'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: filteredAudioTitleToCopyLst,
        );

        // Verify the presence of the audio files which will be later
        // tried to be copied

        List<String> audioFileNameToCopyLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now test copying the filtered audio

        // Open the copy filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: false, // Copy
          movedOrCopiedAudioNumber: 1,
          commentedAudioNumber: 0,
          unmovedOrUncopiedAudioNumber: 1,
        );

        // Verify in source playlist directory that the copied audio file
        // are still present.

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameCopied in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameCopied),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        dropDownTextFinder = find.text('default').last;
        await tester.tap(dropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having copied the filtered audio

        // Setting to this variables the currently selected audio title/
        // subTitle of the 'S8 audio' playlist
        String currentAudioTitle =
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";
        String currentAudioSubTitle =
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the copied audioTitles displayed by applying the
        // 'default' SF parms

        filteredAudioTitleToCopyLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: filteredAudioTitleToCopyLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Copy filtered commented audio from playlist test', () {
      testWidgets('''Select the 'toMoveOrCopy' SF parms and apply it. Then,
           click on the 'copy Filtered Audio' playlist menu and verify the displayed
           warning as well as the copy of all playlist fully listened audio as well
           as their comments and their picture. Verification done on source as well
           as target playlists.''', (WidgetTester tester) async {
        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'delete_filtered_audio_test',
          tapOnPlaylistToggleButton: true,
        );

        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";
        const String sourcePlaylistTitle = 'S8 audio';
        const String targetPlaylistTitle = 'temp';

        List<String> audioTitleBeforeCopyingLst = [
          "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          "La surpopulation mondiale par Jancovici et Barrau",
          "La résilience insulaire par Fiona Roche",
          "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
          "Les besoins artificiels par R.Keucheyan",
          "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
          "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
        ];

        // Verify the displayed audio list before selecting the 'toMoveOrCopy'
        // Sort/Filter parm.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeCopyingLst,
        );

        String sortFilterParmName = 'toMoveOrCopy';

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        Finder dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        Finder dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'toMoveOrCopy' sort/filter item
        Finder titleAscDropDownTextFinder = find.text(sortFilterParmName).last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'toMoveOrCopy'
        // sort/filter parms
        const String audioTitleOne =
            "La surpopulation mondiale par Jancovici et Barrau";
        const String audioTitleTwo =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        const String audioTitleThree =
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)";

        List<String> audioTitleToCopyLst = [
          audioTitleOne,
          audioTitleTwo,
          audioTitleThree,
        ];

        // Verify the displayed audio list after selecting the 'toMoveOrCopy'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        String currentAudioTitle =
            "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik";
        String currentAudioSubTitle =
            "0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verify the presence of the audio files which will be later copied

        List<String> audioFileNameToCopyLst = [
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.mp3",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.mp3",
        ];

        List<String> listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToMove in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToMove),
            true,
          );
        }

        // Verify the presence of the audio comment files which will be later
        // copied or not

        List<String> availableAudioCommentFileNameLst = [
          "231226-094526-Ce qui va vraiment sauver notre espèce par Jancovici et Barrau 23-09-23.json",
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
          "240107-094520-Les besoins artificiels par R.Keucheyan 24-01-05.json",
        ];

        List<String> listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        expect(
          listCommentJsonFileNames,
          availableAudioCommentFileNameLst,
        );

        // Verify the presence of the audio picture files which will be later
        // copied or not
        List<String> availableAudioPictureFileNameLst = [
          "Barrau.jpg",
          "Jancovici.jpg",
          "Prière.jpg",
        ];

        List<String> listPictureJpgFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        expect(
          listPictureJpgFileNames,
          availableAudioPictureFileNameLst,
        );

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify that the applyed Sort/Filter parms name is displayed
        // after the selected playlist title

        Text selectedSortFilterParmsName = tester
            .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

        expect(
          selectedSortFilterParmsName.data,
          sortFilterParmName,
        );

        // Now test copying the filtered audio

        // Open the copy filtered audio dialog by clicking first on
        // the 'Filtered Audio Actions ...' playlist menu item and then
        // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
        await _testMovingOrCopyingFilteredAudio(
          tester: tester,
          sourcePlaylistTitle: sourcePlaylistTitle,
          targetPlaylistTitle: targetPlaylistTitle,
          sortFilterParmName: sortFilterParmName,
          isMove: false, // Copy
          movedOrCopiedAudioNumber: 3,
          commentedAudioNumber: 1,
          unmovedOrUncopiedAudioNumber: 0,
        );

        // Verify in source playlist directory that the copied audio
        // files are still present

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio",
          fileExtension: 'mp3',
        );

        for (String audioFileNameToCopy in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameToCopy),
            true,
          );
        }

        // Verify in source playlist directory that the copied audio
        // comment files are still present

        List<String> audioCommentFileNameToCopyLst = [
          "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameToCopy
            in audioCommentFileNameToCopyLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameToCopy),
            true,
          );
        }

        // Verify in source playlist directory that the copied audio
        // picture files are still present

        List<String> audioPictureFileNameToCopyLst = [
          "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.json",
          "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
        ];

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}S8 audio${path.separator}$kPictureDirName",
          fileExtension: 'json',
        );

        for (String audioPictureFileNameToCopy
            in audioPictureFileNameToCopyLst) {
          expect(
            listCommentJsonFileNames.contains(audioPictureFileNameToCopy),
            true,
          );
        }

        // Verify the source 'S8 audio' playlist json file

        Playlist loadedPlaylist = loadPlaylist(sourcePlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 18);

        List<String> downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleToMove in audioTitleBeforeCopyingLst) {
          expect(
            downloadedAudioLst.contains(audioTitleToMove),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 7);

        List<String> playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleAfterMoving in audioTitleBeforeCopyingLst) {
          expect(
            playableAudioLst.contains(audioTitleAfterMoving),
            true,
          );
        }

        // Verify the target playlist directory in which the audio files
        // were copied

        listMp3FileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle",
          fileExtension: 'mp3',
        );

        for (String audioFileNameCopied in audioFileNameToCopyLst) {
          expect(
            listMp3FileNames.contains(audioFileNameCopied),
            true,
          );
        }

        // Verify the target playlist directory in which the audio comment
        // files were copied

        listCommentJsonFileNames = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kCommentDirName",
          fileExtension: 'json',
        );

        for (String audioCommentFileNameCopied
            in audioCommentFileNameToCopyLst) {
          expect(
            listCommentJsonFileNames.contains(audioCommentFileNameCopied),
            true,
          );
        }

        // Verify the target playlist directory in which the audio picture
        // files were copied

        final String tempPlaylistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$targetPlaylistTitle${path.separator}$kPictureDirName";

        listPictureJpgFileNames = DirUtil.listFileNamesInDir(
          directoryPath: tempPlaylistPictureDir,
          fileExtension: 'json',
        );

        for (String audioPictureFileNameCopied
            in audioPictureFileNameToCopyLst) {
          expect(
            listPictureJpgFileNames.contains(audioPictureFileNameCopied),
            true,
          );
        }

        // Verify the target 'temp' playlist json file

        loadedPlaylist = loadPlaylist(targetPlaylistTitle);

        expect(loadedPlaylist.downloadedAudioLst.length, 4);

        downloadedAudioLst = loadedPlaylist.downloadedAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleCopied in audioTitleToCopyLst) {
          expect(
            downloadedAudioLst.contains(audioTitleCopied),
            true,
          );
        }

        expect(loadedPlaylist.playableAudioLst.length, 4);

        playableAudioLst = loadedPlaylist.playableAudioLst
            .map((Audio audio) => audio.validVideoTitle)
            .toList();

        for (String audioTitleCopied in audioTitleToCopyLst) {
          expect(
            playableAudioLst.contains(audioTitleCopied),
            true,
          );
        }

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the audioTitles content by applying the 'toMoveOrCopy'
        // sort/filter parms. Since they have been copied, the list is
        // not empty.

        // Verify the displayed audio list before selecting the 'default'
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Now tap on the current dropdown button item to open the dropdown
        // button items list

        dropDownButtonFinder =
            find.byKey(const Key('sort_filter_parms_dropdown_button'));

        dropDownButtonTextFinder = find.descendant(
          of: dropDownButtonFinder,
          matching: find.byType(Text),
        );

        await tester.tap(dropDownButtonTextFinder);
        await tester.pumpAndSettle();

        // Find and tap on the 'default' sort/filter item
        titleAscDropDownTextFinder = find.text('default').last;
        await tester.tap(titleAscDropDownTextFinder);
        await tester.pumpAndSettle();

        // Verify the audioTitles selected by applying the 'default'
        // sort/filter parms after having moved the filtered audio

        // Verify the displayed audio list after selecting the 'default'.
        // Sort/Filter parms.
        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleBeforeCopyingLst,
        );

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the 'temp' target playlist

        // Tap the 'Toggle List' button to show the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Select the 'temp' playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: targetPlaylistTitle,
        );

        // Tap the 'Toggle List' button to hide the list of playlist's.
        await tester.tap(find.byKey(const Key('playlist_toggle_button')));
        await tester.pumpAndSettle();

        // Verify the copied audioTitles displayed by applying the
        // 'default' SF parms

        audioTitleToCopyLst.insert(0, "morning _ cinematic video");

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: audioTitleToCopyLst,
        );

        // Setting to this variables the currently selected audio title/subTitle
        // of the 'S8 audio' playlist
        currentAudioTitle = "morning _ cinematic video";
        currentAudioSubTitle =
            "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

        // Verify that the current audio is displayed with the correct
        // title and subtitle color
        await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
          tester: tester,
          currentAudioTitle: currentAudioTitle,
          currentAudioSubTitle: currentAudioSubTitle,
        );

        // Verifying the copied audio's to which a picture is associated

        const String pictureFileNameOne =
            "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json";
        const String pictureFileNameTwo =
            "240107-094528-Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik 23-09-10.json";

        final String pictureFilePathNameOne =
            "$tempPlaylistPictureDir${path.separator}$pictureFileNameOne";
        final String pictureFilePathNameTwo =
            "$tempPlaylistPictureDir${path.separator}$pictureFileNameTwo";
        const String audioTitleOneDurationStr = '7:38';
        const String audioTitleTwoDurationStr = '13:39';

        List<String> copiedAudioPictureFileNameLst = [
          pictureFileNameTwo,
          pictureFileNameOne,
        ];

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: tempPlaylistPictureDir,
          pictureFileNameOne: pictureFilePathNameOne,
          audioForPictureTitle: audioTitleOne, // La surpopulation mondiale ...
          audioForPictureTitleDurationStr: audioTitleOneDurationStr,
          playlistAudioPictureJsonFileNameLst: copiedAudioPictureFileNameLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Now, go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: tempPlaylistPictureDir,
          pictureFileNameOne: pictureFilePathNameTwo,
          audioForPictureTitle:
              audioTitleTwo, // Le Secret de la RÉSILIENCE  ...
          audioForPictureTitleDurationStr: audioTitleTwoDurationStr,
          playlistAudioPictureJsonFileNameLst: copiedAudioPictureFileNameLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      group('''Copy 'default' filtered commented audio from playlist test''',
          () {
        testWidgets(
            '''SF parms 'default'. Copy Youtube->local. Then, click on the 'Copy Filtered
           Audio' playlist menu and verify the displayed warning indicating
           that the copy operation can not be done when 'default' is applyed.''',
            (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'S8 audio';
          const String targetPlaylistTitle = 'temp';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test copying the filtered audio

          // Open the copy filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_copy_filtered_audio',
          );

          // Select the target 'temp' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be copied

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be copied from Youtube playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'temp' target playlist

          // Select the 'temp' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no movcopieded audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: ["morning _ cinematic video"],
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'S8 audio' playlist
          String currentAudioTitle = "morning _ cinematic video";
          String currentAudioSubTitle =
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''SF parms 'default'. Copy Youtube->Youtube. Then, click on the 'Copy Filtered
           Audio' playlist menu and verify the displayed warning indicating
           that the copy operation can not be done when 'default' is applyed.''',
            (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'S8 audio';
          const String targetPlaylistTitle = 'Maria Valtorta';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test copying the filtered audio

          // Open the copy filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_copy_filtered_audio',
          );

          // Select the target 'Maria Valtorta' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be copied

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be copied from Youtube playlist "$sourcePlaylistTitle" to Youtube playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'Maria Valtorta' target playlist

          // Select the 'Maria Valtorta' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no movcopieded audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: [
              "What place Maria Valtorta takes in your spiritual journey"
            ],
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'Maria Valtorta' playlist
          String currentAudioTitle =
              "What place Maria Valtorta takes in your spiritual journey";
          String currentAudioSubTitle =
              "0:06:01.3 2.20 MB at 595 KB/sec on 03/06/2025 at 16:48";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''SF parms 'default'. Copy local->Youtube. Then, click on the 'Copy Filtered
           Audio' playlist menu and verify the displayed warning indicating
           that the copy operation can not be done when 'default' is applyed.''',
            (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'temp';
          const String targetPlaylistTitle = 'S8 audio';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test copying the filtered audio

          // Open the copy filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_copy_filtered_audio',
          );

          // Select the target 'Youtube' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be copied

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be copied from local playlist "$sourcePlaylistTitle" to Youtube playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'S8 audio' target playlist

          // Select the 'S8 audio' playlist

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no movcopieded audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: [
              "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
            ],
            firstAudioListTileIndex: 3,
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'S8 audio' playlist
          String currentAudioTitle =
              'Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik';
          String currentAudioSubTitle =
              '0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16';

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''SF parms 'default'. Copy local->local. Then, click on the 'Copy Filtered
           Audio' playlist menu and verify the displayed warning indicating
           that the copy operation can not be done when 'default' is applyed.''',
            (WidgetTester tester) async {
          await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
            tester: tester,
            savedTestDataDirName: 'delete_filtered_audio_test',
            tapOnPlaylistToggleButton: false,
          );

          const String sourcePlaylistTitle = 'temp';
          const String targetPlaylistTitle = 'local';

          // Verify that the applyed Sort/Filter parms name is displayed
          // after the selected playlist title

          Text selectedSortFilterParmsName = tester
              .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

          expect(
            selectedSortFilterParmsName.data,
            'default',
          );

          // Now test copying the filtered audio

          // Open the copy filtered audio dialog by clicking first on
          // the 'Filtered Audio Actions ...' playlist menu item and then
          // on the 'Copy Filtered Audio to Playlist ...' sub-menu item
          await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
            tester: tester,
            playlistTitle: sourcePlaylistTitle,
            playlistSubMenuKeyStr: 'popup_menu_copy_filtered_audio',
          );

          // Select the target 'local' playlist

          // Check the value of the select one playlist AlertDialog
          // dialog title
          Text alertDialogTitle = tester.widget(
              find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
          expect(alertDialogTitle.data, 'Select a Playlist');

          // Find the RadioListTile target playlist to which the audio
          // will be copied

          Finder radioListTile = find
              .ancestor(
                of: find.text(targetPlaylistTitle),
                matching: find.byType(ListTile),
              )
              .last;

          // Tap the target playlist RadioListTile to select it
          await tester.tap(radioListTile);
          await tester.pumpAndSettle();

          // Now find the confirm button and tap on it
          await tester.tap(find.byKey(const Key('confirmButton')));
          await tester.pumpAndSettle();

          // Now verifying the warning dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Since "default" Sort/Filter parms is selected, no audio can be copied from local playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle". SOLUTION: define a Sort/Filter parms and apply it before executing this operation ...',
            isWarningConfirming: false,
          );

          // Verifying the 'local' target playlist

          // Select the 'local' playlist

          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: targetPlaylistTitle,
          );

          // Tap the 'Toggle List' button to hide the list of playlist's.
          await tester.tap(find.byKey(const Key('playlist_toggle_button')));
          await tester.pumpAndSettle();

          // Verify the audioTitles with no movcopieded audio displayed by applying
          // the 'default' SF parms

          IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
            tester: tester,
            audioOrPlaylistTitlesOrderedLst: ["morning _ cinematic video"],
          );

          // Setting to this variables the currently selected audio title/subTitle
          // of the 'local' playlist
          String currentAudioTitle =
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";
          String currentAudioSubTitle =
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35";

          // Verify that the current audio is displayed with the correct
          // title and subtitle color
          await IntegrationTestUtil.verifyCurrentAudioTitleAndSubTitleColor(
            tester: tester,
            currentAudioTitle: currentAudioTitle,
            currentAudioSubTitle: currentAudioSubTitle,
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
      });
    });
  });
  group('Change application language', () {
    testWidgets(
        '''In playlist download view, change to french and verify translated texts,
        in DatePicker dialog used in audio sort filter dialog as well. Then, switch
        to audio player view verify translated texts. Then, change to english, verify
        translation and go back to playlist download view and verify translation.''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      // First, set the application language to french
      await IntegrationTestUtil.setApplicationLanguage(
        tester: tester,
        language: Language.french,
      );

      // Verify the translated texts in the application

      _verifyFrenchInPlaylistDownloadView();

      // Verifying translated texts in DatePicker dialog
      await _verifyDatePickerTitleTranslation(
        tester: tester,
        datePickerTranslatedTitleStr: 'Sélectionner une date',
        datePickerCancelButtonTranslatedStr: 'Annuler',
      );

      // Click on playlist toggle button to display the playlist list
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Verify the default Sort/Filter parms name value after the
      // selected playlist title

      Text selectedSortFilterParmsName = tester
          .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

      expect(
        selectedSortFilterParmsName.data,
        'défaut',
      );

      // Go to audio player view

      Finder appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      expect(find.text('Lire Audio'), findsOneWidget);

      // Now, set the application language to english
      await IntegrationTestUtil.setApplicationLanguage(
        tester: tester,
        language: Language.english,
      );

      expect(find.text('Play Audio'), findsOneWidget);

      // Return to playlist download view
      appScreenNavigationButton =
          find.byKey(const ValueKey('playlistDownloadViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Verify the translated texts in the application

      _verifyEnglishInPlaylistDownloadView();

      // Verify the translated texts in the DatePicker dialog
      await _verifyDatePickerTitleTranslation(
        tester: tester,
        datePickerTranslatedTitleStr: 'Select date',
        datePickerCancelButtonTranslatedStr: 'Cancel',
      );

      // Verify the default Sort/Filter parms name value after the
      // selected playlist title

      selectedSortFilterParmsName = tester
          .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

      expect(
        selectedSortFilterParmsName.data,
        'default',
      );

      // Click on playlist toggle button to hide the playlist list
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      expect(find.text('default'), findsOneWidget);

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Go to audio player view, change to french and verify translated
        texts. Then, switch to playlist download view and verify translated texts.
        Then, change to english, verify translation and go back to audio player view
        and verify translation.''', (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'sort_and_filter_audio_dialog_widget_test',
        tapOnPlaylistToggleButton: false,
      );

      // First, go to audio player view

      Finder appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Set the application language to french
      await IntegrationTestUtil.setApplicationLanguage(
        tester: tester,
        language: Language.french,
      );

      expect(find.text('Lire Audio'), findsOneWidget);

      // Return to playlist download view
      appScreenNavigationButton =
          find.byKey(const ValueKey('playlistDownloadViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      // Verify the translated texts in the application

      _verifyFrenchInPlaylistDownloadView();

      // Verify the translated texts in the DatePicker dialog
      await _verifyDatePickerTitleTranslation(
        tester: tester,
        datePickerTranslatedTitleStr: 'Sélectionner une date',
        datePickerCancelButtonTranslatedStr: 'Annuler',
      );

      // Click on playlist toggle button to display the playlist list
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Verify the default Sort/Filter parms name value after the
      // selected playlist title

      Text selectedSortFilterParmsName = tester
          .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

      expect(
        selectedSortFilterParmsName.data,
        'défaut',
      );

      // Now, set the application language to english
      await IntegrationTestUtil.setApplicationLanguage(
        tester: tester,
        language: Language.english,
      );

      // Verify the default Sort/Filter parms name value after the
      // selected playlist title

      selectedSortFilterParmsName = tester
          .widget(find.byKey(const Key('selectedPlaylistSFparmNameText')));

      expect(
        selectedSortFilterParmsName.data,
        'default',
      );

      // Click on playlist toggle button to hide the playlist list
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      // Verify the translated texts in the application

      _verifyEnglishInPlaylistDownloadView();

      // Verify the translated texts in the DatePicker dialog
      await _verifyDatePickerTitleTranslation(
        tester: tester,
        datePickerTranslatedTitleStr: 'Select date',
        datePickerCancelButtonTranslatedStr: 'Cancel',
      );

      // Click on playlist toggle button to display the playlist list
      await tester.tap(find.byKey(const Key('playlist_toggle_button')));
      await tester.pumpAndSettle();

      expect(find.text('default'), findsOneWidget);

      // Finally, return to audio player view

      appScreenNavigationButton =
          find.byKey(const ValueKey('audioPlayerViewIconButton'));
      await tester.tap(appScreenNavigationButton);
      await tester.pumpAndSettle();

      expect(find.text('Play Audio'), findsOneWidget);

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('App settings dialog test', () {
    testWidgets(
        'Bug fix: open app settings dialog and save it without modification.',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final Map initialSettingsMap = _loadSettingsMap();

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      await app.main();
      await tester.pumpAndSettle();

      // Now tap the appbar leading popup menu button Then, the app settings
      // dialog is opened.
      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
      );

      // And tap on save button
      await tester.tap(find.byKey(const Key('saveButton')));
      await tester.pumpAndSettle();

      // Ensure settings json file has not been modified
      expect(
        initialSettingsMap,
        _loadSettingsMap(),
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    group('App playlist root path test', () {
      testWidgets(
          '''Modify playlist root path and then reset it to the initial value. Verify
           that the playlist sort order was reset to the initial sort order since the
           user accepted the previously saved sort order. Then, remodify the path to the
           previously modified value and verify that the playlist sort order was reset
           to the new order since the user accepted the previously saved sort order.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}modify_playlist_root_path",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Verify the initial playlist titles order

        List<String> initialPlaylistTitlesOrder = [
          "local_empty_download_single_video",
          "local_not_empty_download_single_video",
          "audio_learn_test_download_2_small_videos",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: initialPlaylistTitlesOrder,
        );

        // Verify playlist selection
        const String initialSelectedPlaylistTitle =
            'local_not_empty_download_single_video';
        expect(
          await IntegrationTestUtil.isPlaylistSelected(
            tester: tester,
            playlistToCheckTitle: initialSelectedPlaylistTitle,
          ),
          true,
        );

        // Now, set the playlist root path to the modified value

        List<String> modifiedDirPlaylistTitlesOrder = [
          "audio_learn_test_download_2_small_videos",
          "local_empty_download_single_video",
          "local_not_empty_download_single_video",
        ];
        final String modifiedPlaylistRootPath =
            '$kApplicationPathWindowsTest${path.separator}newDirectory${path.separator}playlists';
        String newDirectoryPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[audio_learn_test_download_2_small_videos, local_empty_download_single_video, local_not_empty_download_single_video]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\newDirectory\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";
        const String modifiedDirSelectedPlaylistTitle =
            "audio_learn_test_download_2_small_videos";

        // With clicking on 'Confirm' button to accept restoring
        // the previous playlist titles order
        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: modifiedPlaylistRootPath,
          playlistTitlesOrderInModifiedDir: modifiedDirPlaylistTitlesOrder,
          expectedSettingsContent: newDirectoryPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: modifiedDirSelectedPlaylistTitle,
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // Now, reset the playlist root path to the initial value

        String audioPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[local_empty_download_single_video, local_not_empty_download_single_video, audio_learn_test_download_2_small_videos]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        // With clicking on 'Confirm' button to accept restoring
        // the previous playlist titles order
        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: kPlaylistDownloadRootPathWindowsTest,
          playlistTitlesOrderInModifiedDir: initialPlaylistTitlesOrder,
          expectedSettingsContent: audioPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: initialSelectedPlaylistTitle,
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: true, // Confirm button is tapped
        );

        // The playlist titles order is the initial one since 'Cancel'
        // will be clicked
        newDirectoryPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[local_empty_download_single_video, local_not_empty_download_single_video, audio_learn_test_download_2_small_videos]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\newDirectory\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        // With clicking on 'Cancel' button to refuse restoring
        // the previous playlist titles order
        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: modifiedPlaylistRootPath,
          playlistTitlesOrderInModifiedDir: initialPlaylistTitlesOrder,
          expectedSettingsContent: newDirectoryPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: modifiedDirSelectedPlaylistTitle,
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: false, // Confirm button is tapped
        );

        // Move up twice the selected "audio_learn_test_download_2_small_videos"
        // playlist to position it at top of playlists list

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        // Select and move up once the 'local_not_empty_download_single_video'
        // playlist

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: 'local_not_empty_download_single_video',
        );

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        // Re-select the 'audio_learn_test_download_2_small_videos'
        // playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: modifiedDirSelectedPlaylistTitle,
        );

        initialPlaylistTitlesOrder = [
          'audio_learn_test_download_2_small_videos',
          'local_not_empty_download_single_video',
          'local_empty_download_single_video',
        ];

        audioPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[audio_learn_test_download_2_small_videos, local_not_empty_download_single_video, local_empty_download_single_video]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        // Now reset the playlist root path to the initial value
        // with clicking on 'Cancel' button to refuse restoring
        // the previous playlist titles order
        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: kPlaylistDownloadRootPathWindowsTest,
          playlistTitlesOrderInModifiedDir: initialPlaylistTitlesOrder,
          expectedSettingsContent: audioPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: initialSelectedPlaylistTitle,
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: false, // Cancel button is tapped
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Modify playlist root path and then reset it to the initial value. Verify
           that the playlist sort order was not reset to the initial sort order since the
           user rejected the previously saved sort order. Then, remodify the path to the
           previously modified value and verify that the playlist sort order was not reset
           to the new order since the user rejected the previously saved sort order.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}audio_learn_download_test",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Create a new directory containing playlists to which the playlist
        // root path will be modified

        String newDirectoryPlaylistRootPath =
            '$kApplicationPathWindowsTest${path.separator}newDirectory${path.separator}playlists';

        DirUtil.createDirIfNotExistSync(
          pathStr: newDirectoryPlaylistRootPath,
        );

        // Fill the new directory with playlists
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_delete_integr_test_data",
          destinationRootPath: newDirectoryPlaylistRootPath,
        );

        // Delete the settings.json file from the copied data
        DirUtil.deleteFileIfExist(
          pathFileName:
              "$newDirectoryPlaylistRootPath${path.separator}$kSettingsFileName",
        );

        // Verify the initial playlist titles

        List<String> initialPlaylistTitles = [
          "local_empty_download_single_video",
          "local_not_empty_download_single_video",
          "audio_learn_test_download_2_small_videos",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: initialPlaylistTitles,
        );

        // Verify playlist selection
        const String initialSelectedPlaylistTitle =
            'local_not_empty_download_single_video';
        expect(
          await IntegrationTestUtil.isPlaylistSelected(
            tester: tester,
            playlistToCheckTitle: initialSelectedPlaylistTitle,
          ),
          true,
        );

        // Now, set the playlist root path to the modified value

        List<String> newDirectoryPlaylistTitles = [
          "audio_learn_test_download_2_small_videos",
          "audio_player_view_2_shorts_test",
          "local_3",
          "local_audio_playlist_2",
        ];

        String newDirectoryPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[audio_learn_test_download_2_small_videos, audio_player_view_2_shorts_test, local_3, local_audio_playlist_2]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\newDirectory\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: newDirectoryPlaylistRootPath,
          playlistTitlesOrderInModifiedDir: newDirectoryPlaylistTitles,
          expectedSettingsContent: newDirectoryPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: 'local_3',
        );

        // Move up twice the selected "local_3" playlist to position
        // it at top of playlists list

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        await tester.tap(find.byKey(const Key('move_up_playlist_button')));
        await tester.pumpAndSettle();

        newDirectoryPlaylistTitles = [
          'audio_learn_test_download_2_small_videos',
          'local_empty_download_single_video',
          'local_not_empty_download_single_video',
        ];

        // Select another playlist
        String newDirectoryPlaylistSelectedTitle =
            "audio_learn_test_download_2_small_videos";

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: newDirectoryPlaylistSelectedTitle,
        );

        // Now reset the playlist root path to the initial value
        // with clicking on 'Cancel' button to refuse restoring
        // the previous playlist titles order

        String audioPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[audio_learn_test_download_2_small_videos, local_empty_download_single_video, local_not_empty_download_single_video]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: kPlaylistDownloadRootPathWindowsTest,
          playlistTitlesOrderInModifiedDir: newDirectoryPlaylistTitles,
          expectedSettingsContent: audioPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: 'local_not_empty_download_single_video',
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: false, // Cancel button is tapped
        );

        // And finally, set again the playlist root path to the modified
        // value with clicking on 'Cancel' button to refuse restoring
        // the previous playlist titles order

        newDirectoryPlaylistTitles = [
          "audio_learn_test_download_2_small_videos",
          "audio_player_view_2_shorts_test",
          "local_3",
          "local_audio_playlist_2",
        ];

        newDirectoryPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[audio_learn_test_download_2_small_videos, audio_player_view_2_shorts_test, local_3, local_audio_playlist_2]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\newDirectory\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: newDirectoryPlaylistRootPath,
          playlistTitlesOrderInModifiedDir: newDirectoryPlaylistTitles,
          expectedSettingsContent: newDirectoryPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: newDirectoryPlaylistSelectedTitle,
          confirmDialogTitleOne: "Playlist Titles Order Restoration",
          confirmDialogMessage:
              "A previous playlist titles order file is available in the selected playlist root path. Do you want to restore this saved order or keep the current playlist titles order? Click on \"Confirm\" to restore the saved order or on \"Cancel\" to keep the current order.",
          confirmOrCancelAction: false, // Confirm button is tapped
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Modify playlist root path to an invalid root path not ending by 'playlists'.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}audio_learn_download_test",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Create a playlist root invalid directory not containing playlists
        // to which the playlist root path will be modified

        String modifiedInvalidPlaylistRootPath =
            '$kApplicationPathWindowsTest${path.separator}newDirectory';

        DirUtil.createDirIfNotExistSync(
          pathStr: modifiedInvalidPlaylistRootPath,
        );

        // Fill the new directory with playlists
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_delete_integr_test_data",
          destinationRootPath: modifiedInvalidPlaylistRootPath,
        );

        // Delete the settings.json file from the copied data
        DirUtil.deleteFileIfExist(
          pathFileName:
              "$modifiedInvalidPlaylistRootPath${path.separator}$kSettingsFileName",
        );

        // Set the playlist root path to the modified value

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Select the modified dir path. Tapping on the select directory
        // icon button does not open the directory picker dialog. Instead,
        // the FilePicker mock is used to simulate the selection of the
        // directory.

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: modifiedInvalidPlaylistRootPath,
        );

        await tester.tap(find.byKey(const Key('openDirectoryIconButton')));
        await tester.pumpAndSettle();

        // Find the Text using the Key
        final Finder textFinder =
            find.byKey(const Key('playlistsRootPathText'));

        // Retrieve the Text widget
        String text = tester.widget<Text>(textFinder).data ?? '';

        // Verify the selected directory path
        expect(
          text,
          modifiedInvalidPlaylistRootPath,
        );

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now verifying the warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              'The defined path "$modifiedInvalidPlaylistRootPath" is invalid since the playlists final dir name \'newDirectory\' is not equal to \'playlists\'. Please define a valid playlist directory and retry changing the playlists root path.',
          isWarningConfirming: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Select current playlist root path. This does not change anything since
                     the selected path is the current one.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}modify_playlist_root_path",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Verify the initial playlist titles order

        List<String> initialPlaylistTitlesOrder = [
          "local_empty_download_single_video",
          "local_not_empty_download_single_video",
          "audio_learn_test_download_2_small_videos",
        ];

        IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
          tester: tester,
          audioOrPlaylistTitlesOrderedLst: initialPlaylistTitlesOrder,
        );

        // Verify playlist selection
        const String initialSelectedPlaylistTitle =
            'local_not_empty_download_single_video';
        expect(
          await IntegrationTestUtil.isPlaylistSelected(
            tester: tester,
            playlistToCheckTitle: initialSelectedPlaylistTitle,
          ),
          true,
        );

        // Now, set the playlist root path to the initial value.
        // Nothing should change.

        String audioPlaylistsExpectedSettingsContent =
            "{\"SettingType.appTheme\":{\"SettingType.appTheme\":\"AppTheme.dark\"},\"SettingType.language\":{\"SettingType.language\":\"Language.english\"},\"SettingType.playlists\":{\"Playlists.orderedTitleLst\":\"[local_empty_download_single_video, local_not_empty_download_single_video, audio_learn_test_download_2_small_videos]\",\"Playlists.isMusicQualityByDefault\":\"false\",\"Playlists.playSpeed\":\"1.0\",\"Playlists.arePlaylistsDisplayedInPlaylistDownloadView\":\"true\",\"Playlists.maxSavableAudioMp3FileSizeInMb\":\"525.0\"},\"SettingType.dataLocation\":{\"DataLocation.appSettingsPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\",\"DataLocation.playlistRootPath\":\"C:\\\\development\\\\flutter\\\\audiolearn\\\\test\\\\data\\\\audio\\\\playlists\"},\"SettingType.formatOfDate\":{\"FormatOfDate.formatOfDate\":\"dd/MM/yyyy\"},\"namedAudioSortFilterSettings\":{\"default\":{\"selectedSortItemLst\":[{\"sortingOption\":\"audioDownloadDate\",\"isAscending\":false}],\"filterSentenceLst\":[],\"sentencesCombination\":0,\"ignoreCase\":true,\"searchAsWellInYoutubeChannelName\":true,\"searchAsWellInVideoCompactDescription\":true,\"filterMusicQuality\":true,\"filterSpokenQuality\":true,\"filterFullyListened\":true,\"filterPartiallyListened\":true,\"filterNotListened\":true,\"filterCommented\":true,\"filterNotCommented\":true,\"filterPictured\":true,\"filterNotPictured\":true,\"filterPlayable\":true,\"filterNotPlayable\":true,\"filterDownloaded\":true,\"filterImported\":true,\"filterConverted\":true,\"downloadDateStartRange\":null,\"downloadDateEndRange\":null,\"uploadDateStartRange\":null,\"uploadDateEndRange\":null,\"fileSizeStartRangeMB\":0.0,\"fileSizeEndRangeMB\":0.0,\"durationStartRangeSec\":0,\"durationEndRangeSec\":0}},\"searchHistoryOfAudioSortFilterSettings\":\"[]\"}";

        await _changePlaylistRootPathAndSaveAppSettings(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pathToSelectStr: kPlaylistDownloadRootPathWindowsTest,
          playlistTitlesOrderInModifiedDir: initialPlaylistTitlesOrder,
          expectedSettingsContent: audioPlaylistsExpectedSettingsContent,
          selectedPlaylistTitle: initialSelectedPlaylistTitle,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });

    group('App settings set speed test', () {
      testWidgets(
          '''Modify playback speed without selecting existing playlists or already downloaded or imported
            audio's. Finally, create a new playlist and verify that its audio play speed is equal to the
            modified playback speed.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        await app.main();
        await tester.pumpAndSettle();

        // Set the app settings playlist audio play speed to 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Tap on the playback speed text button

        await tester.tap(find.byKey(const Key('setAudioSpeedTextButton')));
        await tester.pumpAndSettle();

        // Now select the 0.7x play speed
        await tester.tap(find.text('0.7x'));
        await tester.pumpAndSettle();

        // And click on the Ok button
        await tester.tap(find.text('Ok'));
        await tester.pumpAndSettle();

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Verify that the app settings playlist audio play speed is now 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is re-opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButton')));
        await tester.pumpAndSettle();

        // Now create a new local playlist
        const String newLocalPlaylistTitle = 'new_local';

        await _createNewLocalPlaylist(
          tester: tester,
          newPlaylistTitle: newLocalPlaylistTitle,
        );

        List<String> oldPlaylistTitles = [
          "local",
          "S8 audio",
        ];

        // Verify that the play speed was not applied to the existing playlists

        for (String playlistTitle in oldPlaylistTitles) {
          await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: playlistTitle,
            playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
          );

          // Verify if the play speed is 1.0x
          expect(find.text('1.0x'), findsOneWidget);

          // Tap on cancel button
          await tester.tap(find.byKey(const Key('cancelButtonKey')));
          await tester.pumpAndSettle();
        }

        // Verify that the play speed was applied to the new created
        // playlist

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: newLocalPlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.7x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButtonKey')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Modify playback speed with selecting existing playlists and without selecting already
            downloaded or imported audio's. Finally, create a new playlist and verify that its audio
            play speed is equal to the modified playback speed.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        await app.main();
        await tester.pumpAndSettle();

        // Set the app settings playlist audio play speed to 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Tap on the playback speed text button

        await tester.tap(find.byKey(const Key('setAudioSpeedTextButton')));
        await tester.pumpAndSettle();

        // Now select the 0.7x play speed
        await tester.tap(find.text('0.7x'));
        await tester.pumpAndSettle();

        // Select the 'Apply to existing playlists' checkbox
        await tester.tap(find.byKey(const Key('applyToExistingPlaylistsKey')));
        await tester.pumpAndSettle();

        // And click on the Ok button
        await tester.tap(find.text('Ok'));
        await tester.pumpAndSettle();

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Verify that the app settings playlist audio play speed is now 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is re-opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButton')));
        await tester.pumpAndSettle();

        // Now create a new local playlist
        const String newLocalPlaylistTitle = 'new_local';

        await _createNewLocalPlaylist(
          tester: tester,
          newPlaylistTitle: newLocalPlaylistTitle,
        );

        List<String> playlistTitles = [
          "local",
          "S8 audio",
        ];

        // Verify that the play speed was applied to the existing playlists

        for (String playlistTitle in playlistTitles) {
          await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: playlistTitle,
            playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
          );

          // Verify if the play speed is 0.70x
          expect(find.text('0.70x'), findsOneWidget);

          // Tap on cancel button
          await tester.tap(find.byKey(const Key('cancelButtonKey')));
          await tester.pumpAndSettle();
        }

        // Verify that the play speed was applied to the new created
        // playlist

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: newLocalPlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.7x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButtonKey')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Modify playback speed without selecting existing playlists and with selecting already
            downloaded or imported audio's. Finally, create a new playlist and verify that its audio
            play speed is equal to the modified playback speed.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        await app.main();
        await tester.pumpAndSettle();

        // Set the app settings playlist audio play speed to 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Tap on the playback speed text button

        await tester.tap(find.byKey(const Key('setAudioSpeedTextButton')));
        await tester.pumpAndSettle();

        // Now select the 0.7x play speed
        await tester.tap(find.text('0.7x'));
        await tester.pumpAndSettle();

        // Select the 'Apply to already downloaded or imported audio' checkbox
        await tester
            .tap(find.byKey(const Key('applyToAlreadyDownloadedAudioKey')));
        await tester.pumpAndSettle();

        // And click on the Ok button
        await tester.tap(find.text('Ok'));
        await tester.pumpAndSettle();

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Verify that the app settings playlist audio play speed is now 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButton')));
        await tester.pumpAndSettle();

        // Now create a new local playlist
        const String newLocalPlaylistTitle = 'new_local';

        await _createNewLocalPlaylist(
          tester: tester,
          newPlaylistTitle: newLocalPlaylistTitle,
        );

        List<String> playlistTitles = [
          "local",
          "S8 audio",
        ];

        // Verify that the play speed was not applied to the existing playlists

        for (String playlistTitle in playlistTitles) {
          await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: playlistTitle,
            playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
          );

          // Verify if the play speed is 1.0x
          expect(find.text('1.0x'), findsOneWidget);

          // Tap on cancel button
          await tester.tap(find.byKey(const Key('cancelButtonKey')));
          await tester.pumpAndSettle();
        }

        // Verify that the play speed was applied to the new created
        // playlist

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: newLocalPlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.7x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButtonKey')));
        await tester.pumpAndSettle();

        // Verify that the play speed was applied to the already downloaded
        // audio of the 'local' playlist which is selected

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedFromPlaylistTitle: "S8 audio",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "Really short video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'audio_player_view_2_shorts_test',
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "morning _ cinematic video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'audio_player_view_2_shorts_test',
            copiedToPlaylistTitle: 'S8 audio',
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedFromPlaylistTitle: "S8 audio",
            audioPlaySpeed: "0.7");

        // Verify that the play speed was applied to the already downloaded
        // audio of the 'S8 audio' playlist which must be selected

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: "S8 audio",
        );

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "La surpopulation mondiale par Jancovici et Barrau",
            youtubeChannel: "",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedToPlaylistTitle: "local",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "morning _ cinematic video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'local',
            audioPlaySpeed: "0.7");

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Modify playback speed with selecting existing playlists and with selecting already
            downloaded or imported audio's. Finally, create a new playlist and verify that its audio
            play speed is equal to the modified playback speed.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        await app.main();
        await tester.pumpAndSettle();

        // Set the app settings playlist audio play speed to 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Tap on the playback speed text button

        await tester.tap(find.byKey(const Key('setAudioSpeedTextButton')));
        await tester.pumpAndSettle();

        // Now select the 0.7x play speed
        await tester.tap(find.text('0.7x'));
        await tester.pumpAndSettle();

        // Select the 'Apply to existing playlists' checkbox
        await tester.tap(find.byKey(const Key('applyToExistingPlaylistsKey')));
        await tester.pumpAndSettle();

        // Select the 'Apply to already downloaded or imported audio' checkbox
        await tester
            .tap(find.byKey(const Key('applyToAlreadyDownloadedAudioKey')));
        await tester.pumpAndSettle();

        // And click on the Ok button
        await tester.tap(find.text('Ok'));
        await tester.pumpAndSettle();

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Verify that the app settings playlist audio play speed is now 0.7

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.70x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButton')));
        await tester.pumpAndSettle();

        // Now create a new local playlist
        const String newLocalPlaylistTitle = 'new_local';

        await _createNewLocalPlaylist(
          tester: tester,
          newPlaylistTitle: newLocalPlaylistTitle,
        );

        List<String> playlistTitles = [
          "local",
          "S8 audio",
        ];

        // Verify that the play speed was applied to the existing playlists

        for (String playlistTitle in playlistTitles) {
          await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: playlistTitle,
            playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
          );

          // Verify if the play speed is 0.70x
          expect(find.text('0.70x'), findsOneWidget);

          // Tap on cancel button
          await tester.tap(find.byKey(const Key('cancelButtonKey')));
          await tester.pumpAndSettle();
        }

        // Verify that the play speed was applied to the new created
        // playlist

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: newLocalPlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_set_audio_play_speed',
        );

        // Verify if the play speed is 0.70x
        expect(find.text('0.7x'), findsOneWidget);

        // Tap on cancel button
        await tester.tap(find.byKey(const Key('cancelButtonKey')));
        await tester.pumpAndSettle();

        // Verify that the play speed was applied to the already downloaded
        // audio of the 'local' playlist which is selected

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedFromPlaylistTitle: "S8 audio",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "Really short video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'audio_player_view_2_shorts_test',
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "morning _ cinematic video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'audio_player_view_2_shorts_test',
            copiedToPlaylistTitle: 'S8 audio',
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedFromPlaylistTitle: "S8 audio",
            audioPlaySpeed: "0.7");

        // Verify that the play speed was applied to the already downloaded
        // audio of the 'S8 audio' playlist which must be selected

        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: "S8 audio",
        );

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "La surpopulation mondiale par Jancovici et Barrau",
            youtubeChannel: "",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle:
                "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            youtubeChannel: "",
            copiedToPlaylistTitle: "local",
            audioPlaySpeed: "0.7");

        await IntegrationTestUtil.verifyAudioInfoDialog(
            tester: tester,
            validVideoTitleOrAudioTitle: "morning _ cinematic video",
            youtubeChannel: "",
            copiedFromPlaylistTitle: 'local',
            audioPlaySpeed: "0.7");

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('App playlist ZIP file size limit test', () {
      testWidgets(
          '''Reduce ZIP file size limit to 1 MB and then execute the appBar menu 'Save Playlists
            Audio's MP3 to ZIP file(s). Then, verify the confirmation dialog data which displays
            a small number of saved ZIP files since the majority of audio files were not added
            to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the app settings
        // dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 1 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '1',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the appBar menu 'Save Playlists Audio's MP3 to
        // ZIP file(s)

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 3, total size: 783 KB and total duration: 0:02:08.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "Those files are too large to be included in the MP3 saved ZIP file and so were not saved:\nlocal\\240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3, 2.37 MB;\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB;\nS8 audio\\240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3, 2.37 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          'playlists\\local\\240110-181805-Really short video 23-07-01.mp3',
          'playlists\\local\\240110-181810-morning _ cinematic video 23-07-01.mp3',
          'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3'
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Reduce ZIP file size limit to 1 MB and delete '240701-163521-Jancovici m'explique
            l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3' from
            the 'local' and the 'S8 audio' playlists. Then execute the appBar menu 'Save Playlists
            Audio's MP3 to ZIP file(s) and verify the confirmation dialog data which displays
            a greater number of saved ZIP files since only one audio file was not added
            to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        DirUtil.deleteFileIfExist(
          pathFileName:
              "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}local${path.separator}240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
        );

        DirUtil.deleteFileIfExist(
          pathFileName:
              "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}S8 audio${path.separator}240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the
        // app settings dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 2.6 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '1',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the appBar menu 'Save Playlists Audio's MP3 to
        // ZIP file(s)

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 3, total size: 783 KB and total duration: 0:02:08.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "This file is too large to be included in the MP3 saved ZIP file and so was not saved:\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          'playlists\\local\\240110-181805-Really short video 23-07-01.mp3',
          'playlists\\local\\240110-181810-morning _ cinematic video 23-07-01.mp3',
          'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3'
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Reduce ZIP file size limit to 2.6 MB. Then execute the appBar menu 'Save Playlists
            Audio's MP3 to ZIP file(s) and verify the confirmation dialog data which displays
            a greater number of saved ZIP files since only one audio file was not added
            to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the
        // app settings dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 2.6 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '2.6',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the appBar menu 'Save Playlists Audio's MP3 to
        // ZIP file(s)

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 5, total size: 5.53 MB and total duration: 0:15:06.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 3."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "This file is too large to be included in the MP3 saved ZIP file and so was not saved:\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<List<String>> expectedZipContentLst = [
          [
            'playlists\\local\\240701-163521-Jancovici m\'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3',
            'playlists\\local\\240110-181805-Really short video 23-07-01.mp3',
          ],
          [
            'playlists\\local\\240110-181810-morning _ cinematic video 23-07-01.mp3',
            'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3',
          ],
          [
            'playlists\\S8 audio\\240701-163521-Jancovici m\'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3',
          ],
        ];

        await _verifyCreatedZipFilesContent(
          zipLst: zipLst,
          expectedZipContentLst: expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });

      testWidgets(
          '''Reduce ZIP file size limit to 1 MB and then execute the playlist menu 'Save the Playlist
            Audio's MP3 to ZIP file(s) on the 'S8 audio' playlist. Then, verify the confirmation dialog
            data which displays a small number of saved ZIP files since the majority of audio files were
            not added to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the
        // app settings dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 1 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '1',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the playlist menu 'Save the Playlist Audio's MP3 to
        // ZIP file(s) ...' on the 'S8 audio' playlist

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistTitle = 'S8 audio';

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $playlistTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 1, total size: 360 KB and total duration: 0:00:59.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${playlistTitle}_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "Those files are too large to be included in the MP3 saved ZIP file and so were not saved:\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB;\nS8 audio\\240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3, 2.37 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3'
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Reduce ZIP file size limit to 1 MB and delete '240701-163521-Jancovici m'explique
            l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3' the
            'S8 audio' playlist. Then execute the playlist menu 'Save the Playlist Audio's MP3
            to ZIP file(s) on the 'S8 audio' playlist and verify the confirmation dialog data
            which displays a greater number of saved ZIP files since only one audio file was not
            added to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        DirUtil.deleteFileIfExist(
          pathFileName:
              "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}local${path.separator}240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
        );

        DirUtil.deleteFileIfExist(
          pathFileName:
              "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}S8 audio${path.separator}240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the
        // app settings dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 2.6 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '1',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the playlist menu 'Save the Playlist Audio's MP3 to
        // ZIP file(s) ...' on the 'S8 audio' playlist

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistTitle = 'S8 audio';

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $playlistTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 1, total size: 360 KB and total duration: 0:00:59.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${playlistTitle}_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "This file is too large to be included in the MP3 saved ZIP file and so was not saved:\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3'
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Reduce ZIP file size limit to 2.6 MB Then execute the playlist menu 'Save the Playlist
            Audio's MP3 to ZIP file(s) on the 'S8 audio' playlist and verify the confirmation dialog
            data which displays a greater number of saved ZIP files since only one audio file was
            not added to the created ZIP file.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}app_settings_set_play_speed",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Tap the appbar leading popup menu button Then, the
        // app settings dialog is opened.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
        );

        // And reduce the ZIP file size limit to 2.6 MB

        // Find the TextField using the Key
        final Finder textFieldFinder =
            find.byKey(const Key('mp3ZipFileSizeLimitInMb'));

        await tester.enterText(
          textFieldFinder,
          '2.6',
        );

        await tester.pumpAndSettle();

        // And tap on save button
        await tester.tap(find.byKey(const Key('saveButton')));
        await tester.pumpAndSettle();

        // Now execute the playlist menu 'Save the Playlist Audio's MP3 to
        // ZIP file(s) ...' on the 'S8 audio' playlist

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistTitle = 'S8 audio';

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Confirm the saving of the audio mp3 files and close the
        // confirm dialog by tapping on the Confirm button.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump(); // Process the tap immediately

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $playlistTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        String oldestAudioDownloadDateTime = "07/01/2024 16:36";

        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $oldestAudioDownloadDateTime."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 2, total size: 2.73 MB and total duration: 0:07:28.0."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 2."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${playlistTitle}_mp3_from_2024-01-07_16_36_07_on_"));
        expect(
            actualMessage,
            contains(
                "This file is too large to be included in the MP3 saved ZIP file and so was not saved:\nS8 audio\\240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3, 2.79 MB."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<List<String>> expectedZipContentLst = [
          [
            'playlists\\S8 audio\\240110-181810-morning _ cinematic video 23-07-01.mp3',
          ],
          [
            'playlists\\S8 audio\\240701-163521-Jancovici m\'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3',
          ],
        ];

        await _verifyCreatedZipFilesContent(
          zipLst: zipLst,
          expectedZipContentLst: expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });
  group('Save playlist, comments, pictures and settings to zip file menu test',
      () {
    group('''Without checking the "Add all JPG pictures to ZIP" checkbox''',
        () {
      testWidgets(
          '''Successful save without checking the "Add all JPG pictures to ZIP" checkbox. The
           integration test verifies the confirmation displayed warning''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_delete_integr_test_data",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Create a new directory to which the zip file will be saved

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}appSave';

        DirUtil.createDirIfNotExistSync(
          pathStr: saveZipFilePath,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: saveZipFilePath,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // Does not check the "Add all JPG pictures to ZIP" checkbox
        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
          closeDialog: true,
        );

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        expect(
          actualMessage,
          contains(
            "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_",
          ),
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: saveZipFilePath,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "audio_learn_test_download_2_small_videos\\audio_learn_test_download_2_small_videos.json",
          "audio_learn_test_download_2_small_videos\\comments\\230628-033811-audio learn test short video one 23-06-10.json",
          "audio_learn_test_download_2_small_videos\\comments\\230628-033813-audio learn test short video two 23-06-10.json",
          "audio_player_view_2_shorts_test\\audio_player_view_2_shorts_test.json",
          "local_3\\local_3.json",
          "local_audio_playlist_2\\local_audio_playlist_2.json",
          'pictures\\pictureAudioMap.json',
          "settings.json",
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName: "$saveZipFilePath${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Unsuccessful save which happens on the S8 Galaxy smartphone. In the save to ZIP dialod,
           the "Add all JPG pictures to ZIP" checkbox is not checked. The integration test verifies
           the displayed warning.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_integr_test_data",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Create a new directory to which the zip file will be saved

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}appSave';

        DirUtil.createDirIfNotExistSync(
          pathStr: saveZipFilePath,
        );

        // Setting the path value returned by the FilePicker mock. This
        // path value is the one returned on the S8 Galaxy smartphone !
        mockFilePicker.setPathToSelect(
          pathToSelectStr: '/',
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // Does not check the "Add all JPG pictures to ZIP" checkbox
        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
          closeDialog: true,
        );

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Playlist, comment and picture JSON files as well as application settings could not be saved to ZIP.",
          isWarningConfirming: false,
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: saveZipFilePath,
          fileExtension: 'zip',
        );

        expect(zipLst.isEmpty, true);

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''After picture and comment addition, save to zip file without checking the
                "Add all JPG pictures to ZIP" checkbox.''',
          (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_zip_comment_picture_test',
          tapOnPlaylistToggleButton: false,
        );

        final String availablePicturesDir =
            "$kApplicationPathWindowsTest${path.separator}availablePictures";

        final String appPictureAudioMapDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        const String localPlaylistTitle = 'local';
        final String localPlaylistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";
        final String localPlaylistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";

        const String localAudioOneTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String localAudioOneDurationStr = '40:53';

        const String jesusChristPlaylistTitle = 'Jésus-Christ';
        final String jesusChristPlaylistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$jesusChristPlaylistTitle${path.separator}$kPictureDirName";

        const String jesusChristAudioOneTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';
        const String jesusChristAudioOneDurationStr = '24:07';

        const String pictureOneFileName = "Jésus, mon amour.jpg";
        const int pictureOneFileSize = 94507;
        const String pictureTwoFileName = "Jésus je T'adore.jpg";
        const int pictureTwoFileSize = 154529;
        const String pictureThreeFileName = "Jésus je T'aime.jpg";
        const int pictureThreeFileSize = 125867;
        const String pictureFourFileName = "Jésus l'Amour de ma vie.jpg";
        const int pictureFourFileSize = 187362;

        // Select the local playlist containing the audio to which we
        // will add a first picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // Verify that the appPictureAudioMap dir is  present
        Directory appPictureAudioMapDirectory =
            Directory(appPictureAudioMapDir);
        expect(appPictureAudioMapDirectory.existsSync(), true);

        // Verify that the local playlist picture dir is not present
        Directory localPlaylistPictureDirDirectory =
            Directory(localPlaylistPictureDir);
        expect(localPlaylistPictureDirDirectory.existsSync(), false);

        // First picture addition (to a local playlist audio)
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureOneFileName, // "Jésus, mon amour.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureOneFileSize,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
        );

        List<String> audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01"
        ];

        List<String> playlistJesusChristAudioOnePictureLstJsonFileName = [
          "241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json",
        ];

        // Now verifying the audio picture first addition result

        List<String> playlistLocalAudioOnePictureLstJsonFileName = [
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        List<String> audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          mustPlayableAudioListBeUsed: false,
        );

        // Now go back to the playlist download view, select another playlist
        // and add another picture to a new audio.

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Select the Jésus-Christ playlist containing the audio to which we
        // will add a first picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: jesusChristPlaylistTitle,
        );

        // Second picture addition (to a jésus-christ playlist audio)
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureOneFileName, // "Jésus, mon amour.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureOneFileSize,
          audioForPictureTitle:
              jesusChristAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: jesusChristPlaylistPictureJsonFilesDir,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitle:
              jesusChristAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
          audioForPictureTitleDurationStr: jesusChristAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistJesusChristAudioOnePictureLstJsonFileName,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          mustPlayableAudioListBeUsed: false,
        );

        // Go back to the playlist download view, re-select the local playlist
        // and add another picture to a the audio which already has a picture.

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Select the local playlist containing the audio to which we
        // will add a new picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // Third picture addition, to the local playlist audio which
        // already has a picture
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureTwoFileSize,
          audioForPictureTitle:
              localAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        List<String> audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        List<List<Picture>> expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
          ],
        ];

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          mustPlayableAudioListBeUsed: false,
        );

        // Return to the playlist download view and add another picture
        // to a the audio which already has two pictures.

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Fourth picture addition, to the local playlist audio which
        // already has two pictures
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureThreeFileName, // "Jésus je T'aime.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureThreeFileSize,
          audioForPictureTitle:
              localAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
            Picture(
              fileName: pictureThreeFileName, // "Jésus je T'aime.jpg"
            ),
          ],
        ];

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree: pictureThreeFileName, // "Jésus je T'aime.jpg"
          audioForPictureTitleThreeLst: audioForPictureTitleLstJesusJeTaime,
          mustPlayableAudioListBeUsed: false,
        );

        // Now go back to the playlist download view and remove the
        // last added audio picture

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Deleting the last added audio picture
        await _removeAudioPictureExecutingAudioListItemMenu(
          tester: tester,
          picturedAudioTitle: localAudioOneTitle,
        );

        await IntegrationTestUtil.verifyPictureSuppression(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureDir: localPlaylistPictureDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioPictureJsonFileName:
              playlistLocalAudioOnePictureLstJsonFileName[0],
          deletedPictureFileName:
              pictureThreeFileName, // "Jésus je T'adore.jpg"
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
        );

        // Now go back to the playlist download view and add again a
        // picture to the same audio whose picture was removed

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Third picture addition
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureFourFileSize,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
        );

        List<String> audioForPictureTitleLstJesusLamourDeMaVie = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
            Picture(
              fileName: pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
            ),
          ],
        ];

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree:
              pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
          audioForPictureTitleThreeLst:
              audioForPictureTitleLstJesusLamourDeMaVie,
          mustPlayableAudioListBeUsed: true,
        );

        // Finally, go back to the playlist download view and save
        // the playlists, comments, pictures and settings to a zip file

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}backupFolder';

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: saveZipFilePath,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // Does not check the "Add all JPG pictures to ZIP" checkbox
        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
          closeDialog: true,
        );

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_${yearMonthDayDateTimeFormatForFileName.format(DateTime.now().subtract(Duration(seconds: 1)))}.zip\".\n\nSaved also 4 picture JPG file(s) in same directory / pictures.",
          warningDialogMessageAlternative:
              "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_${yearMonthDayDateTimeFormatForFileName.format(DateTime.now())}.zip\".\n\nSaved also 4 picture JPG file(s) in same directory / pictures.",
          isWarningConfirming: true,
        );

        List<String> pictureNamesLst = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}backupFolder${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        List<String> expectedPictureNamesLst = [
          "Jésus je T'adore.jpg",
          "Jésus je T'aime.jpg",
          "Jésus l'Amour de ma vie.jpg",
          "Jésus, mon amour.jpg",
        ];
        expect(
          pictureNamesLst,
          expectedPictureNamesLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });

    group('''With checking the "Add all JPG pictures to ZIP" checkbox''', () {
      testWidgets(
          '''Successful save with checking the "Add all JPG pictures to ZIP" checkbox. The
           integration test verifies the confirmation displayed warning''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_delete_integr_test_data",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Create a new directory to which the zip file will be saved

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}appSave';

        DirUtil.createDirIfNotExistSync(
          pathStr: saveZipFilePath,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: saveZipFilePath,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
        );

        // Check the "Add all JPG pictures to ZIP" checkbox
        await tester.tap(find.byKey(const Key('checkbox_0_key')));
        await tester.pumpAndSettle();

        // Close the dialog with the OK button
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        expect(
          actualMessage,
          contains(
            "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_",
          ),
        );

        expect(
          actualMessage,
          contains(
            "\n\nSaved also 1 picture JPG file(s) in the ZIP file.",
          ),
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: saveZipFilePath,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "audio_learn_test_download_2_small_videos\\audio_learn_test_download_2_small_videos.json",
          "audio_learn_test_download_2_small_videos\\comments\\230628-033811-audio learn test short video one 23-06-10.json",
          "audio_learn_test_download_2_small_videos\\comments\\230628-033813-audio learn test short video two 23-06-10.json",
          "audio_player_view_2_shorts_test\\audio_player_view_2_shorts_test.json",
          "local_3\\local_3.json",
          "local_audio_playlist_2\\local_audio_playlist_2.json",
          "pictures\\pictureAudioMap.json",
          "settings.json",
          "pictures\\230628-033811-audio learn test short video one 23-06-10.jpg"
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName: "$saveZipFilePath${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Unsuccessful save which happens on the S8 Galaxy smartphone. In the save to ZIP dialod,
           the "Add all JPG pictures to ZIP" checkbox is checked. The integration test verifies the
           displayed warning.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}2_youtube_2_local_playlists_integr_test_data",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Create a new directory to which the zip file will be saved

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}appSave';

        DirUtil.createDirIfNotExistSync(
          pathStr: saveZipFilePath,
        );

        // Setting the path value returned by the FilePicker mock. This
        // path value is the one returned on the S8 Galaxy smartphone !
        mockFilePicker.setPathToSelect(
          pathToSelectStr: '/',
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
        );

        // Check the "Add all JPG pictures to ZIP" checkbox
        await tester.tap(find.byKey(const Key('checkbox_0_key')));
        await tester.pumpAndSettle();

        // Close the dialog with the OK button
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Playlist, comment and picture JSON files as well as application settings could not be saved to ZIP.",
          isWarningConfirming: false,
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: saveZipFilePath,
          fileExtension: 'zip',
        );

        expect(zipLst.isEmpty, true);

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''After picture and comment addition, save to zip file with checking the
             "Add all JPG pictures to ZIP" checkbox.''',
          (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_zip_comment_picture_test',
          tapOnPlaylistToggleButton: false,
        );

        final String availablePicturesDir =
            "$kApplicationPathWindowsTest${path.separator}availablePictures";

        final String appPictureAudioMapDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        const String localPlaylistTitle = 'local';
        final String localPlaylistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";
        final String localPlaylistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";

        const String localAudioOneTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String localAudioOneDurationStr = '40:53';

        const String jesusChristPlaylistTitle = 'Jésus-Christ';
        final String jesusChristPlaylistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$jesusChristPlaylistTitle${path.separator}$kPictureDirName";

        const String jesusChristAudioOneTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';
        const String jesusChristAudioOneDurationStr = '24:07';

        const String pictureOneFileName = "Jésus, mon amour.jpg";
        const int pictureOneFileSize = 94507;
        const String pictureTwoFileName = "Jésus je T'adore.jpg";
        const int pictureTwoFileSize = 154529;
        const String pictureThreeFileName = "Jésus je T'aime.jpg";
        const int pictureThreeFileSize = 125867;
        const String pictureFourFileName = "Jésus l'Amour de ma vie.jpg";
        const int pictureFourFileSize = 187362;

        // Select the local playlist containing the audio to which we
        // will add a first picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // Verify that the appPictureAudioMap dir is  present
        Directory appPictureAudioMapDirectory =
            Directory(appPictureAudioMapDir);
        expect(appPictureAudioMapDirectory.existsSync(), true);

        // Verify that the local playlist picture dir is not present
        Directory localPlaylistPictureDirDirectory =
            Directory(localPlaylistPictureDir);
        expect(localPlaylistPictureDirDirectory.existsSync(), false);

        // First picture addition (to a local playlist audio)
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureOneFileName, // "Jésus, mon amour.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureOneFileSize,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
        );

        List<String> audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01"
        ];

        List<String> playlistJesusChristAudioOnePictureLstJsonFileName = [
          "241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json",
        ];

        // Now verifying the audio picture first addition result

        List<String> playlistLocalAudioOnePictureLstJsonFileName = [
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        List<String> audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          mustPlayableAudioListBeUsed: false,
        );

        // Now go back to the playlist download view, select another playlist
        // and add another picture to a new audio.

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Select the Jésus-Christ playlist containing the audio to which we
        // will add a first picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: jesusChristPlaylistTitle,
        );

        // Second picture addition (to a jésus-christ playlist audio)
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureOneFileName, // "Jésus, mon amour.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureOneFileSize,
          audioForPictureTitle:
              jesusChristAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: jesusChristPlaylistPictureJsonFilesDir,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitle:
              jesusChristAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
          audioForPictureTitleDurationStr: jesusChristAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistJesusChristAudioOnePictureLstJsonFileName,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          mustPlayableAudioListBeUsed: false,
        );

        // Go back to the playlist download view, re-select the local playlist
        // and add another picture to a the audio which already has a picture.

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Select the local playlist containing the audio to which we
        // will add a new picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // Third picture addition, to the local playlist audio which
        // already has a picture
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureTwoFileSize,
          audioForPictureTitle:
              localAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        List<String> audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        List<List<Picture>> expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
          ],
        ];

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          mustPlayableAudioListBeUsed: false,
        );

        // Return to the playlist download view and add another picture
        // to a the audio which already has two pictures.

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Fourth picture addition, to the local playlist audio which
        // already has two pictures
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureThreeFileName, // "Jésus je T'aime.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureThreeFileSize,
          audioForPictureTitle:
              localAudioOneTitle, // NE VOUS METTEZ PLUS JAMAIS EN COLÈRE ...
        );

        audioForPictureTitleLstJesusMonAmour = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
            Picture(
              fileName: pictureThreeFileName, // "Jésus je T'aime.jpg"
            ),
          ],
        ];

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree: pictureThreeFileName, // "Jésus je T'aime.jpg"
          audioForPictureTitleThreeLst: audioForPictureTitleLstJesusJeTaime,
          mustPlayableAudioListBeUsed: false,
        );

        // Now go back to the playlist download view and remove the
        // last added audio picture

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Deleting the last added audio picture
        await _removeAudioPictureExecutingAudioListItemMenu(
          tester: tester,
          picturedAudioTitle: localAudioOneTitle,
        );

        await IntegrationTestUtil.verifyPictureSuppression(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureDir: localPlaylistPictureDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioPictureJsonFileName:
              playlistLocalAudioOnePictureLstJsonFileName[0],
          deletedPictureFileName:
              pictureThreeFileName, // "Jésus je T'adore.jpg"
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
        );

        // Now go back to the playlist download view and add again a
        // picture to the same audio whose picture was removed

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Third picture addition
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
          pictureSourcePath: availablePicturesDir,
          pictureFileSize: pictureFourFileSize,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
        );

        List<String> audioForPictureTitleLstJesusLamourDeMaVie = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        expectedPlaylistAudioPictureLst = [
          [
            Picture(
              fileName: pictureOneFileName, // "Jésus mon amour.jpg"
            ),
            Picture(
              fileName: pictureTwoFileName, // "Jésus je T'adore.jpg"
            ),
            Picture(
              fileName: pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
            ),
          ],
        ];

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: appPictureAudioMapDir,
          playlistPictureJsonFilesDir: localPlaylistPictureJsonFilesDir,
          audioForPictureTitle: localAudioOneTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: localAudioOneDurationStr,
          playlistAudioPictureJsonFileNameLst:
              playlistLocalAudioOnePictureLstJsonFileName,
          audioPictureJsonFileContentLst: expectedPlaylistAudioPictureLst,
          pictureFileNameOne: pictureOneFileName, // "Jésus mon amour.jpg"
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureTwoFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree:
              pictureFourFileName, // "Jésus l'Amour de ma vie.jpg"
          audioForPictureTitleThreeLst:
              audioForPictureTitleLstJesusLamourDeMaVie,
          mustPlayableAudioListBeUsed: true,
        );

        // Finally, go back to the playlist download view and save
        // the playlists, comments, pictures and settings to a zip file

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        String saveZipFilePath =
            '$kApplicationPathWindowsTest${path.separator}backupFolder';

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: saveZipFilePath,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
        );

        // Check the "Add all JPG pictures to ZIP" checkbox
        await tester.tap(find.byKey(const Key('checkbox_0_key')));
        await tester.pumpAndSettle();

        // Close the dialog with the OK button
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_${yearMonthDayDateTimeFormatForFileName.format(DateTime.now().subtract(Duration(seconds: 1)))}.zip\".\n\nSaved also 4 picture JPG file(s) in the ZIP file.",
          warningDialogMessageAlternative:
              "Saved playlist, comment and picture JSON files as well as application settings to \"$saveZipFilePath${path.separator}audioLearn_${yearMonthDayDateTimeFormatForFileName.format(DateTime.now())}.zip\".\n\nSaved also 4 picture JPG file(s) in the ZIP file.",
          isWarningConfirming: true,
        );

        List<String> pictureNamesLst = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}backupFolder${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        // Since the picture files were added to the creted save ZIP file,
        // the picture dir in the backupFolder should be empty
        List<String> expectedPictureNamesLst = [];
        expect(
          pictureNamesLst,
          expectedPictureNamesLst,
        );

        // Now re-tap the appbar leading popup menu button Then, the 'Save
        // Playlists and Comments to zip File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // This time, do not check the "Add all JPG pictures to ZIP" checkbox
        // and close the dialog with the OK button
        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Playlists Backup to ZIP',
          dialogMessage:
              "Checking the \"Add all JPG pictures to ZIP\" checkbox will add all the application audio pictures to the created ZIP. This is only useful if the ZIP file will be used to restore another application.",
          checkboxLabel: "Add all JPG pictures to ZIP",
          closeDialog: true,
        );

        // Verify that the picture files were now saved to the pictures
        // dir in the backupFolder

        pictureNamesLst = DirUtil.listFileNamesInDir(
          directoryPath:
              "$kApplicationPathWindowsTest${path.separator}backupFolder${path.separator}$kPictureDirName",
          fileExtension: 'jpg',
        );

        // Since the picture files were added to the creted save ZIP file,
        // the picture dir in the backupFolder should be empty
        expectedPictureNamesLst = [
          "Jésus je T'adore.jpg",
          "Jésus je T'aime.jpg",
          "Jésus l'Amour de ma vie.jpg",
          "Jésus, mon amour.jpg",
        ];
        expect(
          pictureNamesLst,
          expectedPictureNamesLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    testWidgets(
        '''Save unique Youtube playlist containing pictures to zip file.''',
        (WidgetTester tester) async {
      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'save_or_delete_playlist_with_pictures',
        tapOnPlaylistToggleButton: false,
      );

      const String playlistToSaveTitle = 'Restore- short - test - playlist';

      // Verify the zip files before saving the playlist.
      // Those zip files were copied from the integration test
      // data directory to the app test directory.

      List<String> zipLst = DirUtil.listFileNamesInDir(
        directoryPath: kApplicationPathWindowsTest,
        fileExtension: 'zip',
      );

      expect(
        zipLst,
        [
          'Windows audioLearn_2025-05-11_13_16.zip',
          'Windows Local restore- short - test - playlist.zip',
          'Windows Restore- short - test - playlist.zip'
        ],
      );

      // Save the playlist and its comments and pictures to a zip file

      // Setting the path value returned by the FilePicker mock.
      mockFilePicker.setPathToSelect(
        pathToSelectStr: kApplicationPathWindowsTest,
      );

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: playlistToSaveTitle,
        playlistMenuKeyStr: 'popup_menu_save_playlist_comments_pictures_to_zip',
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Saved playlist, comment and picture JSON files to \"$kApplicationPathWindowsTest${path.separator}$playlistToSaveTitle.zip\".\n\nSaved also 3 picture JPG file(s) in the ZIP file.",
        isWarningConfirming: true,
      );

      // Verify that the zip file has been created

      zipLst = DirUtil.listFileNamesInDir(
        directoryPath: kApplicationPathWindowsTest,
        fileExtension: 'zip',
      );

      expect(
        zipLst,
        [
          '$playlistToSaveTitle.zip',
          'Windows audioLearn_2025-05-11_13_16.zip',
          'Windows Local restore- short - test - playlist.zip',
          'Windows Restore- short - test - playlist.zip'
        ],
      );

      // Verify the content of the created ZIP file

      final zipFilePath =
          path.join(kApplicationPathWindowsTest, '$playlistToSaveTitle.zip');
      final zipFile = File(zipFilePath);

      // Read the ZIP file as bytes
      final List<int> bytes = await zipFile.readAsBytes();

      // Decode the ZIP
      final archive = ZipDecoder().decodeBytes(bytes);

      // Extract content types (Json and JPG files)
      final List<String> jsonFileNames = archive.files
          .where((file) => file.isFile && file.name.endsWith('.json'))
          .map((file) => file.name)
          .toList();

      final List<String> jpgFiles = archive.files
          .where((file) => file.isFile && file.name.endsWith('.jpg'))
          .map((file) => file.name)
          .toList();

      // Verify ZIP content
      final List<String> expectedJsonFileNames = [
        'playlists\\Restore- short - test - playlist\\comments\\250518-164039-morning _ cinematic video 23-07-01.json',
        'playlists\\Restore- short - test - playlist\\comments\\250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json',
        'playlists\\Restore- short - test - playlist\\pictures\\250518-164035-Really short video 23-07-01.json',
        'playlists\\Restore- short - test - playlist\\pictures\\250518-164039-morning _ cinematic video 23-07-01.json',
        'playlists\\Restore- short - test - playlist\\pictures\\250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json',
        'playlists\\Restore- short - test - playlist\\Restore- short - test - playlist.json',
        'pictures\\pictureAudioMap.json',
      ];

      int i = 0;
      for (String jsonFileName in jsonFileNames) {
        expect(jsonFileName, expectedJsonFileNames[i++]);
      }

      // Verify picture files are included
      expect(jpgFiles.length, 3); // Should have 3 JPG files

      // Check for specific expected pictures if you know their names
      expect(
        jpgFiles,
        contains('pictures\\Jean-Pierre.jpg'),
      );
      expect(
        jpgFiles,
        contains(
            'pictures\\Bora_Bora_2560_1440_Youtube_2 - Voyage vers l\'Inde intérieure.jpg'),
      );
      expect(
        jpgFiles,
        contains('pictures\\Jésus le Dieu vivant.jpg'),
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Save unique local playlist containing pictures to zip file.''',
        (WidgetTester tester) async {
      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'save_or_delete_local_playlist_with_pictures',
        tapOnPlaylistToggleButton: false,
      );

      const String playlistToSaveTitle =
          'Local restore- short - test - playlist';

      // Verify the zip files before saving the playlist.
      // Those zip files were copied from the integration test
      // data directory to the app test directory.

      List<String> zipLst = DirUtil.listFileNamesInDir(
        directoryPath: kApplicationPathWindowsTest,
        fileExtension: 'zip',
      );

      expect(
        zipLst,
        [
          'Windows audioLearn_2025-05-11_13_16.zip',
          'Windows Local restore- short - test - playlist.zip',
          'Windows Restore- short - test - playlist.zip'
        ],
      );

      // Save the playlist and its comments and pictures to a zip file

      // Setting the path value returned by the FilePicker mock.
      mockFilePicker.setPathToSelect(
        pathToSelectStr: kApplicationPathWindowsTest,
      );

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: playlistToSaveTitle,
        playlistMenuKeyStr: 'popup_menu_save_playlist_comments_pictures_to_zip',
      );

      // Verify the displayed warning dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Saved playlist, comment and picture JSON files to \"$kApplicationPathWindowsTest${path.separator}$playlistToSaveTitle.zip\".\n\nSaved also 3 picture JPG file(s) in the ZIP file.",
        isWarningConfirming: true,
      );

      // Verify that the zip file has been created

      zipLst = DirUtil.listFileNamesInDir(
        directoryPath: kApplicationPathWindowsTest,
        fileExtension: 'zip',
      );

      expect(
        zipLst,
        [
          '$playlistToSaveTitle.zip',
          'Windows audioLearn_2025-05-11_13_16.zip',
          'Windows Local restore- short - test - playlist.zip',
          'Windows Restore- short - test - playlist.zip'
        ],
      );

      // Verify the content of the created ZIP file

      final zipFilePath =
          path.join(kApplicationPathWindowsTest, '$playlistToSaveTitle.zip');
      final zipFile = File(zipFilePath);

      // Read the ZIP file as bytes
      final List<int> bytes = await zipFile.readAsBytes();

      // Decode the ZIP
      final archive = ZipDecoder().decodeBytes(bytes);

      // Extract content types (Json and JPG files)
      final List<String> jsonFileNames = archive.files
          .where((file) => file.isFile && file.name.endsWith('.json'))
          .map((file) => file.name)
          .toList();

      final List<String> jpgFiles = archive.files
          .where((file) => file.isFile && file.name.endsWith('.jpg'))
          .map((file) => file.name)
          .toList();

      // Verify ZIP content
      final List<String> expectedJsonFileNames = [
        'playlists\\Local restore- short - test - playlist\\comments\\250518-164039-morning _ cinematic video 23-07-01.json',
        'playlists\\Local restore- short - test - playlist\\comments\\250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json',
        'playlists\\Local restore- short - test - playlist\\Local restore- short - test - playlist.json',
        'playlists\\Local restore- short - test - playlist\\pictures\\250518-164035-Really short video 23-07-01.json',
        'playlists\\Local restore- short - test - playlist\\pictures\\250518-164039-morning _ cinematic video 23-07-01.json',
        'playlists\\Local restore- short - test - playlist\\pictures\\250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json',
        'pictures\\pictureAudioMap.json',
      ];

      int i = 0;
      for (String jsonFileName in jsonFileNames) {
        expect(jsonFileName, expectedJsonFileNames[i++]);
      }

      // Verify picture files are included
      expect(jpgFiles.length, 3); // Should have 3 JPG files

      // Check for specific expected pictures if you know their names
      expect(
        jpgFiles,
        contains('pictures\\Jean-Pierre.jpg'),
      );
      expect(
        jpgFiles,
        contains(
            'pictures\\Bora_Bora_2560_1440_Youtube_2 - Voyage vers l\'Inde intérieure.jpg'),
      );
      expect(
        jpgFiles,
        contains('pictures\\Jésus le Dieu vivant.jpg'),
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group(
      'Save audio mp3 files to zip files for all playlists or unique playlist test',
      () {
    group('Save playlists audio mp3 files to zip file menu test', () {
      testWidgets(
          '''Keep download date to the oldest one. The oldest value is 13/07/2025 14:31. The integration
          test verifies the confirmation displayed warning.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:",
          ],
          useContains: true,
          closeDialogWithConfirmButton: true,
        );

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $oldestAudioDownloadDateTime.\n\nTotal saved audio number: 5, total size: 64.47 MB and total duration: 2:40:27.2."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 5, total size: 64.47 MB and total duration: 2:40:27.2."));
        expect(actualMessage, contains("Save operation real duration: "));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2025-07-13_14_31_25_on_"));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "playlists\\Saint François d'Assise\\250714-171854-How to talk to animals The teaching of Saint Francis of Assisi 22-05-28.mp3",
          "playlists\\Saint François d'Assise\\250713-143130-Saint François d'Assise, le jongleur de Dieu 20-10-03.mp3",
          "playlists\\Saint François d'Assise\\250713-143125-4 octobre  - Saint François, le Saint qui a Transformé l'Église et le Monde 24-10-03.mp3",
          "playlists\\Exo chants chrétiens\\250713-144410-EXO - Ta bienveillance [avec paroles] 13-01-29.mp3",
          "playlists\\Exo chants chrétiens\\250713-144321-SI TU VEUX LE LOUER - EXO 17-05-31.mp3",
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set download date to more recent one. The less old value is 13/07/2025 14:41. The integration
          test verifies the confirmation displayed warning.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Verify that the TextField is focused using its focus node
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);
        expect(textField.focusNode?.hasFocus, isTrue,
            reason: 'TextField should be focused when dialog opens');

        // Now change the download date in the dialog
        String audioOldestDownloadDateTime = '13/07/2025 14:41';
        textField.controller!.text = audioOldestDownloadDateTime;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:01.",
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:02."
          ],
          closeDialogWithConfirmButton: true,
        );

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $audioOldestDownloadDateTime.\n\nTotal saved audio number: 3, total size: 15.49 MB and total duration: 0:22:38.0."));
        // expect(
        //     actualMessage,
        //     contains(
        //         "Total saved audio number: 3, total size: 15.49 MB and total duration: 0:22:38.0."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains(", number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2025-07-13_14_43_21_on_${yearMonthDayDateTimeFormatForFileName.format(DateTime.now().subtract(Duration(seconds: 1)))}.zip\"."));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "playlists\\Saint François d'Assise\\250714-171854-How to talk to animals The teaching of Saint Francis of Assisi 22-05-28.mp3",
          "playlists\\Exo chants chrétiens\\250713-144410-EXO - Ta bienveillance [avec paroles] 13-01-29.mp3",
          "playlists\\Exo chants chrétiens\\250713-144321-SI TU VEUX LE LOUER - EXO 17-05-31.mp3",
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set download date after the last download date. The set value is 14/07/2025 18:31. The integration
          test verifies the displayed warning indicating that no audio mp3 was saved to ZIP.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Verify that the TextField is focused using its focus node
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);
        expect(textField.focusNode?.hasFocus, isTrue,
            reason: 'TextField should be focused when dialog opens');

        // Now change the download date in the dialog
        const String tooRecentAudioDownloadDateTime = '15/07/2025 14:31';
        String audioOldestDownloadDateTime = tooRecentAudioDownloadDateTime;
        textField.controller!.text = audioOldestDownloadDateTime;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:00.",
          ],
          closeDialogWithConfirmButton: true,
          usePumpAndSettle: true,
        );

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "No audio MP3 file was saved to ZIP since no audio was downloaded on or after $tooRecentAudioDownloadDateTime.",
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        expect(
          zipLst.length,
          0,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Empty the download date. The integration test verifies the displayed error warning indicating
            that an empty download date is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now empty the download date in the dialog
        textField.controller!.text = '';
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Defining an empty date or date/time download date is not possible.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set incorrect download date format. The integration test verifies the displayed error warning indicating
            that an unacceptable download date/time format is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now enter an invalid download date in the dialog
        const String invalidDateFormat = '2909/2025';
        textField.controller!.text = invalidDateFormat;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "$invalidDateFormat does not respect the date or date/time format.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set incorrect download date/time format. The integration test verifies the displayed error warning indicating
            that an unacceptable download date/time format is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now enter an invalid download date/time in the dialog
        const String invalidDateTimeFormat = '29/09/2025 1508';
        textField.controller!.text = invalidDateTimeFormat;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "$invalidDateTimeFormat does not respect the date or date/time format.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Save unique playlist audio mp3 files to zip file menu test', () {
      testWidgets(
          '''Keep download date to the oldest one. The oldest value in the 'Saint François d'Assise'
          playlist is 13/07/2025 14:31. The integration test verifies the confirmation displayed
          warning.''', (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:",
          ],
          useContains: true,
          closeDialogWithConfirmButton: true,
        );

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $playlistToSaveTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;

        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $oldestAudioDownloadDateTime.\n\nTotal saved audio number: 3, total size: 53.12 MB and total duration: 2:29:08.4."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 3, total size: 53.12 MB and total duration: 2:29:08.4."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}Saint François d'Assise_mp3_from_2025-07-13_14_31_25_on_"));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "playlists\\Saint François d'Assise\\250714-171854-How to talk to animals The teaching of Saint Francis of Assisi 22-05-28.mp3",
          "playlists\\Saint François d'Assise\\250713-143130-Saint François d'Assise, le jongleur de Dieu 20-10-03.mp3",
          "playlists\\Saint François d'Assise\\250713-143125-4 octobre  - Saint François, le Saint qui a Transformé l'Église et le Monde 24-10-03.mp3",
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set download date to more recent one. A less old value will be 14/07/2025 14:31. The integration
          test verifies the confirmation displayed warning.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Verify that the TextField is focused using its focus node
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);
        expect(textField.focusNode?.hasFocus, isTrue,
            reason: 'TextField should be focused when dialog opens');

        // Now change the download date in the dialog. This date is
        // before the last download date of the playlist
        String audioOldestDownloadDateTime = '14/07/2025 14:31';
        textField.controller!.text = audioOldestDownloadDateTime;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:01.",
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:02.",
          ],
          closeDialogWithConfirmButton: true,
          usePumpAndSettle: true,
        );

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $audioOldestDownloadDateTime.\n\nTotal saved audio number: 1, total size: 4.14 MB and total duration: 0:11:19.3."));
        expect(
            actualMessage,
            contains(
                "Total saved audio number: 1, total size: 4.14 MB and total duration: 0:11:19.3."));
        expect(
            actualMessage, contains("Save operation real duration: 0:00:00"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains("number of created ZIP file(s): 1."));
        expect(
            actualMessage,
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}Saint François d'Assise_mp3_from_2025-07-14_17_18_54_on_"));

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        List<String> expectedZipContentLst = [
          "playlists\\Saint François d'Assise\\250714-171854-How to talk to animals The teaching of Saint Francis of Assisi 22-05-28.mp3",
        ];

        List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
          zipFilePathName:
              "$kApplicationPathWindowsTest${path.separator}${zipLst[0]}",
        );

        expect(
          zipContentLst,
          expectedZipContentLst,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set download date after the last download date. The set value is 14/07/2025 18:31. The integration
          test verifies the displayed warning indicating that no audio mp3 was saved to ZIP.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        expect(find.text('Date/time dd/MM/yyyy hh:mm'), findsOneWidget);

        const String oldestAudioDownloadDateTime = '13/07/2025 14:31';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Verify that the TextField is focused using its focus node
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);
        expect(textField.focusNode?.hasFocus, isTrue,
            reason: 'TextField should be focused when dialog opens');

        // Now change the download date in the dialog
        const String tooRecentAudioDownloadDateTime = '15/07/2025 14:31';
        String audioOldestDownloadDateTime = tooRecentAudioDownloadDateTime;
        textField.controller!.text = audioOldestDownloadDateTime;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration and accept save execution.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle: "Prevision of the Save Duration",
          confirmActionDialogMessagePossibleLst: [
            "Saving the audio MP3 files will take this estimated duration (hh:mm:ss): 0:00:00.",
          ],
          closeDialogWithConfirmButton: true,
          usePumpAndSettle: true,
        );

        // Verify the displayed warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "No audio MP3 file was saved to ZIP since no audio was downloaded on or after $tooRecentAudioDownloadDateTime.",
        );

        List<String> zipLst = DirUtil.listFileNamesInDir(
          directoryPath: kApplicationPathWindowsTest,
          fileExtension: 'zip',
        );

        expect(
          zipLst.length,
          0,
        );
        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Empty the download date. The integration test verifies the displayed error warning indicating
            that an empty download date is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        // Type on the playlist popup menu item to save its audio
        // mp3 files to zip
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now empty the download date in the dialog
        textField.controller!.text = '';
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "Defining an empty date or date/time download date is not possible.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set incorrect download date format. The integration test verifies the displayed error warning indicating
            that an unacceptable download date/time format is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        // Type on the playlist popup menu item to save its audio
        // mp3 files to zip
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now enter an invalid download date in the dialog
        const String invalidDateFormat = '2909/2025';
        textField.controller!.text = invalidDateFormat;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "$invalidDateFormat does not respect the date or date/time format.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Set incorrect download date/time format. The integration test verifies the displayed error warning indicating
            that an unacceptable download date/time format is not possible.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath:
              "$kDownloadAppTestSavedDataDir${path.separator}save_audio_mp3_to_zip",
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // First, set the application language to english
        await IntegrationTestUtil.setApplicationLanguage(
          tester: tester,
          language: Language.english,
        );

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        const String playlistToSaveTitle = "Saint François d'Assise";

        // Type on the playlist popup menu item to save its audio
        // mp3 files to zip
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: playlistToSaveTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        // Now enter an invalid download date/time in the dialog
        const String invalidDateTimeFormat = '29/09/2025 1508';
        textField.controller!.text = invalidDateTimeFormat;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        // Verify the displayed error warning dialog
        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "$invalidDateTimeFormat does not respect the date or date/time format.",
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        // Tap on the cancel button of the set value to target dialog
        await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });
  group(
      'Save and restore text to speech audio mp3 files to zip files for all playlists or unique playlist test',
      () {
    group('Handling multiple playlists', () {
      testWidgets(
          '''Not replace existing playlists. Set download date to today's date without time. The less old value
          awailable by default is 10/01/2024 18:18 and will be changed to today's date without time. Since the
          converted text to speech audio was modified today after 00:00 time, this audio will be the unique audio
          added to the created mp3 zip.
          
          Then delete the 2 playlists and restore again using audioLearn_2025-09-07_07_45_02.zip as well as
          audioLearn_mp3_from_2025-09-07_07_37_32_on_2025-09-24_13_54_22.zip. Then verify the restored 'aaa'
          converted audio duration. Then restore using the two last created zip (playlists and mp3) and verify that
          the version of the 'aaa' converted audio was correctly updated.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        final String sourceRootPath =
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator";

        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath: sourceRootPath,
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Restoring the initial 'local' and "urgent_actus_17-12-2023" playlists and their mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: 'audioLearn_2025-09-07_07_45_02.zip',
          restorableMp3ZipFileName:
              'audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip',
          mockFilePicker: mockFilePicker,
        );

        const String unselectedYoutubePlaylistTitle = "urgent_actus_17-12-2023";

        // Open the convert text to audio dialog
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: unselectedYoutubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
        );

        // Find the text field finder
        final Finder textFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        // Now enter the text to convert to audio
        await tester.enterText(textFieldFinder,
            "Nouvelle description des éléments restaurés {{{{ avec 4 secondes de pause. Et une fin de phrase.");
        await tester.pump();

        // Now click on Create MP3 button to create the audio
        Finder createMP3ButtonFinder =
            find.byKey(const Key('create_audio_file_button'));
        await tester.tap(createMP3ButtonFinder);
        await tester.pumpAndSettle();

        const String enteredFileNameNoExt = 'aaa';
        Finder mp3FileNameTextFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        await tester.enterText(
            mp3FileNameTextFieldFinder, enteredFileNameNoExt);
        await tester.pumpAndSettle();

        // Tap on the create mp3 button
        Finder saveMP3FileButton =
            find.byKey(const Key('create_mp3_button_key'));
        await tester.tap(saveMP3FileButton);
        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates that the saved
        // file name already exist and ask to confirm or cancel the
        // save operation.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle:
              "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$unselectedYoutubePlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
          confirmActionDialogMessagePossibleLst: [""],
          closeDialogWithConfirmButton: true,
        );

        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in Youtube playlist \"$unselectedYoutubePlaylistTitle\".",
          isWarningConfirming: true,
        );

        // Now close the convert text to audio dialog by tapping
        // the Ok button
        Finder cancelButtonFinder =
            find.byKey(const Key('convertTextToAudioCancelButton'));
        await tester.tap(cancelButtonFinder);
        await tester.pumpAndSettle();

        // Now save the playlists ...

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists, Comments, Pictures and Settings to ZIP File' menu
        // is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // Tap on the Ok button
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        String? warningDialogMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data;
        String playlistsNewSavedZipFileName =
            _extractZipFileName(warningDialogMessage!);

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // And save the playlists mp3 files ...

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        const String oldestAudioDownloadDateTime = '10/01/2024 18:18';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Now change the download date in the dialog
        final String audioOldestDownloadDateToday =
            DateFormat('dd/MM/yyyy').format(DateTime.now());
        final String audioOldestDownloadDateTodayForFileNName =
            DateFormat('yyyy-MM-dd').format(DateTime.now());
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        textField.controller!.text = audioOldestDownloadDateToday;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        DateTime now = DateTime.now();

        // Now tap on the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration ok buton to accept the save
        // execution.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump();

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $audioOldestDownloadDateToday 00:00.\n\nTotal saved audio number: 1, total size: 68 KB and total duration: 0:00:08.6."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains(", number of created ZIP file(s): 1."));
        expect(
          actualMessage,
          anyOf([
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now)}.zip\"."),
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now.subtract(const Duration(seconds: 1)))}.zip\"."),
          ]),
        );

        String playlistsMp3NewSavedZipFileName = _extractMp3ZipFileName(
          confirmationMessage: actualMessage,
          zipStartFileName: 'audioLearn',
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // Now delete the two 'local' and "urgent_actus_17-12-2023" playlists
        // (their mp3 files are also deleted)

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: 'local',
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: 'urgent_actus_17-12-2023',
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Restoring the initial 'local' and "urgent_actus_17-12-2023" playlists and their mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: 'audioLearn_2025-09-07_07_45_02.zip',
          restorableMp3ZipFileName:
              'audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip',
          mockFilePicker: mockFilePicker,
        );

        // Select the "urgent_actus_17-12-2023" playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: unselectedYoutubePlaylistTitle,
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 1.8 seconds

        // Find the audio list widget using its key
        Finder listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:01.8 14 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 3,
        );

        // Now restoring the last saved 'local' and "urgent_actus_17-12-2023" playlists and
        // their mp3 files without replacing existing playlists
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: playlistsNewSavedZipFileName,
          restorableMp3ZipFileName: playlistsMp3NewSavedZipFileName,
          mockFilePicker: mockFilePicker,
          doReplaceExistingPlaylists: false,
          restorePlaylistsConfirmationMessage:
              'Restored 0 playlist, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 1 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "$kApplicationPathWindowsTest${path.separator}$playlistsNewSavedZipFileName".',
          restoreMp3ConfirmationMessage:
              "Restored 1 audio(s) MP3 in 1 playlist(s) from the multiple playlists MP3 zip file \"$kApplicationPathWindowsTest${path.separator}$playlistsMp3NewSavedZipFileName\".",
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 8.6 seconds

        // Find the audio list widget using its key
        listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:08.6 68 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 3,
        );

        // Now we want to tap on the 'aaa' audio in order to open the
        // AudioPlayerView displaying the audio. The purpose is to
        // verify that the duration of the audio is indeed 8.6 seconds
        // as indicated in the audio subtitle on the audio list displayed
        // on the plalist download view.

        // First, get the 'aaa' audio ListTile Text widget finder and
        // tap on it

        final Finder aaaAudioListTileTextWidgetFinder = find.text('aaa');

        await tester.tap(aaaAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        String aaaAudioTitleText = (tester.widget<Text>(
                find.byKey(const Key('audioPlayerViewCurrentAudioTitle'))))
            .data!;

        String aaaAudioDurationStr = _extractDuration(aaaAudioTitleText);

        expect(aaaAudioDurationStr, '0:09');

        // Go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyAudioInfoDialog(
          tester: tester,
          audioType: AudioType.textToSpeech,
          validVideoTitleOrAudioTitle: 'aaa',
          audioDownloadDateTime:
              "07/09/2025 07:37", // this is the imported date time
          copiedToPlaylistTitle: 'local',
          audioDuration: '0:00:08.6',
          audioFileSize: '68 KB',
          isMusicQuality: false, // Is spoken quality
          audioPlaySpeed: '1.25',
          audioVolume: '50.0 %',
          audioCommentNumber: 2,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Replace existing playlists. Set download date to today's date without time. The less old value
          awailable by default is 10/01/2024 18:18 and will be changed to today's date without time. Since the
          converted text to speech audio was modified today after 00:00 time, this audio will be the unique audio
          added to the created mp3 zip.
          
          Then delete the 2 playlists and restore again using audioLearn_2025-09-07_07_45_02.zip as well as
          audioLearn_mp3_from_2025-09-07_07_37_32_on_2025-09-24_13_54_22.zip. Then verify the restored 'aaa'
          converted audio duration. Then restore using the two last created zip (playlists and mp3) and verify that
          the version of the 'aaa' converted audio was correctly updated.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        final String sourceRootPath =
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator";

        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath: sourceRootPath,
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        // Restoring the initial 'local' and "urgent_actus_17-12-2023" playlists and their mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: 'audioLearn_2025-09-07_07_45_02.zip',
          restorableMp3ZipFileName:
              'audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip',
          mockFilePicker: mockFilePicker,
        );

        const String unselectedYoutubePlaylistTitle = "urgent_actus_17-12-2023";

        // Open the convert text to audio dialog
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: unselectedYoutubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
        );

        // Find the text field finder
        final Finder textFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        // Now enter the text to convert to audio
        await tester.enterText(textFieldFinder,
            "Nouvelle description des éléments restaurés {{{{ avec 4 secondes de pause. Et une fin de phrase.");
        await tester.pump();

        // Now click on Create MP3 button to create the audio
        Finder createMP3ButtonFinder =
            find.byKey(const Key('create_audio_file_button'));
        await tester.tap(createMP3ButtonFinder);
        await tester.pumpAndSettle();

        const String enteredFileNameNoExt = 'aaa';
        Finder mp3FileNameTextFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        await tester.enterText(
            mp3FileNameTextFieldFinder, enteredFileNameNoExt);
        await tester.pumpAndSettle();

        // Tap on the create mp3 button
        Finder saveMP3FileButton =
            find.byKey(const Key('create_mp3_button_key'));
        await tester.tap(saveMP3FileButton);
        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates that the saved
        // file name already exist and ask to confirm or cancel the
        // save operation.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle:
              "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$unselectedYoutubePlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
          confirmActionDialogMessagePossibleLst: [""],
          closeDialogWithConfirmButton: true,
        );

        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in Youtube playlist \"$unselectedYoutubePlaylistTitle\".",
          isWarningConfirming: true,
        );

        // Now close the convert text to audio dialog by tapping
        // the Ok button
        Finder cancelButtonFinder =
            find.byKey(const Key('convertTextToAudioCancelButton'));
        await tester.tap(cancelButtonFinder);
        await tester.pumpAndSettle();

        // Now save the playlists ...

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists, Comments, Pictures and Settings to ZIP File' menu
        // is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAndCommentsToZip',
        );

        // Tap on the Ok button
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        String? warningDialogMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data;
        String playlistsNewSavedZipFileName =
            _extractZipFileName(warningDialogMessage!);

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // And save the playlists mp3 files ...

        // Tap the appbar leading popup menu button Then, the 'Save
        // Playlists Audio's MP3 to ZIP File' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from all playlists. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        const String oldestAudioDownloadDateTime = '10/01/2024 18:18';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Now change the download date in the dialog
        final String audioOldestDownloadDateToday =
            DateFormat('dd/MM/yyyy').format(DateTime.now());
        final String audioOldestDownloadDateTodayForFileNName =
            DateFormat('yyyy-MM-dd').format(DateTime.now());
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        textField.controller!.text = audioOldestDownloadDateToday;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        DateTime now = DateTime.now();

        // Now tap on the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration ok buton to accept the save
        // execution.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump();

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving multiple playlists audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP all playlists audio MP3 files downloaded from $audioOldestDownloadDateToday 00:00.\n\nTotal saved audio number: 1, total size: 68 KB and total duration: 0:00:08.6."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains(", number of created ZIP file(s): 1."));
        expect(
          actualMessage,
          anyOf([
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now)}.zip\"."),
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now.subtract(const Duration(seconds: 1)))}.zip\"."),
          ]),
        );

        String playlistsMp3NewSavedZipFileName = _extractMp3ZipFileName(
          confirmationMessage: actualMessage,
          zipStartFileName: 'audioLearn',
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // Now delete the two 'local' and "urgent_actus_17-12-2023" playlists
        // (their mp3 files are also deleted)

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: 'local',
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: 'urgent_actus_17-12-2023',
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Restoring the initial 'local' and "urgent_actus_17-12-2023" playlists and their mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: 'audioLearn_2025-09-07_07_45_02.zip',
          restorableMp3ZipFileName:
              'audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip',
          mockFilePicker: mockFilePicker,
        );

        // Select the "urgent_actus_17-12-2023" playlist
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: unselectedYoutubePlaylistTitle,
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 1.8 seconds

        // Find the audio list widget using its key
        Finder listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:01.8 14 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 3,
        );

        // Now restoring the last saved 'local' and "urgent_actus_17-12-2023" playlists and
        // their mp3 files with replacing existing playlists
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: playlistsNewSavedZipFileName,
          restorableMp3ZipFileName: playlistsMp3NewSavedZipFileName,
          mockFilePicker: mockFilePicker,
          doReplaceExistingPlaylists: true,
          restorePlaylistsConfirmationMessage:
              'Restored 2 playlist, 0 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 10 audio reference(s) and 1 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "$kApplicationPathWindowsTest${path.separator}$playlistsNewSavedZipFileName".',
          restoreMp3ConfirmationMessage:
              "Restored 1 audio(s) MP3 in 1 playlist(s) from the multiple playlists MP3 zip file \"$kApplicationPathWindowsTest${path.separator}$playlistsMp3NewSavedZipFileName\".",
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 8.6 seconds

        // Find the audio list widget using its key
        listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:08.6 68 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 3,
        );

        // Now we want to tap on the 'aaa' audio in order to open the
        // AudioPlayerView displaying the audio. The purpose is to
        // verify that the duration of the audio is indeed 8.6 seconds
        // as indicated in the audio subtitle on the audio list displayed
        // on the plalist download view.

        // First, get the 'aaa' audio ListTile Text widget finder and
        // tap on it

        final Finder aaaAudioListTileTextWidgetFinder = find.text('aaa');

        await tester.tap(aaaAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        String aaaAudioTitleText = (tester.widget<Text>(
                find.byKey(const Key('audioPlayerViewCurrentAudioTitle'))))
            .data!;

        String aaaAudioDurationStr = _extractDuration(aaaAudioTitleText);

        expect(aaaAudioDurationStr, '0:09');

        // Go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyAudioInfoDialog(
          tester: tester,
          audioType: AudioType.textToSpeech,
          validVideoTitleOrAudioTitle: 'aaa',
          audioDownloadDateTime:
              "07/09/2025 07:37", // this is the imported date time
          copiedToPlaylistTitle: 'local',
          audioDuration: '0:00:08.6',
          audioFileSize: '68 KB',
          isMusicQuality: false, // Is spoken quality
          audioPlaySpeed: '1.25',
          audioVolume: '50.0 %',
          audioCommentNumber: 2,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Handling unique playlist', () {
      testWidgets(
          '''Not replace existing playlist. Set download date to today's date without time. The less old value
          awailable by default is 10/01/2024 18:18 and will be changed to today's date without time. Since the
          converted text to speech audio was modified today after 00:00 time, this audio will be the unique audio
          added to the created mp3 zip.
          
          Then delete the 2 playlists and restore again using audioLearn_2025-09-07_07_45_02.zip as well as
          audioLearn_mp3_from_2025-09-07_07_37_32_on_2025-09-24_13_54_22.zip. Then verify the restored 'aaa'
          converted audio duration. Then restore using the two last created zip (playlists and mp3) and verify that
          the version of the 'aaa' converted audio was correctly updated.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        final String sourceRootPath =
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator";

        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath: sourceRootPath,
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        const String youtubePlaylistTitle = "urgent_actus_17-12-2023";

        // Restoring the initial "urgent_actus_17-12-2023" playlist and its mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: '$youtubePlaylistTitle.zip',
          restorableMp3ZipFileName:
              '${youtubePlaylistTitle}_mp3_from_2025-08-12_16_29_25_on_2025-09-28_21_50_57.zip',
          mockFilePicker: mockFilePicker,
        );

        // Open the convert text to audio dialog
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
        );

        // Find the text field finder
        final Finder textFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        // Now enter the text to convert to audio
        await tester.enterText(textFieldFinder,
            "Nouvelle description des éléments restaurés {{{{ avec 4 secondes de pause. Et une fin de phrase.");
        await tester.pump();

        // Now click on Create MP3 button to create the audio
        Finder createMP3ButtonFinder =
            find.byKey(const Key('create_audio_file_button'));
        await tester.tap(createMP3ButtonFinder);
        await tester.pumpAndSettle();

        const String enteredFileNameNoExt = 'aaa';
        Finder mp3FileNameTextFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        await tester.enterText(
            mp3FileNameTextFieldFinder, enteredFileNameNoExt);
        await tester.pumpAndSettle();

        // Tap on the create mp3 button
        Finder saveMP3FileButton =
            find.byKey(const Key('create_mp3_button_key'));
        await tester.tap(saveMP3FileButton);
        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates that the saved
        // file name already exist and ask to confirm or cancel the
        // save operation.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle:
              "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$youtubePlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
          confirmActionDialogMessagePossibleLst: [""],
          closeDialogWithConfirmButton: true,
        );

        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in Youtube playlist \"$youtubePlaylistTitle\".",
          isWarningConfirming: true,
        );

        // Now close the convert text to audio dialog by tapping
        // the Ok button
        Finder cancelButtonFinder =
            find.byKey(const Key('convertTextToAudioCancelButton'));
        await tester.tap(cancelButtonFinder);
        await tester.pumpAndSettle();

        // Now save the playlist ...

        // But first rename the existing unique playlist zip file so
        // that it is not overwritten by the next save operation
        final String initialUniquePlaylistZipFileName =
            '$youtubePlaylistTitle.zip';
        final String renamedInitialUniquePlaylistZipFileName =
            '${youtubePlaylistTitle}_initial.zip';
        File('$kApplicationPathWindowsTest${path.separator}$initialUniquePlaylistZipFileName')
            .renameSync(
                '$kApplicationPathWindowsTest${path.separator}$renamedInitialUniquePlaylistZipFileName');

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr:
              'popup_menu_save_playlist_comments_pictures_to_zip',
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // And save the playlist mp3 files ...

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        const String oldestAudioDownloadDateTime = '12/08/2025 16:29';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Now change the download date in the dialog
        final String audioOldestDownloadDateToday =
            DateFormat('dd/MM/yyyy').format(DateTime.now());
        final String audioOldestDownloadDateTodayForFileNName =
            DateFormat('yyyy-MM-dd').format(DateTime.now());
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        textField.controller!.text = audioOldestDownloadDateToday;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        DateTime now = DateTime.now();

        // Now tap on the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration ok buton to accept the save
        // execution.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump();

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $youtubePlaylistTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $audioOldestDownloadDateToday 00:00.\n\nTotal saved audio number: 1, total size: 68 KB and total duration: 0:00:08.6."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains(", number of created ZIP file(s): 1."));
        expect(
          actualMessage,
          anyOf([
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${youtubePlaylistTitle}_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now)}.zip\"."),
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${youtubePlaylistTitle}_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now.subtract(const Duration(seconds: 1)))}.zip\"."),
          ]),
        );

        String playlistMp3NewSavedZipFileName = _extractMp3ZipFileName(
          confirmationMessage: actualMessage,
          zipStartFileName: youtubePlaylistTitle,
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // Now delete the "urgent_actus_17-12-2023" playlist (their
        // mp3 files are also deleted)

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: youtubePlaylistTitle,
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Restoring the initial "urgent_actus_17-12-2023" playlist and its mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName:
              renamedInitialUniquePlaylistZipFileName,
          restorableMp3ZipFileName:
              '${youtubePlaylistTitle}_mp3_from_2025-08-12_16_29_25_on_2025-09-28_21_50_57.zip',
          mockFilePicker: mockFilePicker,
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 1.8 seconds

        // Find the audio list widget using its key
        Finder listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:01.8 14 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 1,
        );

        // Now restoring the last saved "urgent_actus_17-12-2023" playlist
        // and its mp3 files without replacing the existing playlist
        await _restorePaylistsAndTheirMp3(
            tester: tester,
            sourceRootPath: kApplicationPathWindowsTest,
            restorablePlaylistsZipFileName: '$youtubePlaylistTitle.zip',
            restorableMp3ZipFileName: playlistMp3NewSavedZipFileName,
            mockFilePicker: mockFilePicker,
            doReplaceExistingPlaylists: false,
            restorePlaylistsConfirmationMessage:
                'Restored 0 playlist saved individually, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 1 added plus 0 modified comment(s) in existing audio comment file(s) from "$kApplicationPathWindowsTest${path.separator}$youtubePlaylistTitle.zip".',
            restoreMp3ConfirmationMessage:
                "Restored 1 audio(s) MP3 in 1 playlist from the unique playlist MP3 zip file \"$kApplicationPathWindowsTest${path.separator}$playlistMp3NewSavedZipFileName\".",
            restoreMp3FromUniquePlaylistTitle: youtubePlaylistTitle);

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 8.6 seconds

        // Find the audio list widget using its key
        listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:08.6 68 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 1,
        );

        // Now we want to tap on the 'aaa' audio in order to open the
        // AudioPlayerView displaying the audio. The purpose is to
        // verify that the duration of the audio is indeed 8.6 seconds
        // as indicated in the audio subtitle on the audio list displayed
        // on the plalist download view.

        // First, get the 'aaa' audio ListTile Text widget finder and
        // tap on it

        final Finder aaaAudioListTileTextWidgetFinder = find.text('aaa');

        await tester.tap(aaaAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        String aaaAudioTitleText = (tester.widget<Text>(
                find.byKey(const Key('audioPlayerViewCurrentAudioTitle'))))
            .data!;

        String aaaAudioDurationStr = _extractDuration(aaaAudioTitleText);

        expect(aaaAudioDurationStr, '0:09');

        // Go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyAudioInfoDialog(
          tester: tester,
          audioType: AudioType.textToSpeech,
          validVideoTitleOrAudioTitle: 'aaa',
          audioDownloadDateTime:
              "07/09/2025 07:37", // this is the imported date time
          copiedToPlaylistTitle: 'local',
          audioDuration: '0:00:08.6',
          audioFileSize: '68 KB',
          isMusicQuality: false, // Is spoken quality
          audioPlaySpeed: '1.25',
          audioVolume: '50.0 %',
          audioCommentNumber: 2,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Replace existing playlist. Set download date to today's date without time. The less old value
          awailable by default is 10/01/2024 18:18 and will be changed to today's date without time. Since the
          converted text to speech audio was modified today after 00:00 time, this audio will be the unique audio
          added to the created mp3 zip.
          
          Then delete the 2 playlists and restore again using audioLearn_2025-09-07_07_45_02.zip as well as
          audioLearn_mp3_from_2025-09-07_07_37_32_on_2025-09-24_13_54_22.zip. Then verify the restored 'aaa'
          converted audio duration. Then restore using the two last created zip (playlists and mp3) and verify that
          the version of the 'aaa' converted audio was correctly updated.''',
          (WidgetTester tester) async {
        // Purge the test playlist directory if it exists so that the
        // playlist list is empty
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );

        // Copy the test initial audio data to the app dir
        final String sourceRootPath =
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator";

        DirUtil.copyFilesFromDirAndSubDirsToDirectory(
          sourceRootPath: sourceRootPath,
          destinationRootPath: kApplicationPathWindowsTest,
        );

        final SettingsDataService settingsDataService = SettingsDataService(
          sharedPreferences: await SharedPreferences.getInstance(),
          isTest: true,
        );

        // Load the settings from the json file. This is necessary
        // otherwise the ordered playlist titles will remain empty
        // and the playlist list will not be filled with the
        // playlists available in the app test dir
        await settingsDataService.loadSettingsFromFile(
            settingsJsonPathFileName:
                "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await app.main();
        await tester.pumpAndSettle();

        const String youtubePlaylistTitle = "urgent_actus_17-12-2023";

        // Restoring the initial "urgent_actus_17-12-2023" playlist and its mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName: '$youtubePlaylistTitle.zip',
          restorableMp3ZipFileName:
              '${youtubePlaylistTitle}_mp3_from_2025-08-12_16_29_25_on_2025-09-28_21_50_57.zip',
          mockFilePicker: mockFilePicker,
        );

        // Open the convert text to audio dialog
        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
        );

        // Find the text field finder
        final Finder textFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        // Now enter the text to convert to audio
        await tester.enterText(textFieldFinder,
            "Nouvelle description des éléments restaurés {{{{ avec 4 secondes de pause. Et une fin de phrase.");
        await tester.pump();

        // Now click on Create MP3 button to create the audio
        Finder createMP3ButtonFinder =
            find.byKey(const Key('create_audio_file_button'));
        await tester.tap(createMP3ButtonFinder);
        await tester.pumpAndSettle();

        const String enteredFileNameNoExt = 'aaa';
        Finder mp3FileNameTextFieldFinder =
            find.byKey(const Key('textToConvertTextField'));

        await tester.enterText(
            mp3FileNameTextFieldFinder, enteredFileNameNoExt);
        await tester.pumpAndSettle();

        // Tap on the create mp3 button
        Finder saveMP3FileButton =
            find.byKey(const Key('create_mp3_button_key'));
        await tester.tap(saveMP3FileButton);
        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        // Now check the confirm dialog which indicates that the saved
        // file name already exist and ask to confirm or cancel the
        // save operation.
        await IntegrationTestUtil.verifyConfirmActionDialog(
          tester: tester,
          confirmActionDialogTitle:
              "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$youtubePlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
          confirmActionDialogMessagePossibleLst: [""],
          closeDialogWithConfirmButton: true,
        );

        await Future.delayed(const Duration(seconds: 2));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
          tester: tester,
          warningDialogMessage:
              "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in Youtube playlist \"$youtubePlaylistTitle\".",
          isWarningConfirming: true,
        );

        // Now close the convert text to audio dialog by tapping
        // the Ok button
        Finder cancelButtonFinder =
            find.byKey(const Key('convertTextToAudioCancelButton'));
        await tester.tap(cancelButtonFinder);
        await tester.pumpAndSettle();

        // Now save the playlist ...

        // But first rename the existing unique playlist zip file so
        // that it is not overwritten by the next save operation
        final String initialUniquePlaylistZipFileName =
            '$youtubePlaylistTitle.zip';
        final String renamedInitialUniquePlaylistZipFileName =
            '${youtubePlaylistTitle}_initial.zip';
        File('$kApplicationPathWindowsTest${path.separator}$initialUniquePlaylistZipFileName')
            .renameSync(
                '$kApplicationPathWindowsTest${path.separator}$renamedInitialUniquePlaylistZipFileName');

        // Setting the path value returned by the FilePicker mock.
        mockFilePicker.setPathToSelect(
          pathToSelectStr: kApplicationPathWindowsTest,
        );

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr:
              'popup_menu_save_playlist_comments_pictures_to_zip',
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // And save the playlist mp3 files ...

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
          playlistMenuKeyStr: 'popup_menu_save_playlist_audio_mp3_files_to_zip',
        );

        await IntegrationTestUtil.verifySetValueToTargetDialog(
          tester: tester,
          dialogTitle: 'Set the Download Date',
          dialogMessage:
              'The default specified download date corresponds to the oldest audio download date from the playlist. Modify this value by specifying the download date from which the audio MP3 files will be included in the ZIP.',
        );

        const String oldestAudioDownloadDateTime = '12/08/2025 16:29';

        expect(find.text(oldestAudioDownloadDateTime), findsOneWidget);

        Finder setValueToTargetDialogFinder =
            find.byType(SetValueToTargetDialog);

        // This finder obtained as descendant of its enclosing dialog does
        // enable to change the value of the TextField
        Finder setValueToTargetDialogEditTextFinder = find.descendant(
          of: setValueToTargetDialogFinder,
          matching: find.byType(TextField),
        );

        // Now change the download date in the dialog
        final String audioOldestDownloadDateToday =
            DateFormat('dd/MM/yyyy').format(DateTime.now());
        final String audioOldestDownloadDateTodayForFileNName =
            DateFormat('yyyy-MM-dd').format(DateTime.now());
        TextField textField =
            tester.widget<TextField>(setValueToTargetDialogEditTextFinder);

        textField.controller!.text = audioOldestDownloadDateToday;
        await tester.pumpAndSettle();

        // Tap on the Ok button to set download date time.
        await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
        await tester.pumpAndSettle();

        DateTime now = DateTime.now();

        // Now tap on the confirm dialog which indicates the estimated
        // save audio mp3 to zip duration ok buton to accept the save
        // execution.
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pump();

        // Only works if tester.pump() is used instead of
        // tester.pumpAndSettle()
        expect(
          find.text("Saving $youtubePlaylistTitle audio files to ZIP ..."),
          findsOneWidget,
        );
        expect(
          tester
              .widget<Text>(find.byKey(const Key('saving_please_wait')).last)
              .data!,
          contains(
            "Should approxim. take ",
          ),
        );

        // Wait for completion
        await tester.pumpAndSettle();

        Text warningDialogTitle =
            tester.widget(find.byKey(const Key('warningDialogTitle')).last);

        expect(warningDialogTitle.data, 'CONFIRMATION');

        String actualMessage = tester
            .widget<Text>(find.byKey(const Key('warningDialogMessage')).last)
            .data!;
        expect(
            actualMessage,
            contains(
                "Saved to ZIP file(s) unique playlist audio MP3 files downloaded from $audioOldestDownloadDateToday 00:00.\n\nTotal saved audio number: 1, total size: 68 KB and total duration: 0:00:08.6."));
        expect(actualMessage, contains("Save operation real duration: 0:00:"));
        expect(actualMessage, contains("number of bytes saved per second: "));
        expect(actualMessage, contains(", number of created ZIP file(s): 1."));
        expect(
          actualMessage,
          anyOf([
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${youtubePlaylistTitle}_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now)}.zip\"."),
            contains(
                "ZIP file path name: \"$kApplicationPathWindowsTest${path.separator}${youtubePlaylistTitle}_mp3_from_${audioOldestDownloadDateTodayForFileNName}_00_00_00_on_${yearMonthDayDateTimeFormatForFileName.format(now.subtract(const Duration(seconds: 1)))}.zip\"."),
          ]),
        );

        String playlistMp3NewSavedZipFileName = _extractMp3ZipFileName(
          confirmationMessage: actualMessage,
          zipStartFileName: youtubePlaylistTitle,
        );

        // Tap the warning confirmation dialog Ok button to close it
        await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
        await tester.pumpAndSettle();

        // Now delete the "urgent_actus_17-12-2023" playlist (their
        // mp3 files are also deleted)

        await IntegrationTestUtil.typeOnPlaylistMenuItem(
            tester: tester,
            playlistTitle: youtubePlaylistTitle,
            playlistMenuKeyStr: 'popup_menu_delete_playlist');

        // Now find the confirm button of the delete playlist confirm
        // dialog and tap on it
        await tester.tap(find.byKey(const Key('confirmButton')));
        await tester.pumpAndSettle();

        // Restoring the initial "urgent_actus_17-12-2023" playlist and its mp3 files
        await _restorePaylistsAndTheirMp3(
          tester: tester,
          sourceRootPath: kApplicationPathWindowsTest,
          restorablePlaylistsZipFileName:
              renamedInitialUniquePlaylistZipFileName,
          restorableMp3ZipFileName:
              '${youtubePlaylistTitle}_mp3_from_2025-08-12_16_29_25_on_2025-09-28_21_50_57.zip',
          mockFilePicker: mockFilePicker,
        );

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 1.8 seconds

        // Find the audio list widget using its key
        Finder listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:01.8 14 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 1,
        );

        // Now restoring the last saved "urgent_actus_17-12-2023" playlist
        // and its mp3 files with replacing the existing playlist
        await _restorePaylistsAndTheirMp3(
            tester: tester,
            sourceRootPath: kApplicationPathWindowsTest,
            restorablePlaylistsZipFileName: '$youtubePlaylistTitle.zip',
            restorableMp3ZipFileName: playlistMp3NewSavedZipFileName,
            mockFilePicker: mockFilePicker,
            doReplaceExistingPlaylists: true,
            restorePlaylistsConfirmationMessage:
                'Restored 1 playlist saved individually, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 1 added plus 0 modified comment(s) in existing audio comment file(s) from "$kApplicationPathWindowsTest${path.separator}$youtubePlaylistTitle.zip".',
            restoreMp3ConfirmationMessage:
                "Restored 1 audio(s) MP3 in 1 playlist from the unique playlist MP3 zip file \"$kApplicationPathWindowsTest${path.separator}$playlistMp3NewSavedZipFileName\".",
            restoreMp3FromUniquePlaylistTitle: youtubePlaylistTitle);

        // Now verify that the restored converted audio 'aaa' has a
        // duration of 8.6 seconds

        // Find the audio list widget using its key
        listFinder = find.byKey(const Key('audio_list'));
        // Perform the scroll action
        await tester.drag(
            listFinder,
            const Offset(
                0, 300)); // Positive value for vertical drag to scroll up
        await tester.pumpAndSettle();

        // Verify the converted audio sub title in the selected Youtube
        // playlist audio list
        IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
          tester: tester,
          audioSubTitlesAcceptableLst: [
            '0:00:08.6 68 KB converted on 07/09/2025 at 07:37',
          ],
          firstAudioListTileIndex: 1,
        );

        // Now we want to tap on the 'aaa' audio in order to open the
        // AudioPlayerView displaying the audio. The purpose is to
        // verify that the duration of the audio is indeed 8.6 seconds
        // as indicated in the audio subtitle on the audio list displayed
        // on the plalist download view.

        // First, get the 'aaa' audio ListTile Text widget finder and
        // tap on it

        final Finder aaaAudioListTileTextWidgetFinder = find.text('aaa');

        await tester.tap(aaaAudioListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        String aaaAudioTitleText = (tester.widget<Text>(
                find.byKey(const Key('audioPlayerViewCurrentAudioTitle'))))
            .data!;

        String aaaAudioDurationStr = _extractDuration(aaaAudioTitleText);

        expect(aaaAudioDurationStr, '0:09');

        // Go back to the playlist download view
        final Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        await IntegrationTestUtil.verifyAudioInfoDialog(
          tester: tester,
          audioType: AudioType.textToSpeech,
          validVideoTitleOrAudioTitle: 'aaa',
          audioDownloadDateTime:
              "07/09/2025 07:37", // this is the imported date time
          copiedToPlaylistTitle: 'local',
          audioDuration: '0:00:08.6',
          audioFileSize: '68 KB',
          isMusicQuality: false, // Is spoken quality
          audioPlaySpeed: '1.25',
          audioVolume: '50.0 %',
          audioCommentNumber: 2,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
  });

  group(
      'Restore playlist, comments, pictures and settings from zip file menu test',
      () {
    group('Restore Windows zip files to Windows', () {
      group(
          'On not empty app dir where a playlist is selected, restore Windows zip.',
          () {
        group(
            'Restored selected playlist is identical to the before restoration selected playlist.',
            () {
          testWidgets(
              '''Replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'local'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which 'local' is selected.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn local selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            const String playlistRootDirName = 'playlists';

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu with the 'Replace existing playlists' option
            // selected.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
              verifySetValueToTargetDialog: true,
            );

            await tester.pumpAndSettle(const Duration(milliseconds: 500));

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 5 playlist, 5 comment and 6 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 9 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn local selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'A restaurer'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verify local playlist

            List<String> audioTitles = [
              "morning _ cinematic video",
              "Really short video",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            ];
            List<String> audioSubTitles = [
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18",
              "0:00:10.0 61 KB at 20 KB/sec on 10/01/2024 at 18:18",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Now verify 'S8 audio' playlist as well !

            audioTitles = [
              "Quand Aurélien Barrau va dans une école de management",
              "Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
              "La surpopulation mondiale par Jancovici et Barrau",
            ];

            audioSubTitles = [
              "0:17:59.0 6.58 MB at 1.80 MB/sec on 22/07/2024 at 08:11",
              "1:17:53.6 28.50 MB at 1.63 MB/sec on 28/05/2024 at 13:06",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
              "0:07:38.0 2.79 MB at 2.73 MB/sec on 07/01/2024 at 16:36",
            ];

            const String youtubePlaylistTitle = 'S8 audio';
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: youtubePlaylistTitle,
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: youtubePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: youtubePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "New file name.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'commented_7MB' sort/filter item
            Finder commentedMinus7MbDropDownTextFinder =
                find.text('commented_7MB').last;
            await tester.tap(commentedMinus7MbDropDownTextFinder);
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: youtubePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            // for (int i = 0; i < 5; i++) {
            //   await Future.delayed(const Duration(seconds: 2));
            //   await tester.pumpAndSettle();
            // }

            // Verifying and closing the confirm dialog

            // await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
            //   tester: tester,
            //   confirmDialogTitleOne:
            //       "Delete audio's filtered by \"\" parms from playlist \"\"",
            //   confirmDialogMessage:
            //       "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
            //   confirmOrCancelAction: true, // Confirm button is tapped
            // );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle =
                'Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...';
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$youtubePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after redownloading
            // filtered audio's by 'commented_7MB' SF parms as well
            // as redownloading single audio 'Interview de Chat GPT
            // - IA, intelligence, philosophie, géopolitique,
            // post-vérité...'.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'S8 audio',
              expectedAudioFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.mp3",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.mp3",
              ],
              expectedCommentFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "New file name.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Not replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'local'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which 'local' is selected.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn local selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            const String playlistRootDirName = 'playlists';

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu without replacing the existing playlists.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
              verifySetValueToTargetDialog: true,
            );

            await tester.pumpAndSettle(const Duration(milliseconds: 500));

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 4 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 6 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn local selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'A restaurer'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verify local playlist

            List<String> audioTitles = [
              "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
            ];

            List<String> audioSubTitles = [
              "0:24:21.8 8.92 MB at 1.62 MB/sec on 13/02/2025 at 08:30",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Now verify 'S8 audio' playlist as well !

            audioTitles = [
              "Quand Aurélien Barrau va dans une école de management",
              "Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
              "La surpopulation mondiale par Jancovici et Barrau",
            ];

            audioSubTitles = [
              "0:17:59.0 6.58 MB at 1.80 MB/sec on 22/07/2024 at 08:11",
              "1:17:53.6 28.50 MB at 1.63 MB/sec on 28/05/2024 at 13:06",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
              "0:07:38.0 2.79 MB at 2.73 MB/sec on 07/01/2024 at 16:36",
            ];

            const String youtubePlaylistTitle = 'S8 audio';
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: youtubePlaylistTitle,
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: youtubePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: youtubePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "New file name.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'commented_7MB' sort/filter item
            Finder commentedMinus7MbDropDownTextFinder =
                find.text('commented_7MB').last;
            await tester.tap(commentedMinus7MbDropDownTextFinder);
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: youtubePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            // for (int i = 0; i < 5; i++) {
            //   await Future.delayed(const Duration(seconds: 2));
            //   await tester.pumpAndSettle();
            // }

            // Verifying and closing the confirm dialog

            // await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
            //   tester: tester,
            //   confirmDialogTitleOne:
            //       "Delete audio's filtered by \"\" parms from playlist \"\"",
            //   confirmDialogMessage:
            //       "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
            //   confirmOrCancelAction: true, // Confirm button is tapped
            // );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle =
                'Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...';
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$youtubePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after redownloading
            // filtered audio's by 'commented_7MB' SF parms as well
            // as redownloading single audio 'Interview de Chat GPT
            // - IA, intelligence, philosophie, géopolitique,
            // post-vérité...'.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'S8 audio',
              expectedAudioFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.mp3",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.mp3",
              ],
              expectedCommentFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "New file name.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            'Restored selected playlist is different from the before restoration selected playlist.',
            () {
          testWidgets(
              '''Replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'S8 audio'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which 'local' is selected. After restoration, 'local' remains selected and 'S8 audio'
              is not selected anymore.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn S8 audio selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Verify that the before restoration selected playlist is 'local'.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'local',
              isSelected: true,
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu with the 'Replace existing playlists' option
            // selected.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await tester.pumpAndSettle(const Duration(seconds: 1));

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 5 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 9 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn S8 audio selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify that the after restoration selected playlist is still
            // 'local'.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'local',
              isSelected: true,
            );

            // Verify that the after restoration selected playlist is not
            // 'S8 audio'. The 'S8 audio' playlist was selected in the
            // restoration zip file.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'S8 audio',
              isSelected: false,
            );

            List<String> playlistsTitles = [
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'local'
            // displayed audio titles and subtitles.

            // Verify local playlist

            List<String> audioTitles = [
              "morning _ cinematic video",
              "Really short video",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            ];
            List<String> audioSubTitles = [
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18",
              "0:00:10.0 61 KB at 20 KB/sec on 10/01/2024 at 18:18",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Not replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'S8 audio'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which 'local' is selected. After restoration, 'local' remains selected and 'S8 audio'
              is not selected anymore.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn S8 audio selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Verify that the before restoration selected playlist is 'local'.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'local',
              isSelected: true,
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu without replacing the existing playlists.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 4 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 6 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn S8 audio selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify that the after restoration selected playlist is still
            // 'local'.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'local',
              isSelected: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
      });
      group(
          'On not empty app dir where no playlist is selected, restore Windows zip.',
          () {
        group(
            'Restored selected playlist is identical to the before restoration not selected playlist.',
            () {
          testWidgets(
              '''Replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'local'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which the 'local' playlist was unselected. After restoration, since 'local' was
              selected in the zip file, it will be reselected.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn local selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            const String playlistRootDirName = 'playlists';

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Deselect the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu with the 'Replace existing playlists' option
            // selected.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            // Verify that the audio menu button is enabled
            IntegrationTestUtil.verifyWidgetIsEnabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 5 playlist, 5 comment and 6 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 9 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn local selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'A restaurer'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verify local playlist

            List<String> audioTitles = [
              "morning _ cinematic video",
              "Really short video",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            ];
            List<String> audioSubTitles = [
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18",
              "0:00:10.0 61 KB at 20 KB/sec on 10/01/2024 at 18:18",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify 'A restaurer' playlist

            audioTitles = [
              "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
              "L'histoire secrète derrière la progression de l'IA",
              "Le 21 juillet 1913 _ Prières et méditations, La Mère",
              "Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...)",
            ];

            audioSubTitles = [
              "0:24:21.7 9.84 MB at 510 KB/sec on 24/02/2025 at 13:27",
              "0:22:57.8 8.72 MB at 203 KB/sec on 24/02/2025 at 13:16",
              "0:00:58.7 359 KB at 89 KB/sec on 13/02/2025 at 10:43",
              "0:22:57.8 8.72 MB at 2.14 MB/sec on 13/02/2025 at 08:30",
            ];

            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'A restaurer',
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'A restaurer',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Now verify 'S8 audio' playlist as well !

            audioTitles = [
              "Quand Aurélien Barrau va dans une école de management",
              "Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
              "La surpopulation mondiale par Jancovici et Barrau",
            ];

            audioSubTitles = [
              "0:17:59.0 6.58 MB at 1.80 MB/sec on 22/07/2024 at 08:11",
              "1:17:53.6 28.50 MB at 1.63 MB/sec on 28/05/2024 at 13:06",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
              "0:07:38.0 2.79 MB at 2.73 MB/sec on 07/01/2024 at 16:36",
            ];

            const String youtubePlaylistTitle = 'S8 audio';
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: youtubePlaylistTitle,
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: youtubePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: youtubePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "New file name.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'commented_7MB' sort/filter item
            Finder commentedMinus7MbDropDownTextFinder =
                find.text('commented_7MB').last;
            await tester.tap(commentedMinus7MbDropDownTextFinder);
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: youtubePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            // for (int i = 0; i < 5; i++) {
            //   await Future.delayed(const Duration(seconds: 2));
            //   await tester.pumpAndSettle();
            // }

            // Verifying and closing the confirm dialog

            // await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
            //   tester: tester,
            //   confirmDialogTitleOne:
            //       "Delete audio's filtered by \"\" parms from playlist \"\"",
            //   confirmDialogMessage:
            //       "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
            //   confirmOrCancelAction: true, // Confirm button is tapped
            // );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle =
                'Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...';
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$youtubePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after redownloading
            // filtered audio's by 'commented_7MB' SF parms as well
            // as redownloading single audio 'Interview de Chat GPT
            // - IA, intelligence, philosophie, géopolitique,
            // post-vérité...'.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'S8 audio',
              expectedAudioFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.mp3",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.mp3",
              ],
              expectedCommentFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "New file name.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Not replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'local'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which the 'local' playlist was unselected. After restoration, although 'local'
              was selected in the zip file, since the existing playlists are not replaced, no
              playlist will be selected.

              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn local selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            const String playlistRootDirName = 'playlists';

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir before restoring.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Deselect the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu without replacing the existing playlists.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify that the audio menu button is disabled since the local
            // playlist selected in the zip file has not replaced the existing
            // local playlist and so no playlist is selected.
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 4 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 6 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn local selected.zip".\n\nSince the playlists were created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'A restaurer'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "A restaurer",
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verify local playlist

            List<String> audioTitles = [
              "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
            ];

            List<String> audioSubTitles = [
              "0:24:21.8 8.92 MB at 1.62 MB/sec on 13/02/2025 at 08:30",
            ];

            // Verify that no playlist is selected
            await IntegrationTestUtil.verifyNoPlaylistSelected();

            // Select the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify 'A restaurer' playlist

            audioTitles = [
              "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
              "L'histoire secrète derrière la progression de l'IA",
              "Le 21 juillet 1913 _ Prières et méditations, La Mère",
              "Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...)",
            ];

            audioSubTitles = [
              "0:24:21.7 9.84 MB at 510 KB/sec on 24/02/2025 at 13:27",
              "0:22:57.8 8.72 MB at 203 KB/sec on 24/02/2025 at 13:16",
              "0:00:58.7 359 KB at 89 KB/sec on 13/02/2025 at 10:43",
              "0:22:57.8 8.72 MB at 2.14 MB/sec on 13/02/2025 at 08:30",
            ];

            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'A restaurer',
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'A restaurer',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Now verify 'S8 audio' playlist as well !

            audioTitles = [
              "Quand Aurélien Barrau va dans une école de management",
              "Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
              "La surpopulation mondiale par Jancovici et Barrau",
            ];

            audioSubTitles = [
              "0:17:59.0 6.58 MB at 1.80 MB/sec on 22/07/2024 at 08:11",
              "1:17:53.6 28.50 MB at 1.63 MB/sec on 28/05/2024 at 13:06",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
              "0:07:38.0 2.79 MB at 2.73 MB/sec on 07/01/2024 at 16:36",
            ];

            const String youtubePlaylistTitle = 'S8 audio';
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: youtubePlaylistTitle,
            );

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: youtubePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'A restaurer' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'A restaurer',
              expectedAudioFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.mp3",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.mp3",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.mp3",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3",
              ],
              expectedCommentFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              expectedPictureFiles: [
                "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
                "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
                "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'local' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'local',
              expectedAudioFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.mp3"
              ],
              expectedCommentFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              expectedPictureFiles: [
                "250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json"
              ],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Jésus je T'adore.jpg",
              audioForPictureTitleOneLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: youtubePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "New file name.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
              pictureFileNameOne: "Sam Altman.jpg",
              audioForPictureTitleOneLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
              ],
              pictureFileNameTwo: "Jésus mon Amour.jpg",
              audioForPictureTitleTwoLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
              pictureFileNameThree: "Jésus je T'adore.jpg",
              audioForPictureTitleThreeLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'commented_7MB' sort/filter item
            Finder commentedMinus7MbDropDownTextFinder =
                find.text('commented_7MB').last;
            await tester.tap(commentedMinus7MbDropDownTextFinder);
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: youtubePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            // for (int i = 0; i < 5; i++) {
            //   await Future.delayed(const Duration(seconds: 2));
            //   await tester.pumpAndSettle();
            // }

            // Verifying and closing the confirm dialog

            // await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
            //   tester: tester,
            //   confirmDialogTitleOne:
            //       "Delete audio's filtered by \"\" parms from playlist \"\"",
            //   confirmDialogMessage:
            //       "Audio's to delete number: 2,\nCorresponding total file size: 7.37 MB,\nCorresponding total duration: 00:20:08.",
            //   confirmOrCancelAction: true, // Confirm button is tapped
            // );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle =
                'Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité...';
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$youtubePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'S8 audio' playlist dir
            // and comments and pictures dir after redownloading
            // filtered audio's by 'commented_7MB' SF parms as well
            // as redownloading single audio 'Interview de Chat GPT
            // - IA, intelligence, philosophie, géopolitique,
            // post-vérité...'.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'S8 audio',
              expectedAudioFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.mp3",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.mp3",
              ],
              expectedCommentFiles: [
                "240528-130636-Interview de Chat GPT  - IA, intelligence, philosophie, géopolitique, post-vérité... 24-01-12.json",
                "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.json",
                "240722-081104-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
                "New file name.json",
              ],
              expectedPictureFiles: [],
              playlistRootDir: playlistRootDirName,
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            'Restored selected playlist is different from the before restoration selected playlist.',
            () {
          testWidgets(
              '''Replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'S8 audio'
              is selected to Windows application containing 'A restaurer' and 'local' playlists in
              which 'local' was unselected. After restoration, 'S8 audio' will be selected since it
              was selected in the zip file.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn S8 audio selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Deselect the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu with the 'Replace existing playlists' option
            // selected.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await tester.pumpAndSettle(const Duration(milliseconds: 500));

            // Verify that the audio menu button is enabled
            IntegrationTestUtil.verifyWidgetIsEnabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 5 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 9 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn S8 audio selected.zip".\n\nDeleted 1 playlist(s)\n  "A restaurer"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  "Empty",\n  "local",\n  "local_comment",\n  "local_delete_comment",\n  "S8 audio"\nwere created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify that the after restoration selected playlist is now
            // 'S8 audio'.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'S8 audio',
              isSelected: true,
            );

            List<String> playlistsTitles = [
              "A restaurer",
              "local",
              "Empty",
              "local_comment",
              "local_delete_comment",
              "S8 audio",
            ];

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'local'
            // displayed audio titles and subtitles.

            // Verify the 'local' playlist after selecting it

            // Select the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            List<String> audioTitles = [
              "morning _ cinematic video",
              "Really short video",
              "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
            ];
            List<String> audioSubTitles = [
              "0:00:59.0 360 KB at 283 KB/sec on 10/01/2024 at 18:18",
              "0:00:10.0 61 KB at 20 KB/sec on 10/01/2024 at 18:18",
              "0:06:29.0 2.37 MB at 1.69 MB/sec on 08/01/2024 at 16:35",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'local',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Not replace existing playlists. Restore Windows zip containing 'Empty', 'local',
              'local_comment', 'local_delete_comment' and 'S8 audio' playlists in which 'S8 audio'
              is selected to Windows application containing 'A restaurer' and 'local' playlists
              in which 'local' was unselected. After restoration, 'S8 audio' will be selected since
              it was selected in the zip file.
              
              Then, select a SF parm and redownload the filtered audio's. Finally, redownload an
              individual not playable audio.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            const String restorableZipFileName =
                'Windows audioLearn S8 audio selected.zip';

            // Copy the integration test data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_zip_existing_playlist_selected_test",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFileName,
                  path:
                      '$kApplicationPathWindowsTest${path.separator}$restorableZipFileName',
                  size: 12828),
            ]);

            // Deselect the 'local' playlist
            await IntegrationTestUtil.selectPlaylist(
              tester: tester,
              playlistToSelectTitle: 'local',
            );

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu without replacing the existing playlists.
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify that the audio menu button is enabled
            IntegrationTestUtil.verifyWidgetIsEnabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 4 playlist, 5 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 6 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows audioLearn S8 audio selected.zip".\n\nSince the playlists were created, they are positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify that the after restoration selected playlist is
            // 'S8 audio'. The 'S8 audio' playlist was selected in the
            // restoration zip file.
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: 'S8 audio',
              isSelected: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
      });
      group(
          '''On not empty app dir where a playlist is selected, restore Windows zip in which playlist(s)
          corresponding to existing playlist(s) contain additional audio's to which comments and pictures
          are associated. This situation happens if the AudioLearn application exists on two different
          engines and the user wants to restore the playlists, comments and pictures from one computer
          to another in order to add to the target pc or smartphone the audio's downloaded on the source
          engine. The audio mp3 files are not added since they are not in the zip file. But the Audio
          objects are added to the existing playlist and so can be redownloaded if needed.''',
          () {
        testWidgets(
            '''Unique playlist restore, not replace existing playlist. Restore unique playlist Windows zip
            containing 'S8 audio' playlist to Windows application which contains 'S8 audio' and 'local'
            playlists. The restored 'S8 audio' playlist contains additional audio's to which comments and
            pictures are associated.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Windows S8 audio.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 163840),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist saved individually, 2 comment and 2 picture JSON files as well as 2 picture JPG file(s) in the application pictures directory and 2 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows S8 audio.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing restored playlist
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "S8 audio",
            "local",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
            "Quand Aurélien Barrau va dans une école de management",
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB imported on 23/06/2025 at 06:56',
            "0:17:59.0 6.58 MB at 1.37 MB/sec on 23/06/2025 at 06:55",
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/07/2024 at 16:35",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'S8 audio',
            expectedAudioFiles: [
              "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
              "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
            ],
            expectedCommentFiles: [
              "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
              "250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json",
            ],
            expectedPictureFiles: [
              "250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Barrau.jpg',
            audioForPictureTitleOneLst: [
              "S8 audio|250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10"
            ],
            pictureFileNameTwo: 'Jésus, mon amour.jpg',
            audioForPictureTitleTwoLst: [
              "S8 audio|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore, not replace existing playlists. Restore multiple playlists Windows
             zip containing 'S8 audio' and 'local' playlists to Windows application which contain 'S8 audio'
             and 'local' playlists. The restored 'S8 audio' and 'local' playlists contains additional audio's
             to which comments and pictures are associated.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Windows 2 existing playlists with new audios.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 9387),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist, 3 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows 2 existing playlists with new audios.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing restored playlist
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "S8 audio",
            "local",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
            "Quand Aurélien Barrau va dans une école de management",
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB imported on 23/06/2025 at 06:56',
            "0:17:59.0 6.58 MB at 1.37 MB/sec on 23/06/2025 at 06:55",
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/07/2024 at 16:35",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'local',
            expectedAudioFiles: [
              "240110-181805-Really short video 23-07-01.mp3",
              "240110-181810-morning _ cinematic video 23-07-01.mp3",
            ],
            expectedCommentFiles: [
              "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
            ],
            expectedPictureFiles: [
              "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Barrau.jpg',
            audioForPictureTitleOneLst: [
              "S8 audio|250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10"
            ],
            pictureFileNameTwo: 'Jésus, mon amour.jpg',
            audioForPictureTitleTwoLst: [
              "S8 audio|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
            pictureFileNameThree: "Dieu je T'adore.jpg",
            audioForPictureTitleThreeLst: [
              "local|Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
      });
      group('On empty app dir, restore Windows zip.', () {
        testWidgets(
            '''Unique playlist restore, not replace existing playlist. Restore unique playlist Windows zip
            containing 'Prières du Maître' playlist to empty Windows application''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Prières du Maître.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: true,
            verifySetValueToTargetDialog: true,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Prières du Maître.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing and the restored playlists
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "Prières du Maître",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB at 502 KB/sec on 11/02/2025 at 09:00',
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'Prières du Maître',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'Prières du Maître' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'Prières du Maître',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            expectedPictureFiles: [
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Jésus le Dieu vivant.jpg',
            audioForPictureTitleOneLst: [
              "Prières du Maître|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Unique playlist restore, replace existing playlist. Restore unique playlist Windows zip
            containing 'Prières du Maître' playlist to empty Windows application''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Prières du Maître.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: true,
            verifySetValueToTargetDialog: true,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Prières du Maître.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing and the restored playlists
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "Prières du Maître",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB at 502 KB/sec on 11/02/2025 at 09:00',
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'Prières du Maître',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'Prières du Maître' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'Prières du Maître',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            expectedPictureFiles: [
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Jésus le Dieu vivant.jpg',
            audioForPictureTitleOneLst: [
              "Prières du Maître|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore, not replace existing playlist. Restore multiple playlists Windows
            zip containing 'local' and 'S8 audio' playlists to empty Windows application.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows sort_and_filter_audio_dialog_widget_test_playlists.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows sort_and_filter_audio_dialog_widget_test_playlists.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing and the restored playlists
          // list as well as the selected playlist 'S8 audio'
          // displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "local",
            "S8 audio",
          ];

          List<String> audioTitles = [
            'Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik',
            "Les besoins artificiels par R.Keucheyan",
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          ];

          List<String> audioSubTitles = [
            '0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16',
            "0:19:05.0 6.98 MB at 2.28 MB/sec on 07/01/2024 at 08:16",
            "0:20:32.0 7.51 MB at 2.44 MB/sec on 26/12/2023 at 09:45",
            "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'S8 audio',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json"
            ],
            expectedPictureFiles: [
              "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'wallpaper.jpg',
            audioForPictureTitleOneLst: [
              'S8 audio|231226-094534-3 fois où un économiste m\'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01',
            ],
            pictureFileNameTwo:
                'Liguria_Italy_Coast_Houses_Riomaggiore_Crag_513222_3840x2400.jpg',
            audioForPictureTitleTwoLst: [
              'S8 audio|231226-094534-3 fois où un économiste m\'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01',
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore, replace existing playlist. Restore multiple playlists Windows
            zip containing 'local' and 'S8 audio' playlists to empty Windows application.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows sort_and_filter_audio_dialog_widget_test_playlists.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: true,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows sort_and_filter_audio_dialog_widget_test_playlists.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing and the restored playlists
          // list as well as the selected playlist 'S8 audio'
          // displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "local",
            "S8 audio",
          ];

          List<String> audioTitles = [
            'Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik',
            "Les besoins artificiels par R.Keucheyan",
            "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
            "Ce qui va vraiment sauver notre espèce par Jancovici et Barrau",
          ];

          List<String> audioSubTitles = [
            '0:13:39.0 4.99 MB at 2.55 MB/sec on 07/01/2024 at 08:16',
            "0:19:05.0 6.98 MB at 2.28 MB/sec on 07/01/2024 at 08:16",
            "0:20:32.0 7.51 MB at 2.44 MB/sec on 26/12/2023 at 09:45",
            "0:06:29.0 2.37 MB at 1.36 MB/sec on 26/12/2023 at 09:45",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'S8 audio',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json"
            ],
            expectedPictureFiles: [
              "231226-094534-3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'wallpaper.jpg',
            audioForPictureTitleOneLst: [
              'S8 audio|231226-094534-3 fois où un économiste m\'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01',
            ],
            pictureFileNameTwo:
                'Liguria_Italy_Coast_Houses_Riomaggiore_Crag_513222_3840x2400.jpg',
            audioForPictureTitleTwoLst: [
              'S8 audio|231226-094534-3 fois où un économiste m\'a ouvert les yeux (Giraud, Lefournier, Porcher) 23-12-01',
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Not replace existing playlist. After first restoration on the empty
            application of a Windows ZIP file containing 'Prières du Maître' playlist
            in which 'Prières du Maître' is selected, restore a Windows zip containing
            'local' and 'A restaurer' playlists in which 'A restaurer' is selected.
            The result will be that the first restored selected playlist 'Prières du Maître'
            will remain being selected.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          const String firstRestorableZipFileName =
              'Windows Prières du Maître.zip';
          final String zipTestDirectory =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}';
          final String firstRestorableZipFilePathName =
              '$zipTestDirectory${path.separator}$firstRestorableZipFileName';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: firstRestorableZipFileName,
                path: firstRestorableZipFilePathName,
                size: 7460),
          ]);

          // Execute the first 'Restore Playlists, Comments and Settings
          // in the empty application from Zip File ...' menu without
          // replacing the existing playlists.
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\\\Windows Prières du Maître.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify that after the first restoration the selected
          // playlist is 'Prières du Maître'.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'Prières du Maître',
            isSelected: true,
          );

          const String secondRestorableZipFileName =
              'Windows audioLearn_2025-05-11_13_16.zip';
          final String secondRestorableZipFilePathName =
              '$zipTestDirectory$secondRestorableZipFileName';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: secondRestorableZipFileName,
                path: secondRestorableZipFilePathName,
                size: 12288),
          ]);

          // Execute the second 'Restore Playlists, Comments and Settings
          // from Zip File ...' menu without replacing the existing playlists.
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 5 comment and 4 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 5 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows audioLearn_2025-05-11_13_16.zip".\n\nSince the playlists were created, they are positioned at the end of the playlist list.',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify that after the second restoration the selected
          // playlist is still 'Prières du Maître'.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'Prières du Maître',
            isSelected: true,
          );

          // Verify that the after the second restoration the selected
          // is not 'A restaurer'. The 'A restaurer' playlist was selected
          // in the restoration zip file.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'A restaurer',
            isSelected: false,
          );

          // Verifying the restored playlists list as well as their
          // displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "Prières du Maître",
            "A restaurer",
            "local",
          ];

          // Verify 'Prières du Maître' playlist

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
          ];

          List<String> audioSubTitles = [
            "0:02:39.6 2.59 MB at 502 KB/sec on 11/02/2025 at 09:00",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'Prières du Maître',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Now verify 'local' playlist

          // Select the 'local' playlist which was restored.
          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: 'local',
          );

          audioTitles = [
            "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
          ];

          audioSubTitles = [
            "0:24:21.8 8.92 MB at 1.62 MB/sec on 13/02/2025 at 08:30",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'local',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          const String playlistRootDirName = 'playlists';

          // And verify the 'A restaurer' playlist

          // Select the 'A restaurer' playlist
          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: 'A restaurer',
          );

          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'A restaurer',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
              "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
              "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
              "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
            ],
            expectedPictureFiles: [
              "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
              "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
              "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
            ],
            playlistRootDir: playlistRootDirName,
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
            pictureFileNameOne: 'Jésus le Dieu vivant.jpg',
            audioForPictureTitleOneLst: [
              "Prières du Maître|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
              "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
            ],
            pictureFileNameTwo: "Sam Altman.jpg",
            audioForPictureTitleTwoLst: [
              "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
              "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
            ],
            pictureFileNameThree: "Jésus mon Amour.jpg",
            audioForPictureTitleThreeLst: [
              "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
            ],
            pictureFileNameFour: "Jésus je T'adore.jpg",
            audioForPictureTitleFourLst: [
              "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Replace existing playlist. After first restoration on the empty
            application of a Windows ZIP file containing 'Prières du Maître' playlist
            in which 'Prières du Maître' is selected, restore a Windows zip containing
            'local' and 'A restaurer' playlists in which 'A restaurer' is selected.
            The result will be that the first restored selected playlist 'Prières du Maître'
            will remain being selected.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          const String firstRestorableZipFileName =
              'Windows Prières du Maître.zip';
          final String zipTestDirectory =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}';
          final String firstRestorableZipFilePathName =
              '$zipTestDirectory${path.separator}$firstRestorableZipFileName';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: firstRestorableZipFileName,
                path: firstRestorableZipFilePathName,
                size: 7460),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu without replacing the existing playlists.
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\\\Windows Prières du Maître.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify that after the first restoration the selected
          // playlist is 'Prières du Maître'.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'Prières du Maître',
            isSelected: true,
          );

          const String secondRestorableZipFileName =
              'Windows audioLearn_2025-05-11_13_16.zip';
          final String secondRestorableZipFilePathName =
              '$zipTestDirectory$secondRestorableZipFileName';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: secondRestorableZipFileName,
                path: secondRestorableZipFilePathName,
                size: 12288),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu withoreplacing the existing playlists.
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: true,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 5 comment and 4 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 5 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows audioLearn_2025-05-11_13_16.zip".\n\nSince the playlists were created, they are positioned at the end of the playlist list.',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify that after the second restoration the selected
          // playlist is still 'Prières du Maître'.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'Prières du Maître',
            isSelected: true,
          );

          // Verify that the after the second restoration the selected
          // is not 'A restaurer'. The 'A restaurer' playlist was selected
          // in the restoration zip file.
          IntegrationTestUtil.verifyPlaylistSelection(
            tester: tester,
            playlistTitle: 'A restaurer',
            isSelected: false,
          );

          // Verifying the restored playlists list as well as their
          // displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "Prières du Maître",
            "A restaurer",
            "local",
          ];

          // Verify 'Prières du Maître' playlist

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
          ];

          List<String> audioSubTitles = [
            "0:02:39.6 2.59 MB at 502 KB/sec on 11/02/2025 at 09:00",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'Prières du Maître',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Now verify 'local' playlist

          // Select the 'local' playlist which was restored.
          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: 'local',
          );

          audioTitles = [
            "Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage!",
          ];

          audioSubTitles = [
            "0:24:21.8 8.92 MB at 1.62 MB/sec on 13/02/2025 at 08:30",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'local',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          const String playlistRootDirName = 'playlists';

          // And verify the 'A restaurer' playlist

          // Select the 'A restaurer' playlist
          await IntegrationTestUtil.selectPlaylist(
            tester: tester,
            playlistToSelectTitle: 'A restaurer',
          );

          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'A restaurer',
            expectedAudioFiles: [],
            expectedCommentFiles: [
              "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
              "250213-104308-Le 21 juillet 1913 _ Prières et méditations, La Mère 25-02-13.json",
              "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
              "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
            ],
            expectedPictureFiles: [
              "250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12.json",
              "250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12.json",
              "250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09.json",
            ],
            playlistRootDir: playlistRootDirName,
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
            pictureFileNameOne: 'Jésus le Dieu vivant.jpg',
            audioForPictureTitleOneLst: [
              "Prières du Maître|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
              "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
            ],
            pictureFileNameTwo: "Sam Altman.jpg",
            audioForPictureTitleTwoLst: [
              "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
              "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12"
            ],
            pictureFileNameThree: "Jésus mon Amour.jpg",
            audioForPictureTitleThreeLst: [
              "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
            ],
            pictureFileNameFour: "Jésus je T'adore.jpg",
            audioForPictureTitleFourLst: [
              "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore from ZIP containing pictures, not replace existing playlists. Restore
               multiple playlists Windows zip containing 'local' and 'S8 audio' playlists to empty Windows
               application.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows restore_multiple_playlists_and_pictures.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 4 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore from ZIP containing pictures, not replace existing playlists. Restore
               multiple playlists Windows zip containing 'local' and 'S8 audio' playlists to empty Windows
               application. Then restore again the same ZIP after deleting 1 picture''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows restore_multiple_playlists_and_pictures.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 4 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          DirUtil.deleteFileIfExist(
            pathFileName:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}20130208_080157.jpg',
          );

          // Re-execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist, 0 comment and 0 picture JSON files as well as 1 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        group('Redownload Youtube unique playlist from internet.', () {
          testWidgets(
              '''Restore not replace unique playlist. Not replacing existing playlist. Restore
            unique playlist Windows zip containing 'Restore- short - test - playlist' playlist with
            3 short audio's to empty Windows application. Then redownload the restored audio in
            2 ways: redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace unique playlist. Replacing existing playlist. Restore unique
            playlist Windows zip containing 'Restore- short - test - playlist' playlist with 3
            short audio's to empty Windows application. Then redownload the restored audio in
            2 ways: redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group('Redownload local unique playlist from internet.', () {
          testWidgets(
              '''Restore not replace unique playlist. Not replacing existing playlist. Restore unique
            playlist Windows zip containing 'Local restore- short - test - playlist' playlist with 3 short
            audio's to empty Windows application. Then redownload the restored audio in 2 ways:
            redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Local restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Local restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Local restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Local restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Local restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Local restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Local restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace unique playlist. Replacing existing playlist. Restore unique
            playlist Windows zip containing 'Local restore- short - test - playlist' playlist with 3
            short audio's to empty Windows application. Then redownload the restored audio in
            2 ways: redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Local restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Local restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Local restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Local restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Local restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Local restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Local restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            '''Restore 2 selected unique playlists. Each playlist contained in its zip file is
            selected.''', () {
          testWidgets(
              '''Restore not replace 2 selected unique playlists. First restore the Youtube 'Restore-
            short - test - playlist'. Then restore the local 'Local restore- short - test - playlist'.
            Verify the correct playlist selection. Finally, execute the 'Update Playlist JSON Files'
            appbar menu and verify that the playlist selection remains correct.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            DirUtil.deleteFileIfExist(
              pathFileName:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}Jean-Pierre.jpg',
            );
            DirUtil.deleteFileIfExist(
              pathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 2 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace 2 selected unique playlists. First restore the Youtube 'Restore-
            short - test - playlist'. Then restore the local 'Local restore- short - test - playlist'.
            Verify the correct playlist selection. Finally, execute the 'Update Playlist JSON Files'
            appbar menu and verify that the playlist selection remains correct.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Windows Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            DirUtil.deleteFileIfExist(
              pathFileName:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}Jean-Pierre.jpg',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 1 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Windows Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            '''On empty app dir, first restore Windows zip in containing a unique or multiple playlist(s).
          Then restore unique or multiple playlist(s) corresponding to the previously restored playlist(s)
          which contain a comment for a not yet commented existing audio as well as a new comment for a
          already commented existing audio as well as an updated comment for an existing audio which
          already has this comment.''', () {
          testWidgets(
              '''Unique playlist restore, not replace existing playlist. Restore unique playlist Windows zip
            containing 'Prières du Maître' playlist. Then restore to Windows application unique playlist
            Windows zip containing the corresponding playlist with new and modified comments. The two
            modified comments will update or not the existing comment according to their modification date.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            // Copy the test initial audio data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_2_existing_playlists_with_new_and_modified_comments",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            await app.main();
            await tester.pumpAndSettle();

            // Install the initial version of the unique saved
            // playlist 'Prières du Maître'

            String restorableZipFilePathName =
                '$kApplicationPathWindowsTest${path.separator}Windows Prières initialization.zip';

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 2874035),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings
            // from Zip File ...' menu to install the initial version
            // of the unique saved playlist 'Prières du Maître'
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 3 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows Prières initialization.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify the restored playlist audio comments

            // First, open the playlist comment dialog
            Finder playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'Prières du Maître',
            );

            Finder playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              6,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                  "Les paroles très inspirantes",
                  "25/06/25",
                  "16/07/25",
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "La prière du Maître",
                  "20/06/25",
                  "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                  "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                  "12/08/24",
                  "02/12/24",
                  "Je pleure, je pleure, je pleure de joie !\n\n\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
                ]);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // Restore the modified version of the unique saved
            // playlist 'Prières du Maître' which contains new
            // and modified comments

            restorableZipFilePathName =
                '$kApplicationPathWindowsTest${path.separator}Windows Prières comment restoration.zip';

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 2874418),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings
            // from Zip File ...' menu to install the modified version
            // of the unique saved playlist 'Prières du Maître'
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 0 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 1 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows Prières comment restoration.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify the restored playlist audio comments

            // First, open the playlist comment dialog
            playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'Prières du Maître',
            );

            playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              8,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                  "Les paroles très inspirantes",
                  "25/06/25",
                  "16/07/25",
                  "Seigneur, je T'en prie, mets-moi dans le feu de Ton Amour !",
                  "Full comment",
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "La prière du Maître",
                  "20/06/25",
                  "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                  "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                  "12/08/24",
                  "\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
                ]);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Multiple playlists restore, not replace existing playlists. Restore multiple playlists Windows
              zip containing 'Prières du Maître' and 'local' playlists. Then restore to Windows application
              the multiple playlists Windows zip containing the corresponding playlists with new and modified
              comments. The two modified comments will update or not the existing comment according to their
              modification date.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            // Copy the test initial audio data to the app dir
            DirUtil.copyFilesFromDirAndSubDirsToDirectory(
              sourceRootPath:
                  "$kDownloadAppTestSavedDataDir${path.separator}restore_2_existing_playlists_with_new_and_modified_comments",
              destinationRootPath: kApplicationPathWindowsTest,
            );

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            await app.main();
            await tester.pumpAndSettle();

            // Install the initial version of the unique saved
            // playlist 'Prières du Maître'

            String restorableZipFilePathName =
                '$kApplicationPathWindowsTest${path.separator}Windows Prières and local initialization.zip';

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 7898000),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings
            // from Zip File ...' menu to install the initial version
            // of the unique saved playlist 'Prières du Maître'
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 2 playlist, 5 comment and 4 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 8 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows Prières and local initialization.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify the restored playlist audio comments

            // First, open the 'Prières du Maître' playlist comment dialog
            Finder playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'Prières du Maître',
            );

            Finder playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              6,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                  "Les paroles ...",
                  "25/06/25",
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "La prière du Maître",
                  "20/06/25",
                  "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                  "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                  "12/08/24",
                  "02/12/24",
                  "Je pleure, je pleure, je pleure de joie !\n\n\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
                ]);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // First, open the 'local' playlist comment dialog
            playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'local',
            );

            playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              5,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "All",
                  "23/06/25",
                  "Marie-France",
                  "One",
                  "Two",
                ]);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // Restore the modified version of the unique saved
            // playlist 'Prières du Maître' which contains new
            // and modified comments

            restorableZipFilePathName =
                '$kApplicationPathWindowsTest${path.separator}Windows Prières and local comment restoration.zip';

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 2874418),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings
            // from Zip File ...' menu to install the modified version
            // of the unique saved playlist 'Prières du Maître'
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 0 playlist, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 1 added plus 4 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Windows Prières and local comment restoration.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verify the restored playlist audio comments

            // First, open the playlist comment dialog
            playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'Prières du Maître',
            );

            playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              8,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                  "Les paroles inspirantes",
                  "25/06/25",
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "La prière du Maître",
                  "20/06/25",
                  "Seigneur, je T'en prie, mets-moi dans le feu de Ton Amour !",
                  "Full comment",
                  "29/06/25",
                  "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                  "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                  "12/08/24",
                  "\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
                ],
                multipleString: "29/06/25",
                multipleCount: 3);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // First, open the 'local' playlist comment dialog
            playlistCommentListDialogFinder =
                await IntegrationTestUtil.openPlaylistCommentDialog(
              tester: tester,
              playlistTitle: 'local',
            );

            playlistCommentListFinder =
                find.byKey(const Key('playlistCommentsListKey'));

            // Ensure the list has 6 child widgets
            expect(
              tester
                  .widget<ListBody>(playlistCommentListFinder)
                  .children
                  .length,
              6,
            );

            IntegrationTestUtil.checkPlaylistCommentListDialogContent(
                playlistCommentListDialogFinder:
                    playlistCommentListDialogFinder,
                expectedCommentTextsLst: [
                  "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                  "Prière",
                  "23/06/25",
                  "Marie-France",
                  "One",
                  "Two",
                  "Before restore",
                  "Three",
                  "0:28",
                  "0:33",
                ]);

            // Now close the comment list dialog
            await tester.tap(find
                .byKey(const Key('playlistCommentListCloseDialogTextButton')));
            await tester.pumpAndSettle();

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
      });
    });
    group('Restore Android zip files to Windows', () {
      group('On empty app dir, restore Android zip.', () {
        group(
            '''Restore 2 selected unique playlists. Each playlist contained in its zip file is
            selected.''', () {
          testWidgets(
              '''Restore not replace 2 selected unique playlists. First restore the Youtube 'Restore-
            short - test - playlist'. Then restore the local 'Local restore- short - test - playlist'.
            Verify the correct playlist selection. Finally, execute the 'Update Playlist JSON Files'
            appbar menu and verify that the playlist selection remains correct.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify that the audio menu button is enabled
            IntegrationTestUtil.verifyWidgetIsEnabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
              verifySetValueToTargetDialog: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace 2 selected unique playlists. First restore the Youtube 'Restore-
            short - test - playlist'. Then restore the local 'Local restore- short - test - playlist'.
            Verify the correct playlist selection. Finally, execute the 'Update Playlist JSON Files'
            appbar menu and verify that the playlist selection remains correct.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Verify that the audio menu button is disabled
            IntegrationTestUtil.verifyWidgetIsDisabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            // Verify that the audio menu button is enabled
            IntegrationTestUtil.verifyWidgetIsEnabled(
              tester: tester,
              widgetKeyStr: 'audio_popup_menu_button',
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
              verifySetValueToTargetDialog: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group('Redownload Youtube unique playlist from internet.', () {
          testWidgets(
              '''Restore not replace unique playlist. Not replacing existing playlist. Restore
            unique playlist Android zip containing 'Restore- short - test - playlist' playlist with
            3 short audio's to empty Windows application. Then redownload the restored audio in
            2 ways: redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace unique playlist. Replacing existing playlist. Restore unique
            playlist Android zip containing 'Restore- short - test - playlist' playlist with 3
            short audio's to empty Windows application. Then redownload the restored audio in
            2 ways: redownload sort/filtered audio and redownload single audio.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: audioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
              verifySetValueToTargetDialog: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the restored playlist.

            const String uniquePlaylistTitle =
                'Restore- short - test - playlist';
            List<String> playlistsTitles = [
              uniquePlaylistTitle,
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: uniquePlaylistTitle,
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01"
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
                'Restore- short - test - playlist|250518-164035-Really short video 23-07-01',
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
              ],
            );

            // Now, select a filter parms using the drop down button.

            // First, tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            Finder dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            Finder dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            // Define a sort/filter parms in order to be able to select the
            // audio's which will be redoenloaded

            // Open the audio popup menu
            await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
            await tester.pumpAndSettle();

            // Find the sort/filter audio menu item and tap on it to
            // open the audio sort filter dialog
            await tester.tap(find
                .byKey(const Key('define_sort_and_filter_audio_menu_item')));
            await tester.pumpAndSettle();

            // Type "less 70 KB" in the 'Save as' TextField

            String saveAsTitle = 'less 70 KB';

            await tester.enterText(
                find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
                saveAsTitle);
            await tester.pumpAndSettle();

            // Enter the end file size KB in the corresponding field, but first
            // scroll down the dialog so that the date file size fields are
            // visible.

            await tester.drag(
              find.byType(AudioSortFilterDialog),
              const Offset(
                  0, -350), // Negative value for vertical drag to scroll down
            );
            await tester.pumpAndSettle();

            await tester.enterText(
                find.byKey(const Key('endFileSizeTextField')),
                '0.07'); // 70 KB in MB
            await tester.pumpAndSettle(Duration(milliseconds: 200));

            // Click on the "Save" button. This closes the sort/filter dialog
            // and updates the sort/filter playlist download view dropdown
            // button with the newly created sort/filter parms
            await tester
                .tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
            await tester.pumpAndSettle();

            // Re-tap the 'Toggle List' button to display the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Execute the redownload filtered audio menu by clicking first on
            // the 'Filtered Audio Actions ...' playlist menu item and then
            // on the 'Redownload Filtered Audio ...' sub-menu item.
            await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
              tester: tester,
              playlistTitle: uniquePlaylistTitle,
              playlistSubMenuKeyStr: 'popup_menu_redownload_filtered_audio',
            );

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 4; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Tap the 'Toggle List' button to hide the playlist list.
            await tester.tap(find.byKey(const Key('playlist_toggle_button')));
            await tester.pumpAndSettle();

            // Now, select the 'default' filter parms using the drop down button.

            // Now tap on the current dropdown button item to open the dropdown
            // button items list

            dropDownButtonFinder =
                find.byKey(const Key('sort_filter_parms_dropdown_button'));

            dropDownButtonTextFinder = find.descendant(
              of: dropDownButtonFinder,
              matching: find.byType(Text),
            );

            await tester.tap(dropDownButtonTextFinder);
            await tester.pumpAndSettle();

            // And find the 'default' sort/filter item
            Finder defaultDropDownTextFinder = find.text('default').last;
            await tester.tap(defaultDropDownTextFinder);
            await tester.pumpAndSettle();

            // Now we want to tap the popup menu of the Audio ListTile
            // "audio learn test short video one"

            // First, find the Audio sublist ListTile Text widget
            const String audioTitle = "morning _ cinematic video";
            final Finder targetAudioListTileTextWidgetFinder =
                find.text(audioTitle);

            // Then obtain the Audio ListTile widget enclosing the Text widget by
            // finding its ancestor
            final Finder targetAudioListTileWidgetFinder = find.ancestor(
              of: targetAudioListTileTextWidgetFinder,
              matching: find.byType(ListTile),
            );

            // Now find the leading menu icon button of the Audio ListTile and tap
            // on it
            final Finder targetAudioListTileLeadingMenuIconButton =
                find.descendant(
              of: targetAudioListTileWidgetFinder,
              matching: find.byIcon(Icons.menu),
            );

            // Tap the leading menu icon button to open the popup menu
            await tester.tap(targetAudioListTileLeadingMenuIconButton);
            await tester.pumpAndSettle();

            // Now find the popup menu item and tap on it
            final Finder popupDisplayAudioInfoMenuItemFinder =
                find.byKey(const Key("popup_menu_redownload_delete_audio"));

            await tester.tap(popupDisplayAudioInfoMenuItemFinder);
            await tester.pumpAndSettle();

            // Add a delay to allow the download to finish. Since a mock
            // AudioDownloadVM is used, the download will be simulated and
            // will not take time.
            for (int i = 0; i < 3; i++) {
              await Future.delayed(const Duration(seconds: 2));
              await tester.pumpAndSettle();
            }

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  "The audio \"$audioTitle\" was redownloaded in the playlist \"$uniquePlaylistTitle\".",
              isWarningConfirming: true,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after filtered
            // redownload.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: uniquePlaylistTitle,
              expectedAudioFiles: [
                "250518-164035-Really short video 23-07-01.mp3",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.mp3",
                "250518-164039-morning _ cinematic video 23-07-01.mp3",
              ],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            '''Restore 3 selected playlists, 2 saved individually and 1 saved as app saving from appbar
            menu. Each playlist contained in its zip file is selected.''', () {
          testWidgets(
              '''Restore not replace 3 selected unique playlists. First restore the individually saved
              Youtube 'Restore- short - test - playlist'. Then restore the individually saved local
              'Local restore- short - test - playlist'. Finally, restore the not individually saved
              'Prières du Maître' playlist. After each each restore, verify the correct playlist selection.
              Finally, execute the 'Update Playlist JSON Files' appbar menu and verify that the playlist
              selection remains correct. Verify also the application pictureAudioMap.json file content.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            const String notIndividuallySavedPlaylistTitle =
                'Prières du Maître';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Prières du Maître.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3262),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Prières du Maître.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: notIndividuallySavedPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: notIndividuallySavedPlaylistTitle,
                isSelected: false);

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the download app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            // Verify the pictureAudioMap json content after playlist
            // deletion
            IntegrationTestUtil.verifyPictureAudioMapAfterPlaylistRestoration(
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Restore replace 3 selected unique playlists. First restore the individually saved
              Youtube 'Restore- short - test - playlist'. Then restore the individually saved local
              'Local restore- short - test - playlist'. Since the 'doReplaceExistingPlaylists' parameter
              is set to true, the existing picture JPG files restored by the first restore execution
              will be replaced by the restored picture JPG files. Finally, restore the not individually
              saved 'Prières du Maître' playlist (its ZIP file does not contain any JPG file). After
              each each restore, verify the correct playlist selection.
              
              Finally, execute the 'Update Playlist JSON Files' appbar menu and verify that the playlist
              selection remains correct. Verify also the application pictureAudioMap.json file content.''',
              (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Restore- short - test - playlist.zip";

            await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
              tester: tester,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Restore- short - test - playlist.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            const String uniqueYoutubePlaylistTitle =
                'Restore- short - test - playlist';

            // Verifying the restored playlist selection
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            const String uniqueLocalPlaylistTitle =
                'Local restore- short - test - playlist';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Local restore- short - test - playlist.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3138),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog. Since the
            // 'doReplaceExistingPlaylists' parameter is set to true, the
            // existing picture JPG files were replaced by the restored
            // picture JPG files.

            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist saved individually, 2 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 3 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Local restore- short - test - playlist.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: uniqueLocalPlaylistTitle,
                isSelected: false);

            const String notIndividuallySavedPlaylistTitle =
                'Prières du Maître';

            restorableZipFilePathName =
                "$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android Prières du Maître.zip";

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 3262),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            await Future.delayed(const Duration(milliseconds: 500));
            await tester.pumpAndSettle(); // must be used !

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 1 playlist, 1 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 1 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android Prières du Maître.zip".\n\nSince the playlist was created, it is positioned at the end of the playlist list.',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: notIndividuallySavedPlaylistTitle,
                isSelected: false);

            // Now execute the 'Update Playlist JSON Files'
            // appbar menu
            await IntegrationTestUtil.executeUpdatePlaylistJsonFiles(
              tester: tester,
              doRemoveDeletedAudioFiles: false,
            );

            // Verifying that the first restored playlist is
            // still selected
            IntegrationTestUtil.verifyPlaylistSelection(
              tester: tester,
              playlistTitle: uniqueYoutubePlaylistTitle,
              isSelected: true,
            );

            // Ensure that the restored playlist is not
            // selected, although it is selected in the
            // playlist zip file
            IntegrationTestUtil.verifyPlaylistSelection(
                tester: tester,
                playlistTitle: notIndividuallySavedPlaylistTitle,
                isSelected: false);

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the download app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            // Verify the pictureAudioMap json content after playlist
            // deletion
            IntegrationTestUtil.verifyPictureAudioMapAfterPlaylistRestoration(
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
        group(
            '''Restore multiple saved playlists, 2 saved individually and 1 saved as app saving from appbar
            menu. Each playlist contained in its zip file is selected.''', () {
          testWidgets(
              '''Multiple playlists restore, not replace existing playlist. Restore multiple playlists
              Android zip containing "A restaurer", "local" and "Restore- short - test - playlist" playlists
              to empty Windows application.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android audioLearn_multiple_playlists.zip';

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 7460),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: false,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 3 playlist, 7 comment and 7 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 8 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android audioLearn_multiple_playlists.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'S8 audio'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "Restore- short - test - playlist",
              "A restaurer",
              "local",
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'Restore- short - test - playlist',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'Restore- short - test - playlist',
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01",
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              ],
              pictureFileNameFour: 'Sam Altman.jpg',
              audioForPictureTitleFourLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12",
              ],
              pictureFileNameFive: 'Jésus mon Amour.jpg',
              audioForPictureTitleFiveLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              ],
              pictureFileNameSix: "Jésus je T'adore.jpg",
              audioForPictureTitleSixLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
          testWidgets(
              '''Multiple playlists restore, replace existing playlist. Restore multiple playlists
              Android zip containing "A restaurer", "local" and "Restore- short - test - playlist" playlists
              to empty Windows application.''', (WidgetTester tester) async {
            // Purge the test playlist directory if it exists so that the
            // playlist list is empty
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );

            String restorableZipFilePathName =
                '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android audioLearn_multiple_playlists.zip';

            // Since we have to use a mock AudioDownloadVM to add the
            // youtube playlist, we can not use app.main() to start the
            // app because app.main() uses the real AudioDownloadVM
            // and we don't want to make the main.dart file dependent
            // of a mock class. So we have to start the app by hand,
            // what IntegrationTestUtil.launchExpandablePlaylistListView
            // does.

            final SettingsDataService settingsDataService = SettingsDataService(
              sharedPreferences: await SharedPreferences.getInstance(),
              isTest: true,
            );

            // Load the settings from the json file. This is necessary
            // otherwise the ordered playlist titles will remain empty
            // and the playlist list will not be filled with the
            // playlists available in the app test dir
            await settingsDataService.loadSettingsFromFile(
                settingsJsonPathFileName:
                    "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

            WarningMessageVM warningMessageVM = WarningMessageVM();

            // The mockAudioDownloadVM will be later used to simulate
            // redownloading not playable files after having restored
            // the playlists, comments and settings from the zip file.
            MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            AudioDownloadVM audioDownloadVM = AudioDownloadVM(
              warningMessageVM: warningMessageVM,
              settingsDataService: settingsDataService,
            );

            PlaylistListVM playlistListVM = PlaylistListVM(
              warningMessageVM: warningMessageVM,
              audioDownloadVM: mockAudioDownloadVM,
              commentVM: CommentVM(),
              pictureVM: PictureVM(
                settingsDataService: settingsDataService,
              ),
              settingsDataService: settingsDataService,
            );

            // calling getUpToDateSelectablePlaylists() loads all the
            // playlist json files from the app dir and so enables
            // playlistListVM to know which playlists are
            // selected and which are not
            playlistListVM.getUpToDateSelectablePlaylists();

            AudioPlayerVM audioPlayerVM = AudioPlayerVM(
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              commentVM: CommentVM(),
            );

            DateFormatVM dateFormatVM = DateFormatVM(
              settingsDataService: settingsDataService,
            );

            await IntegrationTestUtil
                .launchIntegrTestAppEnablingInternetAccessWithMock(
              tester: tester,
              audioDownloadVM: audioDownloadVM,
              settingsDataService: settingsDataService,
              playlistListVM: playlistListVM,
              warningMessageVM: warningMessageVM,
              audioPlayerVM: audioPlayerVM,
              dateFormatVM: dateFormatVM,
            );

            // Replace the platform instance with your mock
            MockFilePicker mockFilePicker = MockFilePicker();
            FilePicker.platform = mockFilePicker;

            mockFilePicker.setSelectedFiles([
              PlatformFile(
                  name: restorableZipFilePathName,
                  path: restorableZipFilePathName,
                  size: 7460),
            ]);

            // Execute the 'Restore Playlists, Comments and Settings from Zip
            // File ...' menu
            await IntegrationTestUtil.executeRestorePlaylists(
              tester: tester,
              doReplaceExistingPlaylists: true,
            );

            // Verify the displayed warning confirmation dialog
            await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
              tester: tester,
              warningDialogMessage:
                  'Restored 3 playlist, 7 comment and 7 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 8 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android audioLearn_multiple_playlists.zip".',
              isWarningConfirming: true,
              warningTitle: 'CONFIRMATION',
            );

            // Verifying the existing and the restored playlists
            // list as well as the selected playlist 'S8 audio'
            // displayed audio titles and subtitles.

            List<String> playlistsTitles = [
              "Restore- short - test - playlist",
              "A restaurer",
              "local",
            ];

            List<String> audioTitles = [
              "People Talking at The Table _ Free Video Loop",
              "morning _ cinematic video",
              "Really short video",
            ];

            List<String> audioSubTitles = [
              '0:00:24.1 11 KB at 7 KB/sec on 18/05/2025 at 16:40',
              "0:00:58.9 360 KB at 175 KB/sec on 18/05/2025 at 16:40",
              "0:00:09.8 61 KB at 30 KB/sec on 18/05/2025 at 16:40",
            ];

            _verifyRestoredPlaylistAndAudio(
              tester: tester,
              selectedPlaylistTitle: 'Restore- short - test - playlist',
              playlistsTitles: playlistsTitles,
              audioTitles: audioTitles,
              audioSubTitles: audioSubTitles,
            );

            // Verify the content of the 'Restore- short - test - playlist'
            // playlist dir + comments + pictures dir after restoration.
            IntegrationTestUtil.verifyPlaylistDirectoryContents(
              playlistTitle: 'Restore- short - test - playlist',
              expectedAudioFiles: [],
              expectedCommentFiles: [
                "250518-164039-morning _ cinematic video 23-07-01.json",
                "250518-164043-People Talking at The Table _ Free Video Loop 19-09-28.json",
              ],
              expectedPictureFiles: [
                "250518-164035-Really short video 23-07-01.json",
                "250518-164039-morning _ cinematic video 23-07-01.json",
              ],
              doesPictureAudioMapFileNameExist: true,
              applicationPictureDir:
                  '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
              pictureFileNameOne: 'Jean-Pierre.jpg',
              audioForPictureTitleOneLst: [
                "Restore- short - test - playlist|250518-164035-Really short video 23-07-01",
              ],
              pictureFileNameTwo:
                  "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
              audioForPictureTitleTwoLst: [
                "Restore- short - test - playlist|250518-164039-morning _ cinematic video 23-07-01",
              ],
              pictureFileNameThree: 'Jésus le Dieu vivant.jpg',
              audioForPictureTitleThreeLst: [
                "Restore- short - test - playlist|250518-164043-People Talking at The Table _ Free Video Loop 19-09-28",
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              ],
              pictureFileNameFour: 'Sam Altman.jpg',
              audioForPictureTitleFourLst: [
                "A restaurer|250213-083024-Sam Altman prédit la FIN de 99% des développeurs humains (c'estpour2025...) 25-02-12",
                "A restaurer|250224-131619-L'histoire secrète derrière la progression de l'IA 25-02-12",
              ],
              pictureFileNameFive: 'Jésus mon Amour.jpg',
              audioForPictureTitleFiveLst: [
                "A restaurer|250224-132737-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09",
              ],
              pictureFileNameSix: "Jésus je T'adore.jpg",
              audioForPictureTitleSixLst: [
                "local|250213-083015-Un fille revient de la mort avec un message HORRIFIANT de Jésus - Témoignage! 25-02-09"
              ],
            );

            // Purge the test playlist directory so that the created test
            // files are not uploaded to GitHub
            DirUtil.deleteFilesInDirAndSubDirs(
              rootPath: kApplicationPathWindowsTest,
            );
          });
        });
      });
      group(
          '''On not empty app dir where a playlist is selected, restore Android zip in which playlist(s)
          corresponding to existing playlist(s) contain additional audio's to which comments and pictures
          are associated. This situation happens if the AudioLearn application exists on two different
          engines and the user wants to restore the playlists, comments and pictures from one computer
          to another in order to add to the target pc or smartphone the audio's downloaded on the source
          engine. The audio mp3 files are not added since they are not in the zip file. But the Audio
          objects are added to the existing playlist and so can be redownloaded if needed.''',
          () {
        testWidgets(
            '''Unique playlist restore, not replace existing playlist. Restore unique playlist Android zip
            containing 'S8 audio' playlist to Windows application which contains 'S8 audio' and 'local'
            playlists. The restored 'S8 audio' playlist contains additional audio's to which comments and
            pictures are associated.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android S8 audio.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 163840),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
            verifySetValueToTargetDialog: true,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist saved individually, 2 comment and 2 picture JSON files as well as 2 picture JPG file(s) in the application pictures directory and 2 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android S8 audio.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing restored playlist
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "S8 audio",
            "local",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
            "Quand Aurélien Barrau va dans une école de management",
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB imported on 23/06/2025 at 06:56',
            "0:17:59.0 6.58 MB at 1.37 MB/sec on 23/06/2025 at 06:55",
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/07/2024 at 16:35",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'S8 audio',
            expectedAudioFiles: [
              "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.mp3",
              "240701-163521-Jancovici m'explique l’importance des ordres de grandeur face au changement climatique 22-06-12.mp3",
            ],
            expectedCommentFiles: [
              "240701-163607-La surpopulation mondiale par Jancovici et Barrau 23-12-03.json",
              "250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json",
            ],
            expectedPictureFiles: [
              "250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10.json",
              "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'.json"
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Barrau.jpg',
            audioForPictureTitleOneLst: [
              "S8 audio|250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10"
            ],
            pictureFileNameTwo: 'Jésus, mon amour.jpg',
            audioForPictureTitleTwoLst: [
              "S8 audio|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
          );

          DirUtil.deleteFileIfExist(
            pathFileName:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}Barrau.jpg',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist saved individually, 0 comment and 0 picture JSON files as well as 1 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android S8 audio.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore, not replace existing playlists. Restore multiple playlists Android
             zip containing 'S8 audio' and 'local' playlists to Windows application which contain 'S8 audio'
             and 'local' playlists. The restored 'S8 audio' and 'local' playlists contains additional audio's
             to which comments and pictures are associated.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android 2 existing playlists with new audios.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 9387),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist, 3 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android 2 existing playlists with new audios.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verifying the existing restored playlist
          // list as well as the selected playlist 'Prières du
          // Maître' displayed audio titles and subtitles.

          List<String> playlistsTitles = [
            "S8 audio",
            "local",
          ];

          List<String> audioTitles = [
            "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
            "Quand Aurélien Barrau va dans une école de management",
            "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
          ];

          List<String> audioSubTitles = [
            '0:02:39.6 2.59 MB imported on 23/06/2025 at 06:56',
            "0:17:59.0 6.58 MB at 1.37 MB/sec on 23/06/2025 at 06:55",
            "0:06:29.0 2.37 MB at 1.69 MB/sec on 01/07/2024 at 16:35",
          ];

          _verifyRestoredPlaylistAndAudio(
            tester: tester,
            selectedPlaylistTitle: 'S8 audio',
            playlistsTitles: playlistsTitles,
            audioTitles: audioTitles,
            audioSubTitles: audioSubTitles,
          );

          // Verify the content of the 'S8 audio' playlist dir
          // + comments + pictures dir after restoration.
          IntegrationTestUtil.verifyPlaylistDirectoryContents(
            playlistTitle: 'local',
            expectedAudioFiles: [
              "240110-181805-Really short video 23-07-01.mp3",
              "240110-181810-morning _ cinematic video 23-07-01.mp3",
            ],
            expectedCommentFiles: [
              "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
            ],
            expectedPictureFiles: [
              "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
            ],
            doesPictureAudioMapFileNameExist: true,
            applicationPictureDir:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName',
            pictureFileNameOne: 'Barrau.jpg',
            audioForPictureTitleOneLst: [
              "S8 audio|250623-065532-Quand Aurélien Barrau va dans une école de management 23-09-10"
            ],
            pictureFileNameTwo: 'Jésus, mon amour.jpg',
            audioForPictureTitleTwoLst: [
              "S8 audio|Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'"
            ],
            pictureFileNameThree: "Dieu je T'adore.jpg",
            audioForPictureTitleThreeLst: [
              "local|Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
            ],
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
      });
      group(
          '''On empty app dir, first restore Android zip in containing a unique or multiple playlist(s).
          Then restore unique or multiple playlist(s) corresponding to the previously restored playlist(s)
          which contain a comment for a not yet commented existing audio as well as a new comment for a
          already commented existing audio as well as an updated comment for an existing audio which
          already has this comment.''', () {
        testWidgets(
            '''Unique playlist restore, not replace existing playlist. Restore unique playlist Android zip
            containing 'Prières du Maître' playlist. Then restore to Windows application unique playlist
            Android zip containing the corresponding playlist with new and modified comments. The two
            modified comments will update or not the existing comment according to their modification date.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_2_existing_playlists_with_new_and_modified_comments",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          // Install the initial version of the unique saved
          // playlist 'Prières du Maître'

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android Prières initialization.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 2874035),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings
          // from Zip File ...' menu to install the initial version
          // of the unique saved playlist 'Prières du Maître'
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 1 playlist saved individually, 3 comment and 3 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android Prières initialization.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify the restored playlist audio comments

          // First, open the playlist comment dialog
          Finder playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'Prières du Maître',
          );

          Finder playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            6,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
              playlistCommentListDialogFinder: playlistCommentListDialogFinder,
              expectedCommentTextsLst: [
                "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                "Les paroles très inspirantes",
                "25/06/25",
                "16/07/25",
                "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                "La prière du Maître",
                "20/06/25",
                "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                "12/08/24",
                "02/12/24",
                "Je pleure, je pleure, je pleure de joie !\n\n\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
              ]);

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // Restore the modified version of the unique saved
          // playlist 'Prières du Maître' which contains new
          // and modified comments

          restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android Prières comment restoration.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 2874418),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings
          // from Zip File ...' menu to install the modified version
          // of the unique saved playlist 'Prières du Maître'
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
            verifySetValueToTargetDialog: true,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 1 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android Prières comment restoration.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify the restored playlist audio comments

          // First, open the playlist comment dialog
          playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'Prières du Maître',
          );

          playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            8,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
              playlistCommentListDialogFinder: playlistCommentListDialogFinder,
              expectedCommentTextsLst: [
                "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                "Les paroles très inspirantes",
                "25/06/25",
                "16/07/25",
                "Seigneur, je T'en prie, mets-moi dans le feu de Ton Amour !",
                "Full comment",
                "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                "La prière du Maître",
                "20/06/25",
                "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                "12/08/24",
                "\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
              ]);

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''With added and modified comments, multiple playlists restore, not replace existing playlists.
              Restore multiple playlist Android zip containing 'Prières du Maître' and 'local' playlists. Then
              restore to Windows application the multiple playlists Android zip containing the corresponding
              playlists with added and modified comments. The two modified comments will update or not the existing
              comment according to their  modification date.''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          // Copy the test initial audio data to the app dir
          DirUtil.copyFilesFromDirAndSubDirsToDirectory(
            sourceRootPath:
                "$kDownloadAppTestSavedDataDir${path.separator}restore_2_existing_playlists_with_new_and_modified_comments",
            destinationRootPath: kApplicationPathWindowsTest,
          );

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          await app.main();
          await tester.pumpAndSettle();

          // Install the initial version of the two saved
          // playlist 'Prières du Maître' and 'local'

          String restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android Prières and local initialization.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7898000),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings
          // from Zip File ...' menu to install the initial version
          // of the two saved playlist 'Prières du Maître' and 'local'

          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 5 comment and 4 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 8 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android Prières and local initialization.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify the restored playlist audio comments

          // First, open the 'Prières du Maître' playlist comment dialog
          Finder playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'Prières du Maître',
          );

          Finder playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            6,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
              playlistCommentListDialogFinder: playlistCommentListDialogFinder,
              expectedCommentTextsLst: [
                "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                "Les paroles ...",
                "25/06/25",
                "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                "La prière du Maître",
                "20/06/25",
                "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                "12/08/24",
                "02/12/24",
                "Je pleure, je pleure, je pleure de joie !\n\n\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
              ]);

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // First, open the 'local' playlist comment dialog
          playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'local',
          );

          playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            5,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
            playlistCommentListDialogFinder: playlistCommentListDialogFinder,
            expectedCommentTextsLst: [
              "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
              "All",
              "23/06/25",
              "Marie-France",
              "One",
              "29/06/25",
              "Two",
              "29/06/25",
            ],
            multipleString: "29/06/25",
            multipleCount: 2,
          );

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // Restore the modified version of the of the two saved
          // playlist 'Prières du Maître' and 'local' which contains
          // new and modified comments

          restorableZipFilePathName =
              '$kApplicationPathWindowsTest${path.separator}Android Prières and local comment restoration.zip';

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 2874418),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings
          // from Zip File ...' menu to install the modified version
          // of the two saved playlist 'Prières du Maître' and 'local'

          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 1 added plus 4 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\Android Prières and local comment restoration.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Verify the restored playlist audio comments

          // First, open the playlist comment dialog on the
          // 'Prières du Maître' playlist
          playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'Prières du Maître',
          );

          playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            8,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
              playlistCommentListDialogFinder: playlistCommentListDialogFinder,
              expectedCommentTextsLst: [
                "JÉSUS, C'EST LE PLUS BEAU NOM _ Louange acoustique",
                "Les paroles inspirantes",
                "25/06/25",
                "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                "La prière du Maître",
                "20/06/25",
                "Seigneur, je T'en prie, mets-moi dans le feu de Ton Amour !",
                "Full comment",
                "30/06/25",
                "Omraam Mikhaël Aïvanhov  'Je vivrai d’après l'amour!'",
                "Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,",
                "12/08/24",
                "\"Je vivrai d’après l'amour exactement comme l'a enseigné le Christ,\nque ma vie s'améliore par l'amour !\nJe vivrai d’après la loi de Dieu,\nque ma vie se transforme, ainsi que Dieu l'a demandé !\"",
              ]);

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // First, open the 'local' playlist comment dialog
          playlistCommentListDialogFinder =
              await IntegrationTestUtil.openPlaylistCommentDialog(
            tester: tester,
            playlistTitle: 'local',
          );

          playlistCommentListFinder =
              find.byKey(const Key('playlistCommentsListKey'));

          // Ensure the list has 6 child widgets
          expect(
            tester.widget<ListBody>(playlistCommentListFinder).children.length,
            6,
          );

          IntegrationTestUtil.checkPlaylistCommentListDialogContent(
              playlistCommentListDialogFinder: playlistCommentListDialogFinder,
              expectedCommentTextsLst: [
                "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
                "Prière",
                "23/06/25",
                "Marie-France",
                "One",
                "Two",
                "Before restore",
                "Three",
                "0:28",
                "0:33",
              ]);

          // Now close the comment list dialog
          await tester.tap(find
              .byKey(const Key('playlistCommentListCloseDialogTextButton')));
          await tester.pumpAndSettle();

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore from ZIP containing pictures, not replace existing playlist. Restore
               multiple playlists Windows zip containing 'local' and 'S8 audio' playlists to empty Windows
               application.''', (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android restore_multiple_playlists_and_pictures.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Verify that the audio menu button is disabled
          IntegrationTestUtil.verifyWidgetIsDisabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify that the audio menu button is enabled
          IntegrationTestUtil.verifyWidgetIsEnabled(
            tester: tester,
            widgetKeyStr: 'audio_popup_menu_button',
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 4 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
        testWidgets(
            '''Multiple playlists restore from ZIP containing pictures, not replace existing playlist. Restore
               multiple playlists Windows zip containing 'local' and 'S8 audio' playlists to empty Windows
               application. Then restore again the same ZIP after deleting 1 picture''',
            (WidgetTester tester) async {
          // Purge the test playlist directory if it exists so that the
          // playlist list is empty
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );

          String restorableZipFilePathName =
              '$kDownloadAppTestSavedDataDir${path.separator}zip_files_for_restore_tests${path.separator}Android restore_multiple_playlists_and_pictures.zip';

          // Since we have to use a mock AudioDownloadVM to add the
          // youtube playlist, we can not use app.main() to start the
          // app because app.main() uses the real AudioDownloadVM
          // and we don't want to make the main.dart file dependent
          // of a mock class. So we have to start the app by hand,
          // what IntegrationTestUtil.launchExpandablePlaylistListView
          // does.

          final SettingsDataService settingsDataService = SettingsDataService(
            sharedPreferences: await SharedPreferences.getInstance(),
            isTest: true,
          );

          // Load the settings from the json file. This is necessary
          // otherwise the ordered playlist titles will remain empty
          // and the playlist list will not be filled with the
          // playlists available in the app test dir
          await settingsDataService.loadSettingsFromFile(
              settingsJsonPathFileName:
                  "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

          WarningMessageVM warningMessageVM = WarningMessageVM();

          // The mockAudioDownloadVM will be later used to simulate
          // redownloading not playable files after having restored
          // the playlists, comments and settings from the zip file.
          MockAudioDownloadVM mockAudioDownloadVM = MockAudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          AudioDownloadVM audioDownloadVM = AudioDownloadVM(
            warningMessageVM: warningMessageVM,
            settingsDataService: settingsDataService,
          );

          PlaylistListVM playlistListVM = PlaylistListVM(
            warningMessageVM: warningMessageVM,
            audioDownloadVM: mockAudioDownloadVM,
            commentVM: CommentVM(),
            pictureVM: PictureVM(
              settingsDataService: settingsDataService,
            ),
            settingsDataService: settingsDataService,
          );

          // calling getUpToDateSelectablePlaylists() loads all the
          // playlist json files from the app dir and so enables
          // playlistListVM to know which playlists are
          // selected and which are not
          playlistListVM.getUpToDateSelectablePlaylists();

          AudioPlayerVM audioPlayerVM = AudioPlayerVM(
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            commentVM: CommentVM(),
          );

          DateFormatVM dateFormatVM = DateFormatVM(
            settingsDataService: settingsDataService,
          );

          await IntegrationTestUtil
              .launchIntegrTestAppEnablingInternetAccessWithMock(
            tester: tester,
            audioDownloadVM: audioDownloadVM,
            settingsDataService: settingsDataService,
            playlistListVM: playlistListVM,
            warningMessageVM: warningMessageVM,
            audioPlayerVM: audioPlayerVM,
            dateFormatVM: dateFormatVM,
          );

          // Replace the platform instance with your mock
          MockFilePicker mockFilePicker = MockFilePicker();
          FilePicker.platform = mockFilePicker;

          mockFilePicker.setSelectedFiles([
            PlatformFile(
                name: restorableZipFilePathName,
                path: restorableZipFilePathName,
                size: 7460),
          ]);

          // Execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 2 playlist, 1 comment and 4 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 12 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          DirUtil.deleteFileIfExist(
            pathFileName:
                '$kApplicationPathWindowsTest${path.separator}$kPictureDirName${path.separator}20130208_080157.jpg',
          );

          // Re-execute the 'Restore Playlists, Comments and Settings from Zip
          // File ...' menu
          await IntegrationTestUtil.executeRestorePlaylists(
            tester: tester,
            doReplaceExistingPlaylists: false,
          );

          // Verify the displayed warning confirmation dialog
          await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
            tester: tester,
            warningDialogMessage:
                'Restored 0 playlist, 0 comment and 0 picture JSON files as well as 1 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\saved\\zip_files_for_restore_tests\\Android restore_multiple_playlists_and_pictures.zip".',
            isWarningConfirming: true,
            warningTitle: 'CONFIRMATION',
          );

          // Purge the test playlist directory so that the created test
          // files are not uploaded to GitHub
          DirUtil.deleteFilesInDirAndSubDirs(
            rootPath: kApplicationPathWindowsTest,
          );
        });
      });
    });
  });
  group('Restore audio MP3 files from MP3 zip file', () {
    testWidgets(
        '''Restore Playlist Audio's MP3 from Zip File ... playlist item menu selecting a unique playlist
           MP3 zip file. First, on empty app dir, restore unique playlist Windows zip containing 
           urgent_actus_17-12-2023 playlist and then restore unique playlist MP3 zip file containing the
           audio's of this playlist. The restored audio's are playable.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the integration test data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      const String playlistTitle = 'urgent_actus_17-12-2023';

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}$playlistTitle.zip';

      await app.main();
      await tester.pumpAndSettle();

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2632),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings from Zip
      // File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 1 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\urgent_actus_17-12-2023.zip".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Now creating a 'Playable' sort filter parmeter
      // in order to hide the not playable audio's. After
      // restoring the MP3 files, all audio's of the playlist
      // will be playable and so will be displayed.

      const String saveAsTitle = 'Playable';

      // Creating the 'Playable' sort filter parameters which
      // will be applied and used after restoring the MP3 files
      // of the playlist
      await _createAndSavePlayableSortFilterParms(
        tester: tester,
        saveAsTitle: saveAsTitle,
      );

      // Verifying the playable audio's number before restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      Finder listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        0,
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}urgent_actus_17-12-2023_mp3_from_2025-08-12_16_29_25_on_2025-08-15_11_23_41.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 15368672),
      ]);

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: playlistTitle,
        playlistMenuKeyStr:
            'popup_menu_restore_playlist_audio_mp3_files_from_zip',
      );

      // Verify the displayed confirmation dialog
      await IntegrationTestUtil.verifySetValueToTargetDialog(
        tester: tester,
        dialogTitle: 'MP3 Restoration',
        dialogMessage:
            "Only the MP3 relative to the audio's listed in the playlist which are not already present in the playlist are restorable.",
        closeDialog: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 3 audio(s) MP3 in 1 playlist from the unique playlist MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verifying the playable audio's number after restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        3,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore Playlist Audio's MP3 from Zip File ... playlist item menu selecting a multiple
           playlists MP3 zip file. First, on empty app dir, restore unique playlist Windows zip
           containing urgent_actus_17-12-2023 playlist and then restore multiple playlist MP3 zip
           file containing the audio's of this playlist and of another playlist. The restored audio's
           are playable.''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the integration test data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      const String playlistTitle = 'urgent_actus_17-12-2023';

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}$playlistTitle.zip';

      await app.main();
      await tester.pumpAndSettle();

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2632),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings from Zip
      // File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 1 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\urgent_actus_17-12-2023.zip".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Now creating a 'Playable' sort filter parmeter
      // in order to hide the not playable audio's. After
      // restoring the MP3 files, all audio's of the playlist
      // will be playable and so will be displayed.

      const String saveAsTitle = 'Playable';

      // Creating the 'Playable' sort filter parameters which
      // will be applied and used after restoring the MP3 files
      // of the playlist
      await _createAndSavePlayableSortFilterParms(
        tester: tester,
        saveAsTitle: saveAsTitle,
      );

      // Verifying the playable audio's number before restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      Finder listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        0,
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 19331059),
      ]);

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: playlistTitle,
        playlistMenuKeyStr:
            'popup_menu_restore_playlist_audio_mp3_files_from_zip',
      );

      // Verify the displayed confirmation dialog
      await IntegrationTestUtil.verifySetValueToTargetDialog(
        tester: tester,
        dialogTitle: 'MP3 Restoration',
        dialogMessage:
            "Only the MP3 relative to the audio's listed in the playlist which are not already present in the playlist are restorable.",
        closeDialog: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 4 audio(s) MP3 in 1 playlist from the unique playlist MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verifying the playable audio's number after restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore Playlists Audio's MP3 from Zip File ... appbar item menu selecting a unique
           playlist MP3 zip file. First, on empty app dir, restore unique playlist Windows zip 
           containing urgent_actus_17-12-2023 playlist and then restore unique playlist MP3 zip
           file containing the audio's of this playlist. The restored audio's are playable.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the integration test data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      const String playlistTitle = 'urgent_actus_17-12-2023';

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}$playlistTitle.zip';

      await app.main();
      await tester.pumpAndSettle();

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2632),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings from Zip
      // File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 1 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\urgent_actus_17-12-2023.zip".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Now creating a 'Playable' sort filter parmeter
      // in order to hide the not playable audio's. After
      // restoring the MP3 files, all audio's of the playlist
      // will be playable and so will be displayed.

      const String saveAsTitle = 'Playable';

      // Creating the 'Playable' sort filter parameters which
      // will be applied and used after restoring the MP3 files
      // of the playlist
      await _createAndSavePlayableSortFilterParms(
        tester: tester,
        saveAsTitle: saveAsTitle,
      );

      // Verifying the playable audio's number before restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      Finder listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        0,
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}urgent_actus_17-12-2023_mp3_from_2025-08-12_16_29_25_on_2025-08-15_11_23_41.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 15368672),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Verify the displayed confirmation dialog
      await IntegrationTestUtil.verifySetValueToTargetDialog(
        tester: tester,
        dialogTitle: 'MP3 Restoration',
        dialogMessage:
            "Only the MP3 relative to the audio's listed in the playlists which are not already present in the playlists are restorable.",
        closeDialog: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 3 audio(s) MP3 in 1 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verifying the playable audio's number after restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        3,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore Playlists Audio's MP3 from Zip File ... appbar item menu selecting a multiple
           playlists MP3 zip file. First, on empty app dir, restore unique playlist Windows zip 
           containing urgent_actus_17-12-2023 playlist and then restore multiple playlists MP3 zip
           file containing the audio's of this playlist. The restored audio's are playable.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the integration test data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      const String playlistTitle = 'urgent_actus_17-12-2023';

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}$playlistTitle.zip';

      await app.main();
      await tester.pumpAndSettle();

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2632),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings from Zip
      // File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 1 playlist saved individually, 1 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 4 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\urgent_actus_17-12-2023.zip".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Now creating a 'Playable' sort filter parmeter
      // in order to hide the not playable audio's. After
      // restoring the MP3 files, all audio's of the playlist
      // will be playable and so will be displayed.

      const String saveAsTitle = 'Playable';

      // Creating the 'Playable' sort filter parameters which
      // will be applied and used after restoring the MP3 files
      // of the playlist
      await _createAndSavePlayableSortFilterParms(
        tester: tester,
        saveAsTitle: saveAsTitle,
      );

      // Verifying the playable audio's number before restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      Finder listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        0,
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 15368672),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Verify the displayed confirmation dialog
      await IntegrationTestUtil.verifySetValueToTargetDialog(
        tester: tester,
        dialogTitle: 'MP3 Restoration',
        dialogMessage:
            "Only the MP3 relative to the audio's listed in the playlists which are not already present in the playlists are restorable.",
        closeDialog: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 4 audio(s) MP3 in 1 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verifying the playable audio's number after restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        4,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore Playlists Audio's MP3 from Zip File ... appbar item menu selecting a multiple
           playlists MP3 zip file. First, on empty app dir, restore 2 playlists Windows zip 
           containing urgent_actus_17-12-2023 and local playlist and then restore multiple playlists MP3 zip
           file containing the audio's of this playlist. The restored audio's are playable.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the integration test data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_existing_playlists_with_new_audios_android_emulator",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}audioLearn_2025-09-07_07_45_02.zip';

      await app.main();
      await tester.pumpAndSettle();

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2632),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings from Zip
      // File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 2 playlist, 4 comment and 1 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 10 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "C:\\development\\flutter\\audiolearn\\test\\data\\audio\\audioLearn_2025-09-07_07_45_02.zip".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Now creating a 'Playable' sort filter parmeter
      // in order to hide the not playable audio's. After
      // restoring the MP3 files, all audio's of the playlist
      // will be playable and so will be displayed.

      const String saveAsTitle = 'Playable';

      // Creating the 'Playable' sort filter parameters which
      // will be applied and used after restoring the MP3 files
      // of the playlist
      await _createAndSavePlayableSortFilterParms(
        tester: tester,
        saveAsTitle: saveAsTitle,
      );

      // Verifying the playable audio's number before restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      Finder listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        0,
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}audioLearn_mp3_from_2025-08-12_16_29_25_on_2025-09-07_07_46_29.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 15368672),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Verify the displayed confirmation dialog
      await IntegrationTestUtil.verifySetValueToTargetDialog(
        tester: tester,
        dialogTitle: 'MP3 Restoration',
        dialogMessage:
            "Only the MP3 relative to the audio's listed in the playlists which are not already present in the playlists are restorable.",
        closeDialog: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 6 audio(s) MP3 in 2 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verifying the playable audio's number after restoring
      // the MP3 files of the playlist

      // Find the audio list widget using its key
      listFinder = find.byKey(const Key('audio_list'));

      expect(
        tester
            .widgetList(find.descendant(
              of: listFinder,
              matching: find.byType(ListTile),
            ))
            .length,
        1,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Advanced restoration from source playlist to target playlist test.',
      () {
    testWidgets(
        '''After restoring initial audiolearn target application containing 4 playlists as well as
          restoring their mp3, restore the source playlist in which 2 audio's present in the target
          playlists were deleted and in which 2 playlists were deleted. Finally, re-restore the initial
          audiolearn target application containing 4 playlists without setting the "Replace existing
          playlists" checkbox to true as well as re-restore their mp3 to verify that after 2 audio's
          and 2 playlists were deletd, it is not possible to restore totally the initial audiolearn
          application.''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            'Restored 4 playlist, 6 comment and 6 picture JSON files as well as 3 picture JPG file(s) in the application pictures directory and 11 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from "$restorableZipFilePathName".',
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 11 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      final String urgentActuPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023";
      final String localPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}local";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Restore the source playlist in which 2 audio's
      // present in the target playlists were deleted and
      // in which 2 playlists ("local_1", "local_2") not
      // present in the ZIP were deleted

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_audioLearn_2_deleted_playlists_2_deleted_audios_with_pictures_2025-10-04_11_52_58.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 0 playlist, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from \"$restorableZipFilePathName\".\n\nDeleted 2 audio(s)\n  \"Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!\",\n  \"L’uniforme arrive en France en 2024\"\nand their comment(s) and picture(s) as well as their MP3 file.\n\nDeleted 2 playlist(s)\n  \"local_1\",\n  \"local_2\"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the MP3 files in the playlists not deleted after
      // 2 audio's were deleted
      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Re-install the initial version of the four saved
      // playlists

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to re-install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Close the displayed warning confirmation dialog
      await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
      await tester.pumpAndSettle();

      mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 2 audio(s) MP3 in 2 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore the source playlist in which 2 audio's present in the target playlists were deleted
          and in which 2 playlists were deleted after restoring initial audiolearn target application
          containing 4 playlists as well as restoring their mp3, . Finally, re-restore the initial
          audiolearn target application containing 4 playlists WITH setting the "Replace existing
          playlists" checkbox to TRUE as well as re-restore their mp3 to verify that after 2 audio's
          and 2 playlists were deletd, IT IS NOW POSSIBLE to restore totally the initial audiolearn
          application.''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Close the displayed warning confirmation dialog
      await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
      await tester.pumpAndSettle();

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 11 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      final String urgentActuPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023";
      final String localPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}local";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Restore the source playlist in which 2 audio's
      // present in the target playlists were deleted and
      // in which 2 playlists ("local_1", "local_2") not
      // present in the ZIP were deleted

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_audioLearn_2_deleted_playlists_2_deleted_audios_with_pictures_2025-10-04_11_52_58.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 0 playlist, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from \"$restorableZipFilePathName\".\n\nDeleted 2 audio(s)\n  \"Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!\",\n  \"L’uniforme arrive en France en 2024\"\nand their comment(s) and picture(s) as well as their MP3 file.\n\nDeleted 2 playlist(s)\n  \"local_1\",\n  \"local_2\"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the MP3 files in the playlists not deleted after
      // 2 audio's were deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Re-install the initial version of the four saved
      // playlists WITH setting the "Replace existing playlists"
      // checkbox to true

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to re-install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: true,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 4 playlist, 3 comment and 6 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 11 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from \"$restorableZipFilePathName\".\n\nSince the playlists\n  \"local\",\n  \"local_1\",\n  \"local_2\",\n  \"urgent_actus_17-12-2023\"\nwere created, they are positioned at the end of the playlist list.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 4 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Test error restoring initial audiolearn target application with selecting its mp3 restorition
          ZIP instead of its playlists ZIP.''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 0 playlist saved individually, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from \"$restorableZipFilePathName\".",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the restored MP3 files in the playlists not deleted

      List<String> expectedUrgentActusMp3Lst = [];

      expect(
        DirUtil.listFileNamesInDir(
          directoryPath:
              "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023",
          fileExtension: 'mp3',
        ),
        expectedUrgentActusMp3Lst,
      );

      List<String> expectedLocalMp3Lst = [];

      expect(
        DirUtil.listFileNamesInDir(
          directoryPath:
              "$kPlaylistDownloadRootPathWindowsTest${path.separator}local",
          fileExtension: 'mp3',
        ),
        expectedLocalMp3Lst,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''After restoring initial audiolearn target application containing 4 playlists as well as
          restoring their mp3, restore the source playlist in which 2 audio's present in the target
          playlists were deleted, 2 playlists were deleted and 2 playlists were added.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Close the displayed warning confirmation dialog
      await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
      await tester.pumpAndSettle();

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 11 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      final String urgentActuPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023";
      final String localPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}local";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Restore the source playlist in which 2 audio's
      // present in the target playlists were deleted and
      // in which 2 playlists ("local_1", "local_2") not
      // present in the ZIP were deleted and in which 2
      // playlists ("local_3", "local_4") were added

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_audioLearn_with_2_new_2_deleted_playlist_2_deleted_audios_2025-10-05_13_16_51.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 2 playlist, 2 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 2 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) and the application settings from \"$restorableZipFilePathName\".\n\nDeleted 2 audio(s)\n  \"Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!\",\n  \"L’uniforme arrive en France en 2024\"\nand their comment(s) and picture(s) as well as their MP3 file.\n\nDeleted 2 playlist(s)\n  \"local_1\",\n  \"local_2\"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.\n\nSince the playlists\n  \"local_3\",\n  \"local_4\"\nwere created, they are positioned at the end of the playlist list.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the MP3 files in the playlists not deleted after
      // 2 audio's were deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore the unique playlist zip in which 1 audio's present in the corresponding target
          playlist was deleted after restoring initial audiolearn target application containing 4
          playlists as well as restoring their mp3.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Close the displayed warning confirmation dialog
      await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
      await tester.pumpAndSettle();

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 11 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      final String urgentActuPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023";
      final String localPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}local";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Restore the unique playlist ZIP in which 1 audio
      // present in the corresponding target playlist was
      // deleted

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_urgent_actus_17-12-2023_with_1_deleted_audio.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 0 playlist saved individually, 0 comment and 0 picture JSON files as well as 0 picture JPG file(s) in the application pictures directory and 0 audio reference(s) and 0 added plus 0 modified comment(s) in existing audio comment file(s) from \"$restorableZipFilePathName\".\n\nDeleted 1 audio(s)\n  \"L’uniforme arrive en France en 2024\"\nand their comment(s) and picture(s) as well as their MP3 file.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the MP3 files in the playlists not deleted after
      // 1 audio was deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''Restore the source playlist with 2 new comments and 2 new pictures in which 2 audio's present
          in the target playlists were deleted and 2 audio's were added as well as 2 playlists were deleted.
          This is done after restoring initial audiolearn target application containing 4 playlists as well
          as restoring their mp3.''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      // Copy the test initial audio data to the app dir
      DirUtil.copyFilesFromDirAndSubDirsToDirectory(
        sourceRootPath:
            "$kDownloadAppTestSavedDataDir${path.separator}restore_sing_or_mult_playlists_with_delete_audio_mp3",
        destinationRootPath: kApplicationPathWindowsTest,
      );

      final SettingsDataService settingsDataService = SettingsDataService(
        sharedPreferences: await SharedPreferences.getInstance(),
        isTest: true,
      );

      // Load the settings from the json file. This is necessary
      // otherwise the ordered playlist titles will remain empty
      // and the playlist list will not be filled with the
      // playlists available in the app test dir
      await settingsDataService.loadSettingsFromFile(
          settingsJsonPathFileName:
              "$kApplicationPathWindowsTest${path.separator}$kSettingsFileName");

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      await app.main();
      await tester.pumpAndSettle();

      // Install the initial version of the four saved
      // playlists

      String restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_app_with_pictures.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 2782168),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu to install the initial
      // audiolearn version
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Close the displayed warning confirmation dialog
      await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
      await tester.pumpAndSettle();

      // Verify the restored picture files in the application
      // pictures directory

      final String appPicturesDir =
          "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
          "Dieu-le-Père.jpg",
          "Screenshot_20250903_202601.jpg",
        ],
        directoryPath: appPicturesDir,
        fileExtension: 'jpg',
      );

      // Verify the picture application json map content

      List<String> pictureFileNamesLstOne = [
        "local|Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!",
        "urgent_actus_17-12-2023|aaa"
      ];
      List<String> audioForPictureTitleLstTwo = [
        "urgent_actus_17-12-2023|250812-162929-L’uniforme arrive en France en 2024 23-12-11",
        "urgent_actus_17-12-2023|250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13"
      ];
      List<String> audioForPictureTitleLstThree = [
        "local|240110-181805-Really short video 23-07-01",
        "urgent_actus_17-12-2023|250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07"
      ];

      // Now verifying the audio picture addition result
      IntegrationTestUtil.verifyApplicationPictureJsonMap(
        applicationPictureDir: appPicturesDir,
        pictureFileNameOne: "Dieu-le-Père.jpg",
        audioForPictureTitleOneLst: pictureFileNamesLstOne,
        pictureFileNameTwo:
            "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
        audioForPictureTitleTwoLst: audioForPictureTitleLstTwo,
        pictureFileNameThree: "Screenshot_20250903_202601.jpg",
        audioForPictureTitleThreeLst: audioForPictureTitleLstThree,
      );

      // Verify the restored picture json files of the
      // urgent_actus_17-12-2023 playlist

      final String urgentActuPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}urgent_actus_17-12-2023";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.json",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.json",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.json",
          "aaa.json",
        ],
        directoryPath: "$urgentActuPath${path.separator}$kPictureDirName",
        fileExtension: 'json',
      );

      // Verify the restored picture json files of the local playlist

      final String localPath =
          "$kPlaylistDownloadRootPathWindowsTest${path.separator}local";

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.json",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
        ],
        directoryPath: "$localPath${path.separator}$kPictureDirName",
        fileExtension: 'json',
      );

      // Verify the restored comment files of the
      // urgent_actus_17-12-2023 playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "aaa.json",
          "bbb.json",
        ],
        directoryPath: "$urgentActuPath${path.separator}$kCommentDirName",
        fileExtension: 'json',
      );

      // Verify the restored comment files of the local playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "aaa.json",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.json",
        ],
        directoryPath: "$localPath${path.separator}$kCommentDirName",
        fileExtension: 'json',
      );

      String mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}initial_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 18374505),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 11 audio(s) MP3 in 4 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the restored MP3 files in the playlists not deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Restore the source playlist in which 2 audio's present
      // in the target playlists were deleted, 2 audio's were added
      // and in which 2 playlists ("local_1", "local_2") not
      // present in the ZIP were deleted

      restorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_audioLearn_app_with_pictures_comments_and_2_deleted_2_added_audios_and_2_deleted_playlists.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: restorableZipFilePathName,
            path: restorableZipFilePathName,
            size: 5211721),
      ]);

      // Execute the 'Restore Playlists, Comments and Settings
      // from Zip File ...' menu
      await IntegrationTestUtil.executeRestorePlaylists(
        tester: tester,
        doReplaceExistingPlaylists: false,
      );

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 0 playlist, 2 comment and 1 picture JSON files as well as 2 picture JPG file(s) in the application pictures directory and 2 audio reference(s) and 1 added plus 1 modified comment(s) in existing audio comment file(s) and the application settings from \"$restorableZipFilePathName\".\n\nDeleted 2 audio(s)\n  \"Omraam Mikhaël Aïvanhov - Prière - MonDieu je Te donne mon coeur!\",\n  \"L’uniforme arrive en France en 2024\"\nand their comment(s) and picture(s) as well as their MP3 file.\n\nDeleted 2 playlist(s)\n  \"local_1\",\n  \"local_2\"\nno longer present in the restore ZIP file and not created or modified after the ZIP creation.",
        isWarningConfirming: true,
        warningTitle: 'CONFIRMATION',
      );

      // Verify the restored picture files in the application
      // pictures directory

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
          "canari.jpg",
          "DesertCross.jpg",
          "Dieu-le-Père.jpg",
          "Screenshot_20250903_202601.jpg",
        ],
        directoryPath:
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName",
        fileExtension: 'jpg',
      );

      // Verify the picture application json map content

      pictureFileNamesLstOne = [
        "urgent_actus_17-12-2023|aaa",
      ];
      audioForPictureTitleLstTwo = [
        "urgent_actus_17-12-2023|250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13"
      ];
      audioForPictureTitleLstThree = [
        "local|240110-181805-Really short video 23-07-01",
        "urgent_actus_17-12-2023|250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07"
      ];
      List<String> audioForPictureTitleLstFour = [
        "local|240110-181810-morning _ cinematic video 23-07-01"
      ];
      List<String> audioForPictureTitleLstFive = [
        "urgent_actus_17-12-2023|converted"
      ];

      // Now verifying the audio picture addition result
      IntegrationTestUtil.verifyApplicationPictureJsonMap(
        applicationPictureDir: appPicturesDir,
        pictureFileNameOne: "Dieu-le-Père.jpg",
        audioForPictureTitleOneLst: pictureFileNamesLstOne,
        pictureFileNameTwo:
            "Bora_Bora_2560_1440_Youtube_2 - Voyage vers l'Inde intérieure.jpg",
        audioForPictureTitleTwoLst: audioForPictureTitleLstTwo,
        pictureFileNameThree: "Screenshot_20250903_202601.jpg",
        audioForPictureTitleThreeLst: audioForPictureTitleLstThree,
        pictureFileNameFour: "canari.jpg",
        audioForPictureTitleFourLst: audioForPictureTitleLstFour,
        pictureFileNameFive: "DesertCross.jpg",
        audioForPictureTitleFiveLst: audioForPictureTitleLstFive,
      );

      // Verify the restored picture json files of the
      // urgent_actus_17-12-2023 playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.json",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.json",
          "aaa.json",
          "converted.json",
        ],
        directoryPath: "$urgentActuPath${path.separator}$kPictureDirName",
        fileExtension: 'json',
      );

      // Verify the restored picture json files of the local playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.json",
        ],
        directoryPath: "$localPath${path.separator}$kPictureDirName",
        fileExtension: 'json',
      );

      // Verify the restored comment files of the
      // urgent_actus_17-12-2023 playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "aaa.json",
          "bbb.json",
          "converted.json",
        ],
        directoryPath: "$urgentActuPath${path.separator}$kCommentDirName",
        fileExtension: 'json',
      );

      // Verify the restored comment files of the local playlist

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "aaa.json",
          "converted_local.json",
        ],
        directoryPath: "$localPath${path.separator}$kCommentDirName",
        fileExtension: 'json',
      );

      mp3RestorableZipFilePathName =
          '$kApplicationPathWindowsTest${path.separator}restore_audioLearn_mp3.zip';

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: mp3RestorableZipFilePathName,
            path: mp3RestorableZipFilePathName,
            size: 6784843),
      ]);

      await IntegrationTestUtil.typeOnAppbarMenuItem(
        tester: tester,
        appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
      );

      // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
      await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
      await tester.pumpAndSettle();

      // Verify the displayed warning confirmation dialog
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Restored 2 audio(s) MP3 in 2 playlist(s) from the multiple playlists MP3 zip file \"$mp3RestorableZipFilePathName\".",
        isWarningConfirming: true,
      );

      // Verify the MP3 files in the playlists not deleted after
      // 2 audio's were deleted

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3",
          "250812-162933-DETTE PUBLIQUE  - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3",
          "aaa.mp3",
          "bbb.mp3",
          "converted.mp3",
        ],
        directoryPath: urgentActuPath,
        fileExtension: 'mp3',
      );

      IntegrationTestUtil.verifyFilesPresence(
        expectedFileNamesLst: [
          "240110-181805-Really short video 23-07-01.mp3",
          "240110-181810-morning _ cinematic video 23-07-01.mp3",
          "aaa.mp3",
          "converted_local.mp3",
        ],
        directoryPath: localPath,
        fileExtension: 'mp3',
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });

  group('Manage picture for audio', () {
    group('From audio list item in playlist download view', () {
      testWidgets(
          '''Add a picture to audio, then add another picture to the same audio. This
           will replace the existing picture. Then remove the audio picture and re-add
           a picture to the same audio.''', (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          tapOnPlaylistToggleButton: false,
        );

        const String localPlaylistTitle = 'local';
        final String playlistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";
        const String audioForPictureTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String audioForPictureTitleDurationStr = '40:53';
        const String pictureFileNameZero = "Jésus, mon amour.jpg";
        const String pictureFileName = "Jésus je T'adore.jpg";
        const int pictureFileSize = 154529;
        const String secondPictureFileName = "Jésus je T'aime.jpg";
        const int secondPictureFileSize = 125867;
        const String thirdPictureFileName = "Jésus l'Amour de ma vie.jpg";
        const int thirdPictureFileSize = 187362;

        // Available pictures file path
        String pictureSourcePath =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        // Select the local playlist whose audio we will add the picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // First picture addition
        String pictureFilePathName =
            await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFileName, // "Jésus je T'adore.jpg"
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: pictureFileSize,
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
        );

        List<String> audioForPictureTitleLstJesusMonAmour = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        List<String> audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        List<String> audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01"
        ];

        String playlistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";

        List<String> pictureFileNamesLst = [
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        // Now verifying the audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureJsonFilesDir,
          pictureFileNameOne: pictureFileNameZero, // "Jésus, mon amour.jpg"
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTaime,
          mustPlayableAudioListBeUsed: true,
        );

        // Now go back to the playlist download view and add another
        // picture to the same audio. This will replace the first added
        // picture by the second one.

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Second picture addition
        pictureFilePathName =
            await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: secondPictureFileName, // "Jésus je T'aime.jpg"
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: secondPictureFileSize,
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
        );

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureDir,
          pictureFileNameOne: pictureFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameTwo: pictureFileName, // "Jésus je T'adore.jpg"
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree: secondPictureFileName, // "Jésus je T'aime.jpg"
          audioForPictureTitleThreeLst: audioForPictureTitleLstJesusJeTaime,
          mustPlayableAudioListBeUsed: false,
        );

        // Now go back to the playlist download view and remove the
        // audio picture

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Deleting the added audio picture
        await _removeAudioPictureExecutingAudioListItemMenu(
          tester: tester,
          picturedAudioTitle: audioForPictureTitle,
        );

        await IntegrationTestUtil.verifyPictureSuppression(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureDir: playlistPictureDir,
          audioForPictureTitle: audioForPictureTitle,
          audioPictureJsonFileName:
              "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
          deletedPictureFileName: secondPictureFileName,
        );

        // Now go back to the playlist download view and add again a
        // picture to the same audio whose picture was removed

        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Third picture addition
        pictureFilePathName =
            await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName:
              thirdPictureFileName, // "Jésus l'Amour de ma vie.jpg"
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: thirdPictureFileSize,
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
        );

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureDir,
          pictureFileNameOne: pictureFilePathName,
          audioForPictureTitle: audioForPictureTitle, // CETTE SOEUR GUÉRIT ...
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets('''Add audio picture to other audio in same playlist.''',
          (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        const String youtubePlaylistTitle = 'Jésus-Christ';
        final String playlistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$youtubePlaylistTitle${path.separator}$kPictureDirName";
        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";
        const String audioForPictureTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String audioForPictureTitleDurationStr = '40:53';
        const String audioAlreadyUsingPictureTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';
        const String audioAlreadyUsingPictureDurationStr = '24:07';
        const String pictureFileNameZero = "Jésus, mon amour.jpg";
        const String pictureFileName = "Jésus, mon amour.jpg";
        const int pictureFileSize = 94507;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          selectedPlaylistTitle: youtubePlaylistTitle,
          tapOnPlaylistToggleButton: false,
        );

        // First picture addition
        await _addPictureToAudioExecutingAudioListItemMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFileName,
          pictureSourcePath: applicationPictureDir,
          pictureFileSize: pictureFileSize,
          audioForPictureTitle: audioForPictureTitle,
        );

        // Picture json files path
        String playlistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$youtubePlaylistTitle${path.separator}$kPictureDirName";

        List<String> pictureFileNamesLst = [
          '241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json',
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        List<String> audioForPictureTitleLst = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
          "Jésus-Christ|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        // Now verifying the audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureJsonFilesDir,
          pictureFileNameOne: pictureFileName,
          audioForPictureTitle: audioForPictureTitle,
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLst,
          mustPlayableAudioListBeUsed: true,
        );

        // Now go back to the playlist download view and add another
        // picture to the same audio. This will replace the first added
        // picture by the second one.

        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // Deleting the added audio picture
        await _removeAudioPictureExecutingAudioListItemMenu(
          tester: tester,
          picturedAudioTitle: audioForPictureTitle,
        );

        List<String> pictureFileNamesAfterDeletionLst = [
          '241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json',
        ];

        await IntegrationTestUtil.verifyPictureSuppression(
            tester: tester,
            applicationPictureDir: applicationPictureDir,
            playlistPictureDir: playlistPictureDir,
            audioForPictureTitle: audioForPictureTitle,
            audioPictureJsonFileName:
                "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
            deletedPictureFileName: "Jésus, mon amour.jpg",
            isPictureFileNameDeleted: true);

        // Go back to playlist download view in order to ensure that
        // the audio already using a picture was not impacted by
        // the previous picture suppression
        appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        List<String> audioForPictureTitleLstJesusMonAmour = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        // Verifying that the audio already using a picture was not
        // impacted by the previous picture suppression
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureJsonFilesDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioAlreadyUsingPictureTitle,
          audioForPictureTitleDurationStr: audioAlreadyUsingPictureDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesAfterDeletionLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          mustPlayableAudioListBeUsed: true,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('From appbar left popup menu in audio player view', () {
      testWidgets(
          '''Add a picture to audio, then add another picture to the same audio. This
           will replace the existing picture. Then delete the audio picture and re-add
           a picture to the same audio. The effects are identical to the previous test,
           but the actions are performed from the audio player view.''',
          (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          tapOnPlaylistToggleButton: false,
        );

        const String localPlaylistTitle = 'local';
        final String playlistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$localPlaylistTitle${path.separator}$kPictureDirName";
        const String audioForPictureTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String audioForPictureTitleDurationStr = '40:53';
        const String pictureFileNameZero = "Jésus, mon amour.jpg";
        const String pictureFileName = "Jésus je T'adore.jpg";
        const int pictureFileSize = 154529;
        const String secondPictureFileName = "Jésus je T'aime.jpg";
        const int secondPictureFileSize = 125867;
        const String thirdPictureFileName = "Jésus l'Amour de ma vie.jpg";
        const int thirdPictureFileSize = 187362;

        // Select the local playlist whose audio we will add the picture
        await IntegrationTestUtil.selectPlaylist(
          tester: tester,
          playlistToSelectTitle: localPlaylistTitle,
        );

        // Available pictures file path
        String pictureSourcePath =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        // Go to the audio player view
        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('audioPlayerViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Verify that the picture play/pause button is not present
        // since no picture is displayed.
        expect(
          find.byKey(const Key('picture_displayed_play_pause_button_key')),
          findsNothing,
        );

        // First picture addition
        await _addPictureToAudioExecutingAudioPlayerViewLeftAppbarMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFileName,
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: pictureFileSize,
        );

        List<String> audioForPictureTitleLstJesusMonAmour = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        List<String> audioForPictureTitleLstJesusJeTadore = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        List<String> audioForPictureTitleLstJesusLamourDeMaVie = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        List<String> audioForPictureTitleLstJesusJeTaime = [
          "local|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01"
        ];

        List<String> pictureFileNamesLst = [
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        // Now verifying the audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioForPictureTitle,
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureFileName,
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          goToAudioPlayerView: false,
          mustPlayableAudioListBeUsed: false,
        );

        // Now add another picture to the same audio. This will replace
        // the first added picture by the second one.

        // Second picture addition
        await _addPictureToAudioExecutingAudioPlayerViewLeftAppbarMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: secondPictureFileName,
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: secondPictureFileSize,
        );

        // Now verifying the second audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioForPictureTitle,
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureFileName,
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree: secondPictureFileName,
          audioForPictureTitleThreeLst: audioForPictureTitleLstJesusJeTaime,
          goToAudioPlayerView: false,
          mustPlayableAudioListBeUsed: false,
        );

        // Deleting the added audio picture
        await _removeAudioPictureInAudioPlayerView(
          tester: tester,
          picturedAudioTitle: audioForPictureTitle,
        );

        await IntegrationTestUtil.verifyPictureSuppression(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureDir: playlistPictureDir,
          audioForPictureTitle: audioForPictureTitle,
          audioPictureJsonFileName:
              "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
          deletedPictureFileName: "Jésus je T'aime.jpg",
          goToAudioPlayerView: false,
        );

        // Third picture addition
        await _addPictureToAudioExecutingAudioPlayerViewLeftAppbarMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: thirdPictureFileName,
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: thirdPictureFileSize,
        );

        // Now verifying the third audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioForPictureTitle,
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          audioForPictureTitleOneLst: audioForPictureTitleLstJesusMonAmour,
          pictureFileNameTwo: pictureFileName,
          audioForPictureTitleTwoLst: audioForPictureTitleLstJesusJeTadore,
          pictureFileNameThree: thirdPictureFileName,
          audioForPictureTitleThreeLst:
              audioForPictureTitleLstJesusLamourDeMaVie,
          goToAudioPlayerView: false,
          mustPlayableAudioListBeUsed: false,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Add audio picture to other audio in same playlist. The effects are
             identical to the previous test, but the actions are performed from
             the audio player view.''', (WidgetTester tester) async {
        // Replace the platform instance with your mock
        MockFilePicker mockFilePicker = MockFilePicker();
        FilePicker.platform = mockFilePicker;

        const String youtubePlaylistTitle = 'Jésus-Christ';
        final String playlistPictureDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$youtubePlaylistTitle${path.separator}$kPictureDirName";
        const String audioForPictureTitle =
            'CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien';
        const String audioForPictureTitleDurationStr = '40:53';
        const String audioAlreadyUsingPictureTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';
        const String audioAlreadyUsingPictureDurationStr = '24:07';
        const String pictureFileNameZero = "Jésus, mon amour.jpg";
        const String pictureFileName = "Jésus, mon amour.jpg";
        const int pictureFileSize = 94507;

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          selectedPlaylistTitle: youtubePlaylistTitle,
          tapOnPlaylistToggleButton: false,
        );

        // Available pictures file path
        String pictureSourcePath =
            "$kApplicationPathWindowsTest${path.separator}$youtubePlaylistTitle${path.separator}$kPictureDirName";

        // Go to the audio player view
        final Finder audioForPictureTitleListTileTextWidgetFinder =
            find.text(audioForPictureTitle);

        await tester.tap(audioForPictureTitleListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // First picture addition
        await _addPictureToAudioExecutingAudioPlayerViewLeftAppbarMenu(
          tester: tester,
          mockFilePicker: mockFilePicker,
          pictureFileName: pictureFileName,
          pictureSourcePath: pictureSourcePath,
          pictureFileSize: pictureFileSize,
        );

        // Picture json files path
        String playlistPictureJsonFilesDir =
            "$kApplicationPathWindowsTest${path.separator}playlists${path.separator}$youtubePlaylistTitle${path.separator}$kPictureDirName";

        List<String> pictureFileNamesLst = [
          '241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json',
          "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
        ];

        final String applicationPictureDir =
            "$kApplicationPathWindowsTest${path.separator}$kPictureDirName";

        List<String> audioForPictureTitleLst = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
          "Jésus-Christ|250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01",
        ];

        // Now verifying the audio picture addition result
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureJsonFilesDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioForPictureTitle,
          audioForPictureTitleDurationStr: audioForPictureTitleDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesLst,
          goToAudioPlayerView: false,
          audioForPictureTitleOneLst: audioForPictureTitleLst,
          mustPlayableAudioListBeUsed: false,
        );

        // Deleting the added audio picture
        await _removeAudioPictureInAudioPlayerView(
          tester: tester,
          picturedAudioTitle: audioForPictureTitle,
        );

        List<String> pictureFileNamesAfterDeletionLst = [
          '241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12.json',
        ];

        await IntegrationTestUtil.verifyPictureSuppression(
            tester: tester,
            applicationPictureDir: applicationPictureDir,
            playlistPictureDir: playlistPictureDir,
            audioForPictureTitle: audioForPictureTitle,
            audioPictureJsonFileName:
                "250103-125311-CETTE SOEUR GUÉRIT DES MILLIERS DE PERSONNES AU NOM DE JÉSUS !  Émission Carrément Bien 24-07-01.json",
            deletedPictureFileName: "Jésus, mon amour.jpg",
            isPictureFileNameDeleted: true);

        // Go back to playlist download view in order to ensure that
        // the audio already using a picture was not impacted by
        // the previous picture suppression
        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        audioForPictureTitleLst = [
          "Jésus-Christ|241210-073532-NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE 24-11-12",
        ];

        // Verifying that the audio already using a picture was not
        // impacted by the previous picture suppression
        await IntegrationTestUtil.verifyPictureAddition(
          tester: tester,
          applicationPictureDir: applicationPictureDir,
          playlistPictureJsonFilesDir: playlistPictureJsonFilesDir,
          pictureFileNameOne: pictureFileNameZero,
          audioForPictureTitle: audioAlreadyUsingPictureTitle,
          audioForPictureTitleDurationStr: audioAlreadyUsingPictureDurationStr,
          playlistAudioPictureJsonFileNameLst: pictureFileNamesAfterDeletionLst,
          audioForPictureTitleOneLst: audioForPictureTitleLst,
          mustPlayableAudioListBeUsed: true,
        );

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    group('Comment minimization for pictured or not audio', () {
      testWidgets(
          '''Click on the comment icon button after clicking on the pictured and commented audio title to open the
             audio player view. Then, the comment add list dialog is open. Verify that the play/pause button present
             when a picture is present was hidden since the comments dialog was opened. Then, minimize the comment
             add list dialog and verify that the play/pause button displayed when a picture is present remains hidden
             while the comments dialog is minimized. Finally, maximize the comment add list dialog and verify that
             the play/pause button displayed when a picture is present remains hidden while the comments dialog is
             open.
             
             Then, play the comment and minimize the comment add list dialog. Do that also with a comment whose end
             position corresponds to the audio end position.''',
          (WidgetTester tester) async {
        const String youtubePlaylistTitle = 'Jésus-Christ';
        const String audioAlreadyUsingPictureTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          selectedPlaylistTitle: youtubePlaylistTitle,
          tapOnPlaylistToggleButton: false,
        );

        // Go to the audio player view
        final Finder audioForPictureTitleListTileTextWidgetFinder =
            find.text(audioAlreadyUsingPictureTitle);

        await tester.tap(audioForPictureTitleListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Verify that the play/pause button displayed when a picture
        // is present is displayed in the top of audio player view.
        Finder playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsOneWidget);

        // Tap on the comment icon button to open the comment add list
        // dialog
        Finder commentInkWellButtonFinder = find.byKey(
          const Key('commentsInkWellButton'),
        );

        await tester.tap(commentInkWellButtonFinder);
        await tester.pumpAndSettle();

        // Now verify that the play/pause button displayed when a picture
        // is present was hidden since the comments dialog was opened.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Tap on the minimize icon button to minimize the comment add
        // list dialog
        Finder minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );

        await tester.tap(minimizeButtonFinder);
        await tester.pumpAndSettle();

        // Verify again that the play/pause button displayed when a picture
        // is present remains hidden while the comments dialog is minimized.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Then, tap on the maximize icon button to reset the comment
        // add list dialog
        Finder maximizeButtonFinder = find.byKey(
          const Key('maximizeCommentListAddDialogKey'),
        );

        await tester.tap(maximizeButtonFinder);
        await tester.pumpAndSettle();

        // Verify that the play/pause button displayed when a picture
        // is present remains hidden while the comments dialog is open.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Now play the comment and minimize the comment add list dialog.

        await IntegrationTestUtil.playCommentFromListAddDialog(
          tester: tester,
          commentPosition: 1,
          isCommentListAddDialogAlreadyOpen: true,
        );

        // Tap on the minimize icon button to minimize the comment add
        // list dialog
        minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );
        await tester.tap(minimizeButtonFinder);
        await tester.pumpAndSettle();

        // Wait for the comment to finish playing
        await Future.delayed(const Duration(seconds: 4));
        await tester.pumpAndSettle();

        // Verify the audio position and remaining duration text

        Text audioPositionText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioPosition')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioPositionText.data!,
          expectedPositionTimeStr: '23:46',
          plusMinusSeconds: 1,
        );

        Text audioRemainingDurationText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioRemainingDuration')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioRemainingDurationText.data!,
          expectedPositionTimeStr: '0:21',
          plusMinusSeconds: 1,
        );

        // Now, tap on the maximize icon button to reset the comment
        // add list dialog
        maximizeButtonFinder = find.byKey(
          const Key('maximizeCommentListAddDialogKey'),
        );
        await tester.tap(maximizeButtonFinder);
        await tester.pumpAndSettle();

        // Now play the comment whose end position corresponds to the
        // audio end.
        await IntegrationTestUtil.playCommentFromListAddDialog(
          tester: tester,
          commentPosition: 2,
          isCommentListAddDialogAlreadyOpen: true,
        );

        // Tap on the minimize icon button to minimize the comment add
        // list dialog
        minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );
        await tester.tap(minimizeButtonFinder);
        await tester.pumpAndSettle();

        // Wait for the comment to finish playing
        await Future.delayed(const Duration(seconds: 4));
        await tester.pumpAndSettle();

        // Verify the audio position and remaining duration text

        audioPositionText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioPosition')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioPositionText.data!,
          expectedPositionTimeStr: '24:07',
          plusMinusSeconds: 1,
        );

        audioRemainingDurationText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioRemainingDuration')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioRemainingDurationText.data!,
          expectedPositionTimeStr: '0:00',
          plusMinusSeconds: 1,
        );

        // Now, tap on the maximize icon button to reset the comment
        // add list dialog
        maximizeButtonFinder = find.byKey(
          const Key('maximizeCommentListAddDialogKey'),
        );
        await tester.tap(maximizeButtonFinder);
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
      testWidgets(
          '''Click on the 'Audio Comments ...' menu present in the audio player left appbar menu after clicking on
             the pictured and commented audio title to open the audio player view. Then, the comment add list dialog
             is open. Verify that the play/pause button present when
             a picture is present was hidden since the comments dialog was opened. Then, minimize the comment add
             list dialog and verify that the play/pause button displayed when a picture is present remains hidden
             while the comments dialog is minimized. Finally, maximize the comment add list dialog and verify that
             the play/pause button displayed when a picture is present remains hidden while the comments dialog is
             open.
             
             Then, play the comment and minimize the comment add list dialog. Do that also with a comment whose
             end position corresponds to the audio end position.''',
          (WidgetTester tester) async {
        const String youtubePlaylistTitle = 'Jésus-Christ';
        const String audioAlreadyUsingPictureTitle =
            'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';

        await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
          tester: tester,
          savedTestDataDirName: 'audio_player_picture_test',
          selectedPlaylistTitle: youtubePlaylistTitle,
          tapOnPlaylistToggleButton: false,
        );

        // Go to the audio player view
        final Finder audioForPictureTitleListTileTextWidgetFinder =
            find.text(audioAlreadyUsingPictureTitle);

        await tester.tap(audioForPictureTitleListTileTextWidgetFinder);
        await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
          tester: tester,
        );

        // Verify that the play/pause button displayed when a picture
        // is present is displayed in the top of audio player view.
        Finder playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsOneWidget);

        // Tap the appbar leading popup menu button Then, the'Audio
        // Comments ...' menu is selected.
        await IntegrationTestUtil.typeOnAppbarMenuItem(
          tester: tester,
          appbarMenuKeyStr: 'appbar_popup_menu_audio_comment',
        );

        // Now verify that the play/pause button displayed when a picture
        // is present was hidden since the comments dialog was opened.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Tap on the minimize icon button to minimize the comment add
        // list dialog
        Finder minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );

        await tester.tap(minimizeButtonFinder);
        await tester.pumpAndSettle();

        // Verify again that the play/pause button displayed when a picture
        // is present remains hidden while the comments dialog is minimized.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Then, tap on the maximize icon button to reset the comment
        // add list dialog
        Finder maximizeButtonFinder = find.byKey(
          const Key('maximizeCommentListAddDialogKey'),
        );

        await tester.tap(maximizeButtonFinder);
        await tester.pumpAndSettle();

        // Verify that the play/pause button displayed when a picture
        // is present remains hidden while the comments dialog is open.
        playPauseButtonFinder = find.byKey(
          const Key('picture_displayed_play_pause_button_key'),
        );
        expect(playPauseButtonFinder, findsNothing);

        // Now play the comment whose end position corresponds to the
        // audio end.
        await IntegrationTestUtil.playCommentFromListAddDialog(
          tester: tester,
          commentPosition: 2,
          isCommentListAddDialogAlreadyOpen: true,
        );

        // Tap on the minimize icon button to minimize the comment add
        // list dialog
        minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );
        await tester.tap(minimizeButtonFinder);
        await tester.pumpAndSettle();

        // Wait for the comment to finish playing
        await Future.delayed(const Duration(seconds: 4));
        await tester.pumpAndSettle();

        // Verify the audio position and remaining duration text

        Text audioPositionText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioPosition')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioPositionText.data!,
          expectedPositionTimeStr: '24:07',
          plusMinusSeconds: 1,
        );

        Text audioRemainingDurationText = tester.widget<Text>(
            find.byKey(const Key('audioPlayerViewAudioRemainingDuration')));

        IntegrationTestUtil.verifyPositionWithAcceptableDifferenceSeconds(
          tester: tester,
          actualPositionTimeStr: audioRemainingDurationText.data!,
          expectedPositionTimeStr: '0:00',
          plusMinusSeconds: 1,
        );

        // Now, tap on the maximize icon button to reset the comment
        // add list dialog
        maximizeButtonFinder = find.byKey(
          const Key('maximizeCommentListAddDialogKey'),
        );
        await tester.tap(maximizeButtonFinder);
        await tester.pumpAndSettle();

        // Now close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        // Click on the playlist download view icon button to go back to the
        // playlist download view
        Finder appScreenNavigationButton =
            find.byKey(const ValueKey('playlistDownloadViewIconButton'));
        await tester.tap(appScreenNavigationButton);
        await tester.pumpAndSettle();

        // First, find the Audio sublist ListTile Text widget of
        // 'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE'.
        Finder targetAudioListTileTextWidgetFinder =
            find.text(audioAlreadyUsingPictureTitle);

        // Then obtain the Audio ListTile widget enclosing the Text widget by
        // finding its ancestor
        Finder targetAudioListTileWidgetFinder = find.ancestor(
          of: targetAudioListTileTextWidgetFinder,
          matching: find.byType(ListTile),
        );

        // Now find the leading menu icon button of the Audio ListTile and tap
        // on it
        Finder targetAudioListTileLeadingMenuIconButton = find.descendant(
          of: targetAudioListTileWidgetFinder,
          matching: find.byIcon(Icons.menu),
        );

        // Tap the leading menu icon button to open the popup menu
        await tester.tap(targetAudioListTileLeadingMenuIconButton);
        await tester.pumpAndSettle();

        // Now find the popup menu item and tap on it
        final Finder popupDisplayAudioCommentMenuItemFinder =
            find.byKey(const Key("popup_menu_audio_comment"));

        await tester.tap(popupDisplayAudioCommentMenuItemFinder);
        await tester.pumpAndSettle();

        // Verify that no minimize icon button is displayed in the
        // comment add list dialog since the dialog isn't open in
        // the audio player view.
        minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );
        expect(minimizeButtonFinder, findsNothing);

        // Then close the comment list dialog
        await tester.tap(find.byKey(const Key('closeDialogTextButton')));
        await tester.pumpAndSettle();

        await IntegrationTestUtil.openPlaylistCommentDialog(
          tester: tester,
          playlistTitle: youtubePlaylistTitle,
        );

        // Verify that no minimize icon button is displayed in the
        // comment add list dialog since the dialog isn't open in
        // the audio player view.
        minimizeButtonFinder = find.byKey(
          const Key('minimizeCommentListAddDialogKey'),
        );
        expect(minimizeButtonFinder, findsNothing);

        // Then close the comment list dialog
        await tester.tap(
            find.byKey(const Key('playlistCommentListCloseDialogTextButton')));
        await tester.pumpAndSettle();

        // Purge the test playlist directory so that the created test
        // files are not uploaded to GitHub
        DirUtil.deleteFilesInDirAndSubDirs(
          rootPath: kApplicationPathWindowsTest,
        );
      });
    });
    testWidgets(
        '''Open the app in Android similar size and select the french language. Click on the comment icon button after
           clicking on the pictured and commented audio title to open the audio player view. Then, the comment add list
           dialog is opened. Verify that the create comment is usable to add a new comment. Since the french translation
           of 'Comments' is 'Commentaires' which requests more space than the english one, the comment add button was
           not clickable before this bug was fixed. This test is verify that the bug is fixed.''',
        (WidgetTester tester) async {
      const String youtubePlaylistTitle = 'Jésus-Christ';
      const String audioAlreadyUsingPictureTitle =
          'NE VOUS METTEZ PLUS JAMAIS EN COLÈRE _ SAGESSE CHRÉTIENNE';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'audio_player_picture_test',
        selectedPlaylistTitle: youtubePlaylistTitle,
        tapOnPlaylistToggleButton: false,
        setAppSizeToAndroidSize: true,
      );

      // First, set the application language to French
      await IntegrationTestUtil.setApplicationLanguage(
        tester: tester,
        language: Language.french,
      );

      // Go to the audio player view
      final Finder audioForPictureTitleListTileTextWidgetFinder =
          find.text(audioAlreadyUsingPictureTitle);

      await tester.tap(audioForPictureTitleListTileTextWidgetFinder);
      await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
        tester: tester,
      );

      // Tap on the comment icon button to open the comment list add
      // dialog

      Finder commentInkWellButtonFinder = find.byKey(
        const Key('commentsInkWellButton'),
      );

      await tester.tap(commentInkWellButtonFinder);
      await tester.pumpAndSettle();

      // Tap on the Add comment icon button to open the add edit comment
      // dialog
      await tester
          .tap(find.byKey(const Key('addPositionedCommentIconButtonKey')));
      await tester.pumpAndSettle();

      // Enter comment title text
      String commentTitle = 'New comment';
      final Finder textFieldFinder =
          find.byKey(const Key('commentTitleTextField'));

      await tester.enterText(
        textFieldFinder,
        commentTitle,
      );
      await tester.pumpAndSettle();

      // Enter comment text
      String commentText = 'New comment description';
      final Finder commentContentTextFieldFinder =
          find.byKey(const Key('commentContentTextField'));

      await tester.enterText(
        commentContentTextFieldFinder,
        commentText,
      );
      await tester.pumpAndSettle();

      // Tap on the add/edit comment button to save the comment

      final Finder addOrUpdateCommentTextButton =
          find.byKey(const Key('addOrUpdateCommentTextButton'));
      await tester.tap(addOrUpdateCommentTextButton);
      await tester.pumpAndSettle();

      // Verify that the comment list dialog now displays the
      // added comment

      final Finder commentListDialogFinder =
          find.byKey(const Key('audioCommentsListKey'));

      List<String> expectedTitles = [
        'New comment',
        '7ème leçon: rempli ton coeur de gratitude pour éteindre la colère',
        'Till end', // created comment
      ];

      List<String> expectedContents = [
        'New comment description', // created comment
        "Jusqu'à la fin.",
        '',
      ];

      List<String> expectedStartPositions = [
        '14:16', // created comment
        '23:42',
        '24:04',
      ];

      List<String> expectedEndPositions = [
        '14:16', // created comment
        '23:46',
        '24:08',
      ];

      List<String> expectedCreationDates = [
        frenchDateFormatYy.format(DateTime.now()), // created comment
        '13/12/24',
        '01/04/25',
      ];

      List<String> expectedUpdateDates = [
        '', // created comment
        '01/04/25',
        '',
      ];

      // Verify content of each list item
      IntegrationTestUtil.verifyCommentsInCommentListDialog(
          tester: tester,
          commentListDialogFinder: commentListDialogFinder,
          commentsNumber: 3,
          expectedTitlesLst: expectedTitles,
          expectedContentsLst: expectedContents,
          expectedStartPositionsLst: expectedStartPositions,
          expectedEndPositionsLst: expectedEndPositions,
          expectedCreationDatesLst: expectedCreationDates,
          expectedUpdateDatesLst: expectedUpdateDates);

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Change playlist audio quality tests', () {
    testWidgets(
        '''Spoken changed to musical quality. Then, restart the application to verify
           that the audio quality checkbox state was preserved.''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName:
            'sort_and_filter_audio_dialog_widget_newly_downloaded_playlist_test',
        tapOnPlaylistToggleButton: false,
      );

      const String youtubePlaylistToModifyTitle = 'MaValTest';

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: youtubePlaylistToModifyTitle,
        isPlaylistLocal: false,
        playlistQuality: PlaylistQuality.voice,
      );

      // Set playlist audio quality to musical. Then, the application is
      // restarted ...
      await _tapOnSetAudioQualityMenu(
        tester: tester,
        playlistToModifyTitle: youtubePlaylistToModifyTitle,
        setMusicQuality: true,
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: youtubePlaylistToModifyTitle,
        isPlaylistLocal: false,
        playlistQuality: PlaylistQuality.music,
      );
    });
    testWidgets(
        '''Restart the application to verify that the audio quality checkbox state was preserved.
           Then download one audio in the playlist and verify its audio musical quality. Then
           select the local playlist and restart the application.''',
        (WidgetTester tester) async {
      const String youtubePlaylistToModifyTitle = 'MaValTest';

      await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
        tester: tester,
        forcedLocale: const Locale('en'),
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: youtubePlaylistToModifyTitle,
        isPlaylistLocal: false,
        playlistQuality: PlaylistQuality.music,
      );

      // Now typing on the download playlist button to download the
      // an audio.
      await tester.tap(find.byKey(const Key('download_sel_playlists_button')));
      await tester.pumpAndSettle();

      await Future.delayed(const Duration(milliseconds: 1000));

      // Add a delay to allow the download to finish.
      for (int i = 0; i < 7; i++) {
        await Future.delayed(const Duration(seconds: 1));
        await tester.pumpAndSettle();
        // Now tap on Stop button to stop the download
        await tester.tap(find.byKey(const Key('stopDownloadingButton')));
        await tester.pumpAndSettle();
      }

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: youtubePlaylistToModifyTitle,
        validVideoTitleOrAudioTitle: 'Really short video',
        movedFromPlaylistTitle: '',
        movedToPlaylistTitle: '',
        copiedFromPlaylistTitle: '',
        copiedToPlaylistTitle: '',
        audioDuration: '0:00:09.8',
        isMusicQuality: true, // Is musical quality
      );

      const String localPlaylistTitle = 'local_audio';

      // Now selecting the local playlist by tapping on the
      // playlist checkbox and restart the application.
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: localPlaylistTitle,
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localPlaylistTitle,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.voice,
      );
    });
    testWidgets(
        '''Restart the app. The local playlist is selected and its quality will be set to
           musical. verify that the audio quality checkbox state was preserved.
           Then download one audio in the playlist and verify its audio musical quality. Then
           select the local playlist and restart the application.''',
        (WidgetTester tester) async {
      const String youtubePlaylistToModifyTitle = 'MaValTest';
      const String localSpokenPlaylistTitle = 'local_audio';

      await IntegrationTestUtil.launchIntegrTestAppEnablingInternetAccess(
        tester: tester,
        forcedLocale: const Locale('en'),
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localSpokenPlaylistTitle,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.voice,
      );

      // Set playlist audio quality to musical.
      await _tapOnSetAudioQualityMenu(
        tester: tester,
        playlistToModifyTitle: localSpokenPlaylistTitle,
        setMusicQuality: true,
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localSpokenPlaylistTitle,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.music,
      );

      const String singleVideoUrl = 'https://youtu.be/uv3VQoWSjBE';

      // Entering the single video URL in the Youtube URL or search text field
      // of the app
      await tester.enterText(
        find.byKey(
          const Key('youtubeUrlOrSearchTextField'),
        ),
        singleVideoUrl,
      );
      await tester.pumpAndSettle();

      // Open the target playlist selection dialog by tapping the
      // download single video button
      await tester.tap(find.byKey(const Key('downloadSingleVideoButton')));
      await tester.pumpAndSettle();

      // Find the RadioListTile target playlist to which the audio
      // will be downloaded

      Finder radioListTile = find
          .ancestor(
            of: find.text(localSpokenPlaylistTitle),
            matching: find.byType(ListTile),
          )
          .last;

      // Tap the target playlist RadioListTile to select it
      await tester.tap(radioListTile);
      await tester.pumpAndSettle();

      // Now find the confirm button and tap on it
      await tester.tap(find.byKey(const Key('confirmButton')));
      await tester.pumpAndSettle();

      // Verify the displayed alert dialog
      await IntegrationTestUtil.verifyAlertDisplayAndCloseIt(
        tester: tester,
        alertDialogMessage:
            "Confirm target playlist \"$localSpokenPlaylistTitle\" for downloading single video audio in high-quality music format.",
      );

      // Add a delay to allow the download to finish.
      await Future.delayed(const Duration(seconds: 7));
      await tester.pumpAndSettle();

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: localSpokenPlaylistTitle,
        validVideoTitleOrAudioTitle: 'audio learn test short video two',
        movedFromPlaylistTitle: '',
        movedToPlaylistTitle: '',
        copiedFromPlaylistTitle: '',
        copiedToPlaylistTitle: '',
        audioDuration: '0:00:09.8',
        isMusicQuality: true, // Is musical quality
      );

      // Re-set the unselected MyValTest playlist audio quality
      // to spoken and then select it to verify the state of the
      // audio quality checkbox.
      await _resetUnselectedPlaylistAudioQualityAndThenSelectPlaylist(
        tester: tester,
        playlistTitle: youtubePlaylistToModifyTitle,
        isPlaylistLocal: false,
        playlistQuality: PlaylistQuality.voice,
      );

      // Re-set the unselected 'local_audio' playlist audio quality
      // to spoken and then select it to verify the state of the
      // audio quality checkbox.
      await _resetUnselectedPlaylistAudioQualityAndThenSelectPlaylist(
        tester: tester,
        playlistTitle: localSpokenPlaylistTitle,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.voice,
      );

      // Now, re-select the 'MyValTest' playlist by tapping on the
      // playlist checkbox.
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: youtubePlaylistToModifyTitle,
      );

      // Now typing on the download playlist button to download the
      // an audio.
      await tester.tap(find.byKey(const Key('download_sel_playlists_button')));
      await tester.pumpAndSettle();

      await Future.delayed(const Duration(milliseconds: 1000));

      // Add a delay to allow the download to finish.
      for (int i = 0; i < 7; i++) {
        await Future.delayed(const Duration(seconds: 1));
        await tester.pumpAndSettle();
      }

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: youtubePlaylistToModifyTitle,
        validVideoTitleOrAudioTitle: 'morning _ cinematic video',
        movedFromPlaylistTitle: '',
        movedToPlaylistTitle: '',
        copiedFromPlaylistTitle: '',
        copiedToPlaylistTitle: '',
        audioDuration: '0:00:58.9',
        isMusicQuality: false, // Is musical quality
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Test playlist info modification', () {
    testWidgets(
        '''Verify playlist info. Then delete an audio and verify that the playlist info
           is updated accordingly.''', (WidgetTester tester) async {
      const String selectedPlaylistTitle = 'audio_player_view_2_shorts_test';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: '2_youtube_2_local_playlists_integr_test_data',
        selectedPlaylistTitle: selectedPlaylistTitle,
        tapOnPlaylistToggleButton: true,
      );

      // Verify the playlist info dialog content
      await IntegrationTestUtil.verifyPlaylistInfoDialogContent(
        tester: tester,
        playlistTitle: selectedPlaylistTitle,
        playlistDownloadAudioSortFilterParmsName: 'default',
        playlistPlayAudioSortFilterParmsName: 'default',
        isPaylistSelected: true,
        playlistInfoTotalAudioNumber: '2',
        playlistInfoPlayableAudioNumber: '2',
        playlistInfoAudioCommentNumber: '2',
        playlistInfoPlayableAudioTotalDuration: '0:01:09',
        playlistInfoPlayableAudioTotalRemainingDuration: '0:00:55',
        playlistInfoPlayableAudioTotalFileSize: '422 KB',
      );

      // Now we delete the 'Really short video' audio from the
      // 'audio_player_view_2_shorts_test' playlist.

      const String audioToDeleteTitle = 'Really short video';

      // First, find the Audio sublist ListTile Text widget
      final Finder uniqueAudioListTileTextWidgetFinder =
          find.text(audioToDeleteTitle);

      // Then obtain the Audio ListTile widget enclosing the Text widget by
      // finding its ancestor
      final Finder uniqueAudioListTileWidgetFinder = find.ancestor(
        of: uniqueAudioListTileTextWidgetFinder,
        matching: find.byType(ListTile),
      );

      // Now find the leading menu icon button of the Audio ListTile
      // and tap on it
      final Finder uniqueAudioListTileLeadingMenuIconButton = find.descendant(
        of: uniqueAudioListTileWidgetFinder,
        matching: find.byIcon(Icons.menu),
      );

      // Tap the leading menu icon button to open the popup menu
      await tester.tap(uniqueAudioListTileLeadingMenuIconButton);
      await tester.pumpAndSettle();

      // Now find the delete audio popup menu item and tap on it
      final Finder popupDeleteAudioMenuItem =
          find.byKey(const Key("popup_menu_delete_audio"));

      await tester.tap(popupDeleteAudioMenuItem);
      await tester.pumpAndSettle();

      // Tap on the confirm button to delete the audio
      await tester.tap(find.byKey(const Key('confirmButton')));
      await tester.pumpAndSettle();

      // After audio deletion, verify the playlist info dialog content
      await IntegrationTestUtil.verifyPlaylistInfoDialogContent(
        tester: tester,
        playlistTitle: selectedPlaylistTitle,
        playlistDownloadAudioSortFilterParmsName: 'default',
        playlistPlayAudioSortFilterParmsName: 'default',
        isPaylistSelected: true,
        playlistInfoTotalAudioNumber: '2',
        playlistInfoPlayableAudioNumber: '1',
        playlistInfoAudioCommentNumber: '1',
        playlistInfoPlayableAudioTotalDuration: '0:00:59',
        playlistInfoPlayableAudioTotalRemainingDuration: '0:00:54',
        playlistInfoPlayableAudioTotalFileSize: '360 KB',
      );
    });
  });
  group('''Import audio's functionality.''', () {
    testWidgets(
        '''Importing one text to speech audio test. Verify conversion warning. Then reimporting
          it and verify the not imported warning. Normally, the imported audio's are not located
          in a playlist directory !''', (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      const String selectedYoutubePlaylistTitle = 'urgent_actus_17-12-2023';
      const String localPlaylistTitle = 'local';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'import_audios_integr_test',
        selectedPlaylistTitle: selectedYoutubePlaylistTitle,
        tapOnPlaylistToggleButton: false,
      );

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      const String fileName_5 = "bbb.mp3";
      const String fileNameNoExt = "bbb";

      // Setting one selected mp3 file.
      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: fileName_5,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedYoutubePlaylistTitle${path.separator}$fileName_5",
            size: 155136),
      ]);

      DateTime importDateTime = DateTime.now();

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: localPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_import_audio_in_playlist',
      );

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Audio(s)\n\n\"$fileName_5\"\n\nimported to local playlist \"$localPlaylistTitle\".",
        isWarningConfirming: true,
      );

      // Re-import the same audio to verify the not imported warning
      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: localPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_import_audio_in_playlist',
      );

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Audio(s)\n\n\"$fileName_5\"\n\nNOT imported to local playlist \"$localPlaylistTitle\" since the playlist directory already contains the audio(s).",
      );

      // Select the local playlist to verify that the imported audio is present
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: localPlaylistTitle,
      );

      // Verifying all audio info dialog fields related of the imported audio
      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioType: AudioType.imported,
        validVideoTitleOrAudioTitle: fileNameNoExt,
        audioDownloadDateTime:
            '${DateFormat('dd/MM/yyyy').format(importDateTime)} ${DateFormat('HH:mm').format(importDateTime)}', // this is the imported date time
        isAudioPlayable: true,
        audioEnclosingPlaylistTitle: localPlaylistTitle,
        audioDuration: '0:00:19.3',
        audioPosition: '0:00:00',
        audioState: 'Not listened',
        lastListenDateTime: '',
        audioFileName: fileName_5,
        audioFileSize: '155 KB',
        isMusicQuality: false, // Is spoken quality
        audioPlaySpeed: '1.25',
        audioVolume: '50.0 %',
        audioCommentNumber: 0,
      );

      // Verify the imported audio sub title in the selected Youtube
      // playlist audio list
      IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
        tester: tester,
        audioSubTitlesAcceptableLst: [
          '0:00:19.3 155 KB imported on ${DateFormat('dd/MM/yyyy').format(importDateTime)} at ${DateFormat('HH:mm').format(importDateTime)}', // this is the imported date time
        ],
        firstAudioListTileIndex: 2,
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''2 audio's present in the source playlist exist in the playlist which will import
          all audio's of the source playlist. This situation will display 2 warnings, a
          audio import confirmation and a already existing audio's not imported warning.
          Normally, the imported audio's are not located in a playlist !''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      const String selectedPlaylistTitle = 'urgent_actus_17-12-2023';
      const String localPlaylistTitle = 'local';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'import_audios_integr_test',
        selectedPlaylistTitle: selectedPlaylistTitle,
        tapOnPlaylistToggleButton: false,
      );

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      const String fileName_1 =
          "250812-162925-NOUVEAU CHAPITRE POUR ETHEREUM - L'IDÉE GÉNIALE DE VITALIK! ACTUS CRYPTOMONNAIES 13_12 23-12-13.mp3";
      const String fileName_2 =
          "250812-162929-L’uniforme arrive en France en 2024 23-12-11.mp3";
      const String fileName_3 =
          "250812-162933-DETTE PUBLIQUE - LA RÉALITÉ DERRIÈRE LES DISCOURS CATASTROPHISTES 23-11-07.mp3";
      const String fileName_4 = "aaa.mp3";
      const String fileName_5 = "bbb.mp3";

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: fileName_1,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_1",
            size: 176640),
        PlatformFile(
            name: fileName_2,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_2",
            size: 183552),
        PlatformFile(
            name: fileName_3,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_3",
            size: 176640),
        PlatformFile(
            name: fileName_4,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_4",
            size: 175296),
        PlatformFile(
            name: fileName_5,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_5",
            size: 155136),
      ]);

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: localPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_import_audio_in_playlist',
      );

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Audio(s)\n\n\"$fileName_1\",\n\"$fileName_2\",\n\"$fileName_5\"\n\nimported to local playlist \"$localPlaylistTitle\".",
        isWarningConfirming: true,
      );

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Audio(s)\n\n\"$fileName_3\",\n\"$fileName_4\"\n\nNOT imported to local playlist \"$localPlaylistTitle\" since the playlist directory already contains the audio(s).",
      );

      // Re-import the same audio's to verify the not imported warning\

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: fileName_1,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_1",
            size: 176640),
        PlatformFile(
            name: fileName_2,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_2",
            size: 183552),
        PlatformFile(
            name: fileName_3,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_3",
            size: 176640),
        PlatformFile(
            name: fileName_4,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_4",
            size: 175296),
        PlatformFile(
            name: fileName_5,
            path:
                "$kPlaylistDownloadRootPathWindowsTest${path.separator}$selectedPlaylistTitle${path.separator}$fileName_5",
            size: 155136),
      ]);

      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: localPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_import_audio_in_playlist',
      );

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "Audio(s)\n\n\"$fileName_1\",\n\"$fileName_2\",\n\"$fileName_3\",\n\"$fileName_4\",\n\"$fileName_5\"\n\nNOT imported to local playlist \"$localPlaylistTitle\" since the playlist directory already contains the audio(s).",
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('''Convert text to audio.''', () {
    testWidgets(
        '''On selected playlist, add a text to speech audio. Verify the text to speech dialog appearance.
          Then enter a text with case ( { ) characters. Verify the Listen Create MP3 button state. Listen and
          Stop the text. Then listen the full text and verify the listen duration after which the Stop
          button is reset to the Listen button. Then, create the MP3 audio and verify its presence in the
          playlist audio list. Verify also the audio info dialog content of the converted audio. Then, verify
          the added comment in relation with the text to audio conversion.

          Finally, redo a text to speech conversion with a different text and save it to the same MP3 file
          name. Do the same verifications as previously.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      const String selectedYoutubePlaylistTitle = 'urgent_actus_17-12-2023';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'import_audios_integr_test',
        tapOnPlaylistToggleButton: false,
      );

      // Open the convert text to audio dialog
      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: selectedYoutubePlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
      );

      // Verify the convert text to audio dialog title
      final Text convertTextToAudioDialogTitle = tester.widget<Text>(
          find.byKey(const Key('convertTextToAudioDialogTitleKey')));
      expect(
        convertTextToAudioDialogTitle.data,
        'Convert Text to Audio',
      );

      // Verify the presence of the help icon button
      expect(find.byIcon(Icons.help_outline), findsOneWidget);

      // Verify the text to convert title
      final Text textToConvert =
          tester.widget<Text>(find.byKey(const Key('textToConvertTitleKey')));
      expect(
        textToConvert.data,
        'Text to convert, { = silence',
      );

      // Verify the voice selection title
      final Text conversionVoiceSelection =
          tester.widget<Text>(find.byKey(const Key('voiceSelectionTitleKey')));
      expect(
        conversionVoiceSelection.data,
        'Voice selection:',
      );

      // Verify the voice selection checkboxes

      final Finder masculineCheckbox =
          find.byKey(const Key('masculineVoiceCheckbox'));
      Finder feminineCheckbox = find.byKey(const Key('femineVoiceCheckbox'));

      // Initially masculine should be selected
      expect(
        (tester.widget(masculineCheckbox) as Checkbox).value,
        true,
      );
      expect(
        (tester.widget(feminineCheckbox) as Checkbox).value,
        false,
      );

      // Tap the feminine checkbox
      await tester.tap(feminineCheckbox);
      await tester.pump();

      // Verify state changed to feminine
      expect(
        (tester.widget(masculineCheckbox) as Checkbox).value,
        false,
      );
      expect(
        (tester.widget(feminineCheckbox) as Checkbox).value,
        true,
      );

      // Tap masculine checkbox back
      await tester.tap(masculineCheckbox);
      await tester.pump();

      // Verify state changed back to masculine
      expect(
        (tester.widget(masculineCheckbox) as Checkbox).value,
        true,
      );
      expect(
        (tester.widget(feminineCheckbox) as Checkbox).value,
        false,
      );

      // Enter and then delete a text to convert

      // Verify the presence of the hint text in the TextField
      expect(find.text('Enter your text here ...'), findsOneWidget);

      // Find the text field and delete button
      final Finder textFieldFinder =
          find.byKey(const Key('textToConvertTextField'));
      final Finder textFieldDeleteButtonFFinder =
          find.byKey(const Key('deleteTextToConvertIconButton'));

      // Verify the disabled state of the Listen and Create MP3 buttons
      await _verifyListenAndCreateMp3ButtonsState(
        tester: tester,
        areEnabled: false,
      );

      // Enter text in the TextField
      const testText = 'Ceci est un texte à supprimer.';
      await tester.enterText(textFieldFinder, testText);
      await tester.pump();

      // Verify the text was entered
      expect(find.text(testText), findsOneWidget);

      // Verify the TextField controller has the text
      final textFieldWidget = tester.widget<TextField>(textFieldFinder);
      expect(textFieldWidget.controller!.text, testText);

      // Verify the enabled state of the Listen and Create MP3 buttons
      await _verifyListenAndCreateMp3ButtonsState(
        tester: tester,
        areEnabled: true,
      );

      // Tap the delete button
      await tester.tap(textFieldDeleteButtonFFinder);
      await tester.pump();

      // Verify the text field is now empty
      expect(textFieldWidget.controller!.text, isEmpty);
      expect(find.text(testText), findsNothing);

      // Verify the TextField is focused after clearing (as per your implementation)
      expect(
          tester.binding.focusManager.primaryFocus, textFieldWidget.focusNode);

      // Verify the presence of the hint text in the TextField
      await tester.pumpAndSettle();
      expect(find.text('Enter your text here ...'), findsOneWidget);

      // Verify the again disabled state of the Listen and Create MP3 buttons
      await _verifyListenAndCreateMp3ButtonsState(
        tester: tester,
        areEnabled: false,
      );

      // Now enter a text to convert and listen it, verifying its
      // between 8 and 9 second duration

      const String initialTextToConvertStr = "{{ un {{{ deux { trois.";
      await tester.enterText(textFieldFinder, initialTextToConvertStr);
      await tester.pump();

      // Tap on the listen button
      final Finder listenButton = find.byKey(const Key('listen_text_button'));
      await tester.tap(listenButton);
      await tester.pumpAndSettle();

      // Verify button changed to Stop button
      TextButton stopButtonWidget = tester.widget(listenButton);
      Row stopButtonRow = stopButtonWidget.child as Row;
      Icon stopIcon = (stopButtonRow.children[0] as Icon);
      expect(stopIcon.icon, Icons.stop); // Stop icon

      // Now, tap on the Stop button after 1 seconds
      await Future.delayed(const Duration(seconds: 1));
      await tester.tap(listenButton);
      await tester.pumpAndSettle();

      // Verify the Stop button changed back to Listen button
      TextButton listenButtonWidget = tester.widget(listenButton);
      Row listenButtonRow = listenButtonWidget.child as Row;
      Icon listenIcon = (listenButtonRow.children[0] as Icon);
      expect(listenIcon.icon, Icons.volume_up); // Back to Listen icon

      // Now, tap again on the Listen button and let the audio
      // play to its end
      await tester.tap(listenButton);
      await tester.pumpAndSettle();

      // Add a delay to allow the audio to reach its end and the next audio
      // to start playing.
      for (int i = 0; i < 11; i++) {
        await Future.delayed(const Duration(seconds: 1));
        await tester.pumpAndSettle();
      }

      // Final verification - the Stop button changed to Listen button
      TextButton finalButtonWidget = tester.widget(listenButton);
      Row finalButtonRow = finalButtonWidget.child as Row;
      Icon finalIcon = (finalButtonRow.children[0] as Icon);
      expect(finalIcon.icon, Icons.volume_up); // Back to Listen icon

      // Now click on Create MP3 button to create the audio
      Finder createMP3ButtonFinder =
          find.byKey(const Key('create_audio_file_button'));
      await tester.tap(createMP3ButtonFinder);
      await tester.pumpAndSettle();

      // Verify the convert text to audio dialog title
      expect(
        find.text('MP3 File Name'),
        findsOneWidget,
      );

      // Verify the text to convert title
      expect(
        find.text('Enter the MP3 file name'),
        findsOneWidget,
      );

      // Verify the presence of the hint text in the MP3 file name
      // TextField
      expect(find.text('file name'), findsOneWidget);
      expect(find.text('.mp3'), findsOneWidget);

      const String enteredFileNameNoExt = 'convertedAudio';
      Finder mp3FileNameTextFieldFinder =
          find.byKey(const Key('textToConvertTextField'));

      await tester.enterText(mp3FileNameTextFieldFinder, enteredFileNameNoExt);
      await tester.pump();

      // Verify the text was entered
      expect(find.text(enteredFileNameNoExt), findsOneWidget);

      DateTime now = DateTime.now();

      // Tap on the create mp3 button
      Finder saveMP3FileButton = find.byKey(const Key('create_mp3_button_key'));
      await tester.tap(saveMP3FileButton);
      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas added to Youtube playlist \"$selectedYoutubePlaylistTitle\".",
        isWarningConfirming: true,
      );

      // Now close the convert text to audio dialog by tapping
      // the Cancel button
      Finder cancelButtonFinder =
          find.byKey(const Key('convertTextToAudioCancelButton'));
      await tester.tap(cancelButtonFinder);
      await tester.pumpAndSettle();

      // Verify the converted audio sub title in the selected Youtube
      // playlist audio list
      IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
        tester: tester,
        audioSubTitlesAcceptableLst: [
          '0:00:07.0 56 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now.subtract(const Duration(seconds: 1)))}',
          '0:00:07.0 56 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now)}',
        ],
        firstAudioListTileIndex: 4,
      );

      // Go to the audio player view and verify the audio position
      // and duration of the converted audio
      await _inAudioPlayerViewVerifyAudioPositionAndDuration(
        tester: tester,
        audioTitle: enteredFileNameNoExt,
        audioStartPosition: '0:00',
        audioEndPosition: '0:07',
        audioDuration: '0:07',
      );

      // Verifying all audio info dialog fields related of the
      // converted audio type
      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioType: AudioType.textToSpeech,
        validVideoTitleOrAudioTitle: enteredFileNameNoExt,
        audioDownloadDateTime:
            '${DateFormat('dd/MM/yyyy').format(now)} ${DateFormat('HH:mm').format(now)}', // this is the imported date time
        isAudioPlayable: true,
        audioEnclosingPlaylistTitle: selectedYoutubePlaylistTitle,
        audioDuration: '0:00:07.0',
        audioPosition: '0:00:00',
        audioState: 'Not listened',
        lastListenDateTime: '',
        audioFileName: '$enteredFileNameNoExt.mp3',
        audioFileSize: '56 KB',
        isMusicQuality: false, // Is spoken quality
        audioPlaySpeed: '1.25',
        audioVolume: '50.0 %',
        audioCommentNumber: 1,
      );

      // Now, we verify the created comment showing the converted
      // audio text

      // First, find the Youtube playlist audio ListTile Text widget
      Finder audioTitleTileTextWidgetFinder = find.text(enteredFileNameNoExt);

      // Then obtain the audio ListTile widget enclosing the Text widget
      // by finding its ancestor
      Finder audioTitleTileWidgetFinder = find.ancestor(
        of: audioTitleTileTextWidgetFinder,
        matching: find.byType(ListTile),
      );

      // Now we want to tap the popup menu of the audioTitle ListTile

      // Find the leading menu icon button of the audioTitle ListTile
      // and tap on it
      Finder audioTitleTileLeadingMenuIconButton = find.descendant(
        of: audioTitleTileWidgetFinder,
        matching: find.byIcon(Icons.menu),
      );

      // Tap the leading menu icon button to open the popup menu
      await tester.tap(audioTitleTileLeadingMenuIconButton);
      await tester.pumpAndSettle();

      // Now find the 'Audio Comments ...' popup menu item and
      // tap on it
      Finder audioCommentsPopupMenuItem =
          find.byKey(const Key("popup_menu_audio_comment"));

      await tester.tap(audioCommentsPopupMenuItem);
      await tester.pumpAndSettle();

      // Verify that the audio comments list of the dialog has 1 comment
      // item

      Finder audioCommentsLstFinder = find.byKey(const Key(
        'audioCommentsListKey',
      ));

      // Ensure the list has one child widgets
      expect(
        tester.widget<ListBody>(audioCommentsLstFinder).children.length,
        1,
      );

      List<String> expectedTitles = [
        'Text',
      ];

      List<String> expectedContents = [
        initialTextToConvertStr,
      ];

      List<String> expectedStartPositions = [
        '0:00',
      ];

      List<String> expectedEndPositions = [
        '0:07',
      ];

      List<String> expectedCreationDates = [
        frenchDateFormatYy.format(DateTime.now()), // created comment
      ];

      List<String> expectedUpdateDates = [
        '',
      ];

      // Verify content of each list item
      IntegrationTestUtil.verifyCommentsInCommentListDialog(
          tester: tester,
          commentListDialogFinder: audioCommentsLstFinder,
          commentsNumber: 1,
          expectedTitlesLst: expectedTitles,
          expectedContentsLst: expectedContents,
          expectedStartPositionsLst: expectedStartPositions,
          expectedEndPositionsLst: expectedEndPositions,
          expectedCreationDatesLst: expectedCreationDates,
          expectedUpdateDatesLst: expectedUpdateDates);

      // Now close the comment list dialog
      await tester.tap(find.byKey(const Key('closeDialogTextButton')));
      await tester.pumpAndSettle(const Duration(milliseconds: 700));

      // Now, reopen the convert text to audio dialog
      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: selectedYoutubePlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
      );

      // Now enter a new text to convert
      const String nextTextToConvertStr = "un deux trois.";
      await tester.enterText(textFieldFinder, nextTextToConvertStr);
      await tester.pump();

      // Tap the feminine checkbox to change the voice
      await tester.tap(feminineCheckbox);
      await tester.pump();

      // Now click on Create MP3 button to create the audio
      createMP3ButtonFinder = find.byKey(const Key('create_audio_file_button'));
      await tester.tap(createMP3ButtonFinder);
      await tester.pumpAndSettle();

      // Enter the same mp3 file name as before
      mp3FileNameTextFieldFinder =
          find.byKey(const Key('textToConvertTextField'));

      await tester.enterText(mp3FileNameTextFieldFinder, enteredFileNameNoExt);
      await tester.pump();

      now = DateTime.now();

      // Tap on the create mp3 button
      saveMP3FileButton = find.byKey(const Key('create_mp3_button_key'));
      await tester.tap(saveMP3FileButton);
      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      // Now check the confirm dialog which indicates that the saved
      // file name already exist and ask to confirm or cancel the
      // save operation.
      await IntegrationTestUtil.verifyConfirmActionDialog(
        tester: tester,
        confirmActionDialogTitle:
            "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$selectedYoutubePlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
        confirmActionDialogMessagePossibleLst: [""],
        closeDialogWithConfirmButton: true,
      );

      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in Youtube playlist \"$selectedYoutubePlaylistTitle\".",
        isWarningConfirming: true,
      );

      // Now close the convert text to audio dialog by tapping
      // the Cancel button
      cancelButtonFinder =
          find.byKey(const Key('convertTextToAudioCancelButton'));
      await tester.tap(cancelButtonFinder);
      await tester.pumpAndSettle();

      // Verify the converted audio sub title in the selected Youtube
      // playlist audio list
      IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
        tester: tester,
        audioSubTitlesAcceptableLst: [
          '0:00:00.8 6 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now.subtract(const Duration(seconds: 1)))}',
          '0:00:00.8 6 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now)}',
        ],
        firstAudioListTileIndex: 3,
      );

      // Go to the audio player view and verify the audio position
      // and duration of the converted audio
      await _inAudioPlayerViewVerifyAudioPositionAndDuration(
        tester: tester,
        audioTitle: enteredFileNameNoExt,
        audioStartPosition: '0:00',
        audioEndPosition: '0:01',
        audioDuration: '0:01',
      );

      // Verifying all audio info dialog fields related of the
      // converted audio type
      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioType: AudioType.textToSpeech,
        validVideoTitleOrAudioTitle: enteredFileNameNoExt,
        audioDownloadDateTime:
            '${DateFormat('dd/MM/yyyy').format(now)} ${DateFormat('HH:mm').format(now)}', // this is the imported date time
        isAudioPlayable: true,
        audioEnclosingPlaylistTitle: selectedYoutubePlaylistTitle,
        audioDuration: '0:00:00.8',
        audioPosition: '0:00:00',
        audioState: 'Not listened',
        lastListenDateTime: '',
        audioFileName: '$enteredFileNameNoExt.mp3',
        audioFileSize: '6 KB',
        isMusicQuality: false, // Is spoken quality
        audioPlaySpeed: '1.25',
        audioVolume: '50.0 %',
        audioCommentNumber: 2,
      );

      // Now, we verify the second created comment showing the new
      // converted audio text

      // First, find the Youtube playlist audio ListTile Text widget
      audioTitleTileTextWidgetFinder = find.text(enteredFileNameNoExt);

      // Then obtain the audio ListTile widget enclosing the Text widget
      // by finding its ancestor
      audioTitleTileWidgetFinder = find.ancestor(
        of: audioTitleTileTextWidgetFinder,
        matching: find.byType(ListTile),
      );

      // Now we want to tap the popup menu of the audioTitle ListTile

      // Find the leading menu icon button of the audioTitle ListTile
      // and tap on it
      audioTitleTileLeadingMenuIconButton = find.descendant(
        of: audioTitleTileWidgetFinder,
        matching: find.byIcon(Icons.menu),
      );

      // Tap the leading menu icon button to open the popup menu
      await tester.tap(audioTitleTileLeadingMenuIconButton);
      await tester.pumpAndSettle();

      // Now find the 'Audio Comments ...' popup menu item and
      // tap on it
      audioCommentsPopupMenuItem =
          find.byKey(const Key("popup_menu_audio_comment"));

      await tester.tap(audioCommentsPopupMenuItem);
      await tester.pumpAndSettle();

      // Verify that the audio comments list of the dialog has 2 comment
      // items

      audioCommentsLstFinder = find.byKey(const Key(
        'audioCommentsListKey',
      ));

      // Ensure the list has one child widgets
      expect(
        tester.widget<ListBody>(audioCommentsLstFinder).children.length,
        2,
      );

      expectedTitles = [
        'Text',
        'Text',
      ];

      expectedContents = [
        initialTextToConvertStr,
        nextTextToConvertStr,
      ];

      expectedStartPositions = [
        '0:00',
        '0:00',
      ];

      expectedEndPositions = [
        '0:07',
        '0:01',
      ];

      expectedCreationDates = [
        frenchDateFormatYy.format(DateTime.now()), // created comment
        frenchDateFormatYy.format(DateTime.now()), // created comment
      ];

      expectedUpdateDates = [
        '',
        '',
      ];

      // Verify content of each list item
      IntegrationTestUtil.verifyCommentsInCommentListDialog(
          tester: tester,
          commentListDialogFinder: audioCommentsLstFinder,
          commentsNumber: 2,
          expectedTitlesLst: expectedTitles,
          expectedContentsLst: expectedContents,
          expectedStartPositionsLst: expectedStartPositions,
          expectedEndPositionsLst: expectedEndPositions,
          expectedCreationDatesLst: expectedCreationDates,
          expectedUpdateDatesLst: expectedUpdateDates);

      // Now close the comment list dialog
      await tester.tap(find.byKey(const Key('closeDialogTextButton')));
      await tester.pumpAndSettle();

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets(
        '''On unselected playlist, add a text to speech audio. Verify the text to speech dialog appearance.
          Then enter a text with case ( { ) characters. Verify the Listen Create MP3 button state. Listen and
          Stop the text. Then listen the full text and verify the listen duration after which the Stop
          button is reset to the Listen button. Then, create the MP3 audio and verify its presence in the
          playlist audio list. Verify also the audio info dialog content of the converted audio. Then, verify
          the added comment in relation with the text to audio conversion.

          Finally, redo a text to speech conversion with a different text and save it to the same MP3 file
          name. Do the same verifications as previously.''',
        (WidgetTester tester) async {
      // Purge the test playlist directory if it exists so that the
      // playlist list is empty
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );

      const String unselectedLocalPlaylistTitle = 'local';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'import_audios_integr_test',
        tapOnPlaylistToggleButton: false,
      );

      // Open the convert text to audio dialog
      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: unselectedLocalPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
      );

      // Verify the convert text to audio dialog title
      final Text convertTextToAudioDialogTitle = tester.widget<Text>(
          find.byKey(const Key('convertTextToAudioDialogTitleKey')));
      expect(
        convertTextToAudioDialogTitle.data,
        'Convert Text to Audio',
      );

      // Now enter a text to convert and listen it, verifying its
      // between 8 and 9 second duration

      // Find the text field finder
      final Finder textFieldFinder =
          find.byKey(const Key('textToConvertTextField'));

      const String initialTextToConvertStr = "{{ un {{{ deux { trois.";
      await tester.enterText(textFieldFinder, initialTextToConvertStr);
      await tester.pump();

      // Tap on the listen button
      final Finder listenButton = find.byKey(const Key('listen_text_button'));
      await tester.tap(listenButton);
      await tester.pumpAndSettle();

      // Verify button changed to Stop button
      TextButton stopButtonWidget = tester.widget(listenButton);
      Row stopButtonRow = stopButtonWidget.child as Row;
      Icon stopIcon = (stopButtonRow.children[0] as Icon);
      expect(stopIcon.icon, Icons.stop); // Stop icon

      // Now, tap on the Stop button after 1 seconds
      await Future.delayed(const Duration(seconds: 1));
      await tester.tap(listenButton);
      await tester.pumpAndSettle();

      // Verify the Stop button changed back to Listen button
      TextButton listenButtonWidget = tester.widget(listenButton);
      Row listenButtonRow = listenButtonWidget.child as Row;
      Icon listenIcon = (listenButtonRow.children[0] as Icon);
      expect(listenIcon.icon, Icons.volume_up); // Back to Listen icon

      // Now click on Create MP3 button to create the audio
      Finder createMP3ButtonFinder =
          find.byKey(const Key('create_audio_file_button'));
      await tester.tap(createMP3ButtonFinder);
      await tester.pumpAndSettle();

      // Verify the convert text to audio dialog title
      expect(
        find.text('MP3 File Name'),
        findsOneWidget,
      );

      // Verify the text to convert title
      expect(
        find.text('Enter the MP3 file name'),
        findsOneWidget,
      );

      // Verify the presence of the hint text in the MP3 file name
      // TextField
      expect(find.text('file name'), findsOneWidget);
      expect(find.text('.mp3'), findsOneWidget);

      const String enteredFileNameNoExt = 'convertedAudio';
      Finder mp3FileNameTextFieldFinder =
          find.byKey(const Key('textToConvertTextField'));

      await tester.enterText(mp3FileNameTextFieldFinder, enteredFileNameNoExt);
      await tester.pumpAndSettle();

      // Verify the text was entered
      expect(find.text(enteredFileNameNoExt), findsOneWidget);

      DateTime now = DateTime.now();

      // Tap on the create mp3 button
      Finder saveMP3FileButton = find.byKey(const Key('create_mp3_button_key'));
      await tester.tap(saveMP3FileButton);
      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas added to local playlist \"$unselectedLocalPlaylistTitle\".",
        isWarningConfirming: true,
      );

      // Now close the convert text to audio dialog by tapping
      // the Cancel button
      Finder cancelButtonFinder =
          find.byKey(const Key('convertTextToAudioCancelButton'));
      await tester.tap(cancelButtonFinder);
      await tester.pumpAndSettle();

      // Now select the 'local' playlist
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: unselectedLocalPlaylistTitle,
      );

      // Verify the converted audio sub title in the selected Youtube
      // playlist audio list
      IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
        tester: tester,
        audioSubTitlesAcceptableLst: [
          '0:00:07.0 56 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now.subtract(const Duration(seconds: 1)))}',
          '0:00:07.0 56 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now)}',
        ],
        firstAudioListTileIndex: 2,
      );

      // Verifying all audio info dialog fields related of the
      // converted audio type
      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioType: AudioType.textToSpeech,
        validVideoTitleOrAudioTitle: enteredFileNameNoExt,
        audioDownloadDateTime:
            '${DateFormat('dd/MM/yyyy').format(now)} ${DateFormat('HH:mm').format(now)}', // this is the imported date time
        isAudioPlayable: true,
        audioEnclosingPlaylistTitle: unselectedLocalPlaylistTitle,
        audioDuration: '0:00:07.0',
        audioPosition: '0:00:00',
        audioState: 'Not listened',
        lastListenDateTime: '',
        audioFileName: '$enteredFileNameNoExt.mp3',
        audioFileSize: '56 KB',
        isMusicQuality: false, // Is spoken quality
        audioPlaySpeed: '1.25',
        audioVolume: '50.0 %',
        audioCommentNumber: 1,
      );

      // Now, we verify the created comment showing the converted
      // audio text

      // First, find the Youtube playlist audio ListTile Text widget
      Finder audioTitleTileTextWidgetFinder = find.text(enteredFileNameNoExt);

      // Then obtain the audio ListTile widget enclosing the Text widget
      // by finding its ancestor
      Finder audioTitleTileWidgetFinder = find.ancestor(
        of: audioTitleTileTextWidgetFinder,
        matching: find.byType(ListTile),
      );

      // Now we want to tap the popup menu of the audioTitle ListTile

      // Find the leading menu icon button of the audioTitle ListTile
      // and tap on it
      Finder audioTitleTileLeadingMenuIconButton = find.descendant(
        of: audioTitleTileWidgetFinder,
        matching: find.byIcon(Icons.menu),
      );

      // Tap the leading menu icon button to open the popup menu
      await tester.tap(audioTitleTileLeadingMenuIconButton);
      await tester.pumpAndSettle();

      // Now find the 'Audio Comments ...' popup menu item and
      // tap on it
      Finder audioCommentsPopupMenuItem =
          find.byKey(const Key("popup_menu_audio_comment"));

      await tester.tap(audioCommentsPopupMenuItem);
      await tester.pumpAndSettle();

      // Verify that the audio comments list of the dialog has 1 comment
      // item

      Finder audioCommentsLstFinder = find.byKey(const Key(
        'audioCommentsListKey',
      ));

      // Ensure the list has one child widgets
      expect(
        tester.widget<ListBody>(audioCommentsLstFinder).children.length,
        1,
      );

      List<String> expectedTitles = [
        'Text',
      ];

      List<String> expectedContents = [
        initialTextToConvertStr,
      ];

      List<String> expectedStartPositions = [
        '0:00',
      ];

      List<String> expectedEndPositions = [
        '0:07',
      ];

      List<String> expectedCreationDates = [
        frenchDateFormatYy.format(DateTime.now()), // created comment
      ];

      List<String> expectedUpdateDates = [
        '',
      ];

      // Verify content of each list item
      IntegrationTestUtil.verifyCommentsInCommentListDialog(
          tester: tester,
          commentListDialogFinder: audioCommentsLstFinder,
          commentsNumber: 1,
          expectedTitlesLst: expectedTitles,
          expectedContentsLst: expectedContents,
          expectedStartPositionsLst: expectedStartPositions,
          expectedEndPositionsLst: expectedEndPositions,
          expectedCreationDatesLst: expectedCreationDates,
          expectedUpdateDatesLst: expectedUpdateDates);

      // Now close the comment list dialog
      await tester.tap(find.byKey(const Key('closeDialogTextButton')));
      await tester.pumpAndSettle(const Duration(milliseconds: 700));

      // Now unselect the 'local' playlist
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: unselectedLocalPlaylistTitle,
      );

      // Now, reopen the convert text to audio dialog
      await IntegrationTestUtil.typeOnPlaylistMenuItem(
        tester: tester,
        playlistTitle: unselectedLocalPlaylistTitle,
        playlistMenuKeyStr: 'popup_menu_convert_text_to_audio_in_playlist',
      );

      // Now enter a new text to convert
      const String nextTextToConvertStr = "un deux trois.";
      await tester.enterText(textFieldFinder, nextTextToConvertStr);
      await tester.pump();

      // Tap the feminine checkbox to change the voice
      Finder feminineCheckbox = find.byKey(const Key('femineVoiceCheckbox'));
      await tester.tap(feminineCheckbox);
      await tester.pump();

      // Now click on Create MP3 button to create the audio
      createMP3ButtonFinder = find.byKey(const Key('create_audio_file_button'));
      await tester.tap(createMP3ButtonFinder);
      await tester.pumpAndSettle();

      // Enter the same mp3 file name as before
      mp3FileNameTextFieldFinder =
          find.byKey(const Key('textToConvertTextField'));

      await tester.enterText(mp3FileNameTextFieldFinder, enteredFileNameNoExt);
      await tester.pump();

      // Tap on the create mp3 button
      saveMP3FileButton = find.byKey(const Key('create_mp3_button_key'));
      await tester.tap(saveMP3FileButton);
      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      // Now check the confirm dialog which indicates that the saved
      // file name already exist and ask to confirm or cancel the
      // save operation.
      await IntegrationTestUtil.verifyConfirmActionDialog(
        tester: tester,
        confirmActionDialogTitle:
            "The file \"$enteredFileNameNoExt.mp3\" already exists in the playlist \"$unselectedLocalPlaylistTitle\". If you want to replace it with the new version, click on the \"Confirm\" button. Otherwise, click on the \"Cancel\" button and you will be able to define a different file name.",
        confirmActionDialogMessagePossibleLst: [""],
        closeDialogWithConfirmButton: true,
      );

      await Future.delayed(const Duration(seconds: 2));
      await tester.pumpAndSettle();

      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "The audio created by the text to MP3 conversion\n\n\"$enteredFileNameNoExt.mp3\"\n\nwas replaced in local playlist \"$unselectedLocalPlaylistTitle\".",
        isWarningConfirming: true,
      );

      // Now close the convert text to audio dialog by tapping
      // the Cancel button
      cancelButtonFinder =
          find.byKey(const Key('convertTextToAudioCancelButton'));
      await tester.tap(cancelButtonFinder);
      await tester.pumpAndSettle();

      // Now select the 'local' playlist
      await IntegrationTestUtil.selectPlaylist(
        tester: tester,
        playlistToSelectTitle: unselectedLocalPlaylistTitle,
      );

      // Verify the converted audio sub title in the selected Youtube
      // playlist audio list
      IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
        tester: tester,
        audioSubTitlesAcceptableLst: [
          '0:00:00.8 6 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now.subtract(const Duration(seconds: 1)))}',
          '0:00:00.8 6 KB converted on ${DateFormat('dd/MM/yyyy').format(now)} at ${DateFormat('HH:mm').format(now)}',
        ],
        firstAudioListTileIndex: 2,
      );

      // Verifying all audio info dialog fields related of the
      // converted audio type
      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioType: AudioType.textToSpeech,
        validVideoTitleOrAudioTitle: enteredFileNameNoExt,
        audioDownloadDateTime:
            '${DateFormat('dd/MM/yyyy').format(now)} ${DateFormat('HH:mm').format(now)}', // this is the imported date time
        isAudioPlayable: true,
        audioEnclosingPlaylistTitle: unselectedLocalPlaylistTitle,
        audioDuration: '0:00:00.8',
        audioPosition: '0:00:00',
        audioState: 'Not listened',
        lastListenDateTime: '',
        audioFileName: '$enteredFileNameNoExt.mp3',
        audioFileSize: '6 KB',
        isMusicQuality: false, // Is spoken quality
        audioPlaySpeed: '1.25',
        audioVolume: '50.0 %',
        audioCommentNumber: 2,
      );

      // Now, we verify the second created comment showing the new
      // converted audio text

      // First, find the Youtube playlist audio ListTile Text widget
      audioTitleTileTextWidgetFinder = find.text(enteredFileNameNoExt);

      // Then obtain the audio ListTile widget enclosing the Text widget
      // by finding its ancestor
      audioTitleTileWidgetFinder = find.ancestor(
        of: audioTitleTileTextWidgetFinder,
        matching: find.byType(ListTile),
      );

      // Now we want to tap the popup menu of the audioTitle ListTile

      // Find the leading menu icon button of the audioTitle ListTile
      // and tap on it
      audioTitleTileLeadingMenuIconButton = find.descendant(
        of: audioTitleTileWidgetFinder,
        matching: find.byIcon(Icons.menu),
      );

      // Tap the leading menu icon button to open the popup menu
      await tester.tap(audioTitleTileLeadingMenuIconButton);
      await tester.pumpAndSettle();

      // Now find the 'Audio Comments ...' popup menu item and
      // tap on it
      audioCommentsPopupMenuItem =
          find.byKey(const Key("popup_menu_audio_comment"));

      await tester.tap(audioCommentsPopupMenuItem);
      await tester.pumpAndSettle();

      // Verify that the audio comments list of the dialog has 2 comment
      // items

      audioCommentsLstFinder = find.byKey(const Key(
        'audioCommentsListKey',
      ));

      // Ensure the list has one child widgets
      expect(
        tester.widget<ListBody>(audioCommentsLstFinder).children.length,
        2,
      );

      expectedTitles = [
        'Text',
        'Text',
      ];

      expectedContents = [
        initialTextToConvertStr,
        nextTextToConvertStr,
      ];

      expectedStartPositions = [
        '0:00',
        '0:00',
      ];

      expectedEndPositions = [
        '0:07',
        '0:01',
      ];

      expectedCreationDates = [
        frenchDateFormatYy.format(DateTime.now()), // created comment
        frenchDateFormatYy.format(DateTime.now()), // created comment
      ];

      expectedUpdateDates = [
        '',
        '',
      ];

      // Verify content of each list item
      IntegrationTestUtil.verifyCommentsInCommentListDialog(
          tester: tester,
          commentListDialogFinder: audioCommentsLstFinder,
          commentsNumber: 2,
          expectedTitlesLst: expectedTitles,
          expectedContentsLst: expectedContents,
          expectedStartPositionsLst: expectedStartPositions,
          expectedEndPositionsLst: expectedEndPositions,
          expectedCreationDatesLst: expectedCreationDates,
          expectedUpdateDatesLst: expectedUpdateDates);

      // Now close the comment list dialog
      await tester.tap(find.byKey(const Key('closeDialogTextButton')));
      await tester.pumpAndSettle();

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
  group('Download URLs from Text File tests', () {
    testWidgets(
        '''Download URLs in music quality playlist in spoken quality.''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'download_urls_from_text_field_test',
        tapOnPlaylistToggleButton: false,
      );

      const String localPlaylistTitleInWhichToDownloadURLs =
          'Chants Bible en ligne music';

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localPlaylistTitleInWhichToDownloadURLs,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.music,
      );

      String urlsTextFileName = 'youtube_bibleenlignefr_urls.txt';

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: urlsTextFileName,
            path:
                '$kApplicationPathWindowsTest${path.separator}$urlsTextFileName',
            size: 131),
      ]);

      // Set playlist audio quality to musical. Then, the application is
      // restarted ...
      await _tapOnDownloadURLsFromTextFileMenu(
        tester: tester,
        playlistToDownloadInTitle: localPlaylistTitleInWhichToDownloadURLs,
        initialSpokenCheckboxState: false,
        initialMusicCheckboxState: true,
        setMusicQuality: false,
      );

      // Add a delay to allow the download to finish.
      for (int i = 0; i < 6; i++) {
        await Future.delayed(const Duration(milliseconds: 1000));
        await tester.pumpAndSettle();
      }

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: localPlaylistTitleInWhichToDownloadURLs,
        youtubeChannel: "Jean-Pierre Schnyder",
        validVideoTitleOrAudioTitle: "audio learn test short video one",
        isMusicQuality: false, // Is spoken quality
      );

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: localPlaylistTitleInWhichToDownloadURLs,
        youtubeChannel: "Jean-Pierre Schnyder",
        validVideoTitleOrAudioTitle: "audio learn test short video two",
        isMusicQuality: false, // Is spoken quality
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirs(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets('''Download URLs in spoken quality playlist.''',
        (WidgetTester tester) async {
      const String localPlaylistTitleInWhichToDownloadURLs =
          'Chants Bible en ligne spoken';

      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'download_urls_from_text_field_test',
        selectedPlaylistTitle: localPlaylistTitleInWhichToDownloadURLs,
        tapOnPlaylistToggleButton: false,
      );

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localPlaylistTitleInWhichToDownloadURLs,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.voice,
      );

      String urlsTextFileName = 'youtube_bibleenlignefr_urls.txt';

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: urlsTextFileName,
            path:
                '$kApplicationPathWindowsTest${path.separator}$urlsTextFileName',
            size: 131),
      ]);

      // Set playlist audio quality to musical. Then, the application is
      // restarted ...
      await _tapOnDownloadURLsFromTextFileMenu(
        tester: tester,
        playlistToDownloadInTitle: localPlaylistTitleInWhichToDownloadURLs,
        initialSpokenCheckboxState: true,
        initialMusicCheckboxState: false,
        setMusicQuality: true,
      );

      // Add a delay to allow the download to finish.
      for (int i = 0; i < 5; i++) {
        await Future.delayed(const Duration(milliseconds: 1500));
        await tester.pumpAndSettle();
      }

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: localPlaylistTitleInWhichToDownloadURLs,
        youtubeChannel: "Jean-Pierre Schnyder",
        validVideoTitleOrAudioTitle: "audio learn test short video one",
        isMusicQuality: true, // Is music quality
      );

      await IntegrationTestUtil.verifyAudioInfoDialog(
        tester: tester,
        audioEnclosingPlaylistTitle: localPlaylistTitleInWhichToDownloadURLs,
        youtubeChannel: "Jean-Pierre Schnyder",
        validVideoTitleOrAudioTitle: "audio learn test short video two",
        isMusicQuality: true, // Is music quality
      );

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirsWithRetry(
        rootPath: kApplicationPathWindowsTest,
      );
    });
    testWidgets('''Uncheck all checkbox of download audio quality.''',
        (WidgetTester tester) async {
      await IntegrationTestUtil.initializeApplicationAndSelectPlaylist(
        tester: tester,
        savedTestDataDirName: 'download_urls_from_text_field_test',
        tapOnPlaylistToggleButton: false,
      );

      const String localPlaylistTitleInWhichToDownloadURLs =
          'Chants Bible en ligne music';

      await _verifyPlaylistAudioQuality(
        tester: tester,
        playlistTitle: localPlaylistTitleInWhichToDownloadURLs,
        isPlaylistLocal: true,
        playlistQuality: PlaylistQuality.music,
      );

      String urlsTextFileName = 'youtube_bibleenlignefr_urls.txt';

      // Replace the platform instance with your mock
      MockFilePicker mockFilePicker = MockFilePicker();
      FilePicker.platform = mockFilePicker;

      mockFilePicker.setSelectedFiles([
        PlatformFile(
            name: urlsTextFileName,
            path:
                '$kApplicationPathWindowsTest${path.separator}$urlsTextFileName',
            size: 131),
      ]);

      // Set playlist audio quality to musical. Then, the application is
      // restarted ...
      await _tapOnDownloadURLsFromTextFileMenu(
          tester: tester,
          playlistToDownloadInTitle: localPlaylistTitleInWhichToDownloadURLs,
          initialSpokenCheckboxState: false,
          initialMusicCheckboxState: true,
          setMusicQuality: false,
          uncheckAllCheckboxes: true);

      // Since no checkbox was checked, a warning is displayed ...

      // Verify the displayed warning dialog and close it
      await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
        tester: tester,
        warningDialogMessage:
            "No checkbox selected. Please select one checkbox before clicking 'Ok', or click 'Cancel' to exit.",
        isWarningConfirming: false,
      );

      // And click on the Cancel button of the download URLs from text
      // file dialog
      await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
      await tester.pumpAndSettle();

      expect(find.text("audio learn test short video one"), findsNothing);

      expect(find.text("audio learn test short video two"), findsNothing);

      // Purge the test playlist directory so that the created test
      // files are not uploaded to GitHub
      DirUtil.deleteFilesInDirAndSubDirsWithRetry(
        rootPath: kApplicationPathWindowsTest,
      );
    });
  });
}

Future<void> _inAudioPlayerViewVerifyAudioPositionAndDuration({
  required WidgetTester tester,
  required String audioTitle,
  required String audioStartPosition,
  required String audioEndPosition,
  required String audioDuration,
}) async {
  // First, find the Audio sublist ListTile Text widget
  Finder convertedCommentedAudioTitleListTileTextWidgetFinder =
      find.text(audioTitle);

  // Type on the audio title to open the audio player view
  await tester.tap(convertedCommentedAudioTitleListTileTextWidgetFinder);
  await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
    tester: tester,
  );

  // Verify start and end positions and the audio duration in the
  // audio player view

  Text audioPositionText = tester
      .widget<Text>(find.byKey(const Key('audioPlayerViewAudioPosition')));
  expect(audioPositionText.data, audioStartPosition);

  Text audioRemainingDurationText = tester.widget<Text>(
      find.byKey(const Key('audioPlayerViewAudioRemainingDuration')));
  expect(audioRemainingDurationText.data, audioEndPosition);

  String aaaAudioTitleText = (tester.widget<Text>(
          find.byKey(const Key('audioPlayerViewCurrentAudioTitle'))))
      .data!;

  String aaaAudioDurationStr = _extractDuration(aaaAudioTitleText);

  expect(aaaAudioDurationStr, audioDuration);

  // Go back to the playlist download view
  final Finder appScreenNavigationButton =
      find.byKey(const ValueKey('playlistDownloadViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle();
}

Future<void> _restorePaylistsAndTheirMp3({
  required WidgetTester tester,
  required String sourceRootPath,
  required String restorablePlaylistsZipFileName,
  required String restorableMp3ZipFileName,
  required MockFilePicker mockFilePicker,
  bool doReplaceExistingPlaylists = false,
  String restorePlaylistsConfirmationMessage = '',
  String restoreMp3ConfirmationMessage = '',
  String restoreMp3FromUniquePlaylistTitle = '',
}) async {
  String restorableZipFilePathName =
      '$sourceRootPath${path.separator}$restorablePlaylistsZipFileName';

  // Setting the file path name value returned by the FilePicker mock.
  mockFilePicker.setSelectedFiles([
    PlatformFile(
        name: restorableZipFilePathName,
        path: restorableZipFilePathName,
        size: 6703),
  ]);

  // Execute the 'Restore Playlists, Comments and Settings from Zip
  // File ...' menu to initialize the application 'local' and
  // urgent_actus_17-12-2023 playlist
  await IntegrationTestUtil.executeRestorePlaylists(
    tester: tester,
    doReplaceExistingPlaylists: doReplaceExistingPlaylists,
  );

  if (restorePlaylistsConfirmationMessage.isNotEmpty) {
    // Verify the displayed confirmation dialog and confirm the
    // restoration
    await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
      tester: tester,
      warningDialogMessage: restorePlaylistsConfirmationMessage,
      isWarningConfirming: true,
    );
  } else {
    // Tap the warning confirmation dialog Ok button to close it
    await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
    await tester.pumpAndSettle();
  }

  String mp3RestorableZipFilePathName =
      '$sourceRootPath${path.separator}$restorableMp3ZipFileName';

  mockFilePicker.setSelectedFiles([
    PlatformFile(
        name: mp3RestorableZipFilePathName,
        path: mp3RestorableZipFilePathName,
        size: 19331059),
  ]);

  if (restoreMp3FromUniquePlaylistTitle.isEmpty) {
    // Execute the 'Restore Playlists Audio's MP3 from Zip File ...' menu
    // to restore the two playlists mp3 files
    await IntegrationTestUtil.typeOnAppbarMenuItem(
      tester: tester,
      appbarMenuKeyStr: 'appBarMenuRestorePlaylistsAudioMp3FilesFromZip',
    );
  } else {
    // Execute the 'Restore Playlist Audio's MP3 from Zip File ...' menu
    // to restore the 'local' playlist mp3 files
    await IntegrationTestUtil.typeOnPlaylistMenuItem(
      tester: tester,
      playlistTitle: restoreMp3FromUniquePlaylistTitle,
      playlistMenuKeyStr:
          'popup_menu_restore_playlist_audio_mp3_files_from_zip',
    );
  }

  // Tap on the MP3 Restoration SetValueToTargetDialog Ok button
  await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
  await tester.pumpAndSettle();

  if (restoreMp3ConfirmationMessage.isNotEmpty) {
    // Verify the displayed confirmation dialog and confirm the
    // restoration
    await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
      tester: tester,
      warningDialogMessage: restoreMp3ConfirmationMessage,
      isWarningConfirming: true,
    );
  } else {
    // Tap the warning confirmation dialog Ok button to close it
    await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
    await tester.pumpAndSettle();
  }
}

Future<void> _createAndSavePlayableSortFilterParms({
  required WidgetTester tester,
  required String saveAsTitle,
}) async {
  // Now open the audio popup menu
  await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
  await tester.pumpAndSettle();

  // Find the sort/filter audio menu item and tap on it to
  // open the audio sort filter dialog
  await tester
      .tap(find.byKey(const Key('define_sort_and_filter_audio_menu_item')));
  await tester.pumpAndSettle();

  // Type "Playable" in the 'Save as' TextField

  await tester.enterText(
      find.byKey(const Key('sortFilterSaveAsUniqueNameTextField')),
      saveAsTitle);
  await tester.pumpAndSettle();

  // Scrolling down the sort filter dialog so that the checkboxes
  // are visible and so accessible by the integration test.
  // WARNING: Scrolling down must be done before setting sort
  // options, otherwise, it does not work.
  await tester.drag(
    find.byType(AudioSortFilterDialog),
    const Offset(0, -300), // Negative value for vertical drag to scroll down
  );
  await tester.pumpAndSettle();

  // Tap on the 'Not playable' checkbox to unselect it
  await tester.tap(find.byKey(const Key('filterNotPlayableCheckbox')));
  await tester.pumpAndSettle();

  // Click on the "Save" button.
  await tester.tap(find.byKey(const Key('saveSortFilterOptionsTextButton')));
  await tester.pumpAndSettle();
}

class CommentListAddDialog {}

Future<void> _verifyListenAndCreateMp3ButtonsState({
  required WidgetTester tester,
  required bool areEnabled,
}) async {
  if (areEnabled) {
    IntegrationTestUtil.verifyWidgetIsEnabled(
      tester: tester,
      widgetKeyStr: 'listen_text_button',
    );
    IntegrationTestUtil.verifyWidgetIsEnabled(
      tester: tester,
      widgetKeyStr: 'create_audio_file_button',
    );
  } else {
    IntegrationTestUtil.verifyWidgetIsDisabled(
      tester: tester,
      widgetKeyStr: 'listen_text_button',
    );
    IntegrationTestUtil.verifyWidgetIsDisabled(
      tester: tester,
      widgetKeyStr: 'create_audio_file_button',
    );
  }
}

Future<void> _verifyCreatedZipFilesContent({
  required List<String> zipLst,
  required List<List<String>> expectedZipContentLst,
}) async {
  for (int i = 0; i < zipLst.length; i++) {
    List<String> zipContentLst = await DirUtil.listPathFileNamesInZip(
      zipFilePathName:
          "$kApplicationPathWindowsTest${path.separator}${zipLst[i]}",
    );

    expect(
      zipContentLst,
      expectedZipContentLst[i],
    );
  }
}

Future<String> _createNewLocalPlaylist({
  required WidgetTester tester,
  required String newPlaylistTitle,
}) async {
  // Open the add playlist dialog by tapping the add playlist
  // button
  await tester.tap(find.byKey(const Key('addPlaylistButton')));
  await tester.pumpAndSettle();

  // Enter the title of the local playlist
  await tester.enterText(
    find.byKey(const Key('playlistLocalTitleConfirmDialogTextField')),
    newPlaylistTitle,
  );

  // Confirm the addition by tapping the confirmation button in
  // the AlertDialog
  await tester.tap(find.byKey(const Key('addPlaylistConfirmDialogAddButton')));
  await tester.pumpAndSettle();

  // Close the warning dialog
  await tester.tap(find.byKey(const Key('warningDialogOkButton')).last);
  await tester.pumpAndSettle();
  return newPlaylistTitle;
}

Future<void> _verifyTargetListTitles({
  required WidgetTester tester,
  required String moveOrCopyMenuKeyStr,
}) async {
  // Now we want to tap the popup menu of the Audio ListTile
  // "audio learn test short video two"

  const String movedAudioTitle = "audio learn test short video two";

  // First, find the Audio sublist ListTile Text widget
  final Finder sourceAudioListTileTextWidgetFinder = find.text(movedAudioTitle);

  // Then obtain the Audio ListTile widget enclosing the Text widget by
  // finding its ancestor
  final Finder sourceAudioListTileWidgetFinder = find.ancestor(
    of: sourceAudioListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the Audio ListTile and tap
  // on it
  final Finder sourceAudioListTileLeadingMenuIconButton = find.descendant(
    of: sourceAudioListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(sourceAudioListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Now find the move or copy audio popup menu item and tap on it
  final Finder popupMoveMenuItem = find.byKey(Key(moveOrCopyMenuKeyStr));

  await tester.tap(popupMoveMenuItem);
  await tester.pumpAndSettle();

  // Verify that the target playlist list is not filtered
  // by the search sentence

  final playlistTitles = IntegrationTestUtil.getPlaylistTitlesFromDialog(
    tester: tester,
  );

  expect(
      playlistTitles,
      equals([
        'local_3',
        'local_audio_playlist_2',
        'local_two',
      ]));

  // Now find the confirm button and tap on it
  await tester.tap(find.byKey(const Key('cancelButton')));
  await tester.pumpAndSettle();
}

Future<void> _selectAndApplySortFilterParms({
  required WidgetTester tester,
  required List<String> playlistDisplayedAudioTitlesLst,
  required String sfParmsName,
  required String textFieldContentStr,
}) async {
  // Now select the 'asc listened' sort/filter item in the dropdown
  // button items list

  // Tap on the current dropdown button item to open the dropdown
  // button items list

  final Finder dropDownButtonFinder =
      find.byKey(const Key('sort_filter_parms_dropdown_button'));

  final Finder dropDownButtonTextFinder = find.descendant(
    of: dropDownButtonFinder,
    matching: find.byType(Text),
  );

  await tester.tap(dropDownButtonTextFinder);
  await tester.pumpAndSettle();

  // And find the 'asc listened' sort/filter item
  final Finder titleAscDropDownTextFinder = find.text(sfParmsName).last;
  await tester.tap(titleAscDropDownTextFinder);
  await tester.pumpAndSettle();

  // Verify that the search text field content was not changed
  IntegrationTestUtil.verifyTextFieldContent(
    tester: tester,
    textFieldKeyStr: 'youtubeUrlOrSearchTextField',
    expectedTextFieldContent: textFieldContentStr,
  );

  // And verify the order of the 'asc listened' playlist audio
  // titles

  // Ensure that since the search icon button was un-pressed,
  // the displayed audio list returned to the default list.
  IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
    tester: tester,
    audioOrPlaylistTitlesOrderedLst: playlistDisplayedAudioTitlesLst,
  );
}

Future<void> _resetUnselectedPlaylistAudioQualityAndThenSelectPlaylist({
  required WidgetTester tester,
  required String playlistTitle,
  required bool isPlaylistLocal,
  required PlaylistQuality playlistQuality,
}) async {
  if (playlistQuality == PlaylistQuality.voice) {
    // Re-set the unselected MyValTest playlist audio quality
    // to spoken.
    await _tapOnSetAudioQualityMenu(
      tester: tester,
      playlistToModifyTitle: playlistTitle,
      setMusicQuality: false,
    );
  } else {
    // Re-set the unselected MyValTest playlist audio quality
    // to musical.
    await _tapOnSetAudioQualityMenu(
      tester: tester,
      playlistToModifyTitle: playlistTitle,
      setMusicQuality: true,
    );
  }

  // Now selecting the MyValTest playlist by tapping on the
  // playlist checkbox.
  await IntegrationTestUtil.selectPlaylist(
    tester: tester,
    playlistToSelectTitle: playlistTitle,
  );

  if (!isPlaylistLocal) {
    // Verify that the music quality checkbox is enabled
    IntegrationTestUtil.verifyWidgetIsEnabled(
      tester: tester,
      widgetKeyStr: 'audio_quality_checkbox',
    );
  } else {
    // Verify that the music quality checkbox is disabled
    IntegrationTestUtil.verifyWidgetIsDisabled(
      tester: tester,
      widgetKeyStr: 'audio_quality_checkbox',
    );
  }

  Finder downloadAtMusicalQualityCheckBoxFinder =
      find.byKey(const Key('audio_quality_checkbox'));
  Checkbox downloadAtMusicalQualityCheckBoxWidget =
      tester.widget<Checkbox>(downloadAtMusicalQualityCheckBoxFinder);

  if (playlistQuality == PlaylistQuality.voice) {
    expect(downloadAtMusicalQualityCheckBoxWidget.value, false);
  } else {
    expect(downloadAtMusicalQualityCheckBoxWidget.value, true);
  }
}

Future<void> _verifyPlaylistAudioQuality({
  required WidgetTester tester,
  required String playlistTitle,
  required bool isPlaylistLocal,
  required PlaylistQuality playlistQuality,
}) async {
  if (isPlaylistLocal) {
    IntegrationTestUtil.verifyWidgetIsDisabled(
      tester: tester,
      widgetKeyStr: 'audio_quality_checkbox',
    );
  } else {
    IntegrationTestUtil.verifyWidgetIsEnabled(
      tester: tester,
      widgetKeyStr: 'audio_quality_checkbox',
    );
  }

  Finder downloadAtMusicalQualityCheckBoxFinder =
      find.byKey(const Key('audio_quality_checkbox'));
  Checkbox downloadAtMusicalQualityCheckBoxWidget =
      tester.widget<Checkbox>(downloadAtMusicalQualityCheckBoxFinder);
  String playlistAudioQuality;

  if (playlistQuality == PlaylistQuality.music) {
    // Verify that the download at musical quality checkbox is
    // checked
    expect(downloadAtMusicalQualityCheckBoxWidget.value, true);
    playlistAudioQuality = 'musical';
  } else {
    // Verify that the download at musical quality checkbox is
    // unchecked
    expect(downloadAtMusicalQualityCheckBoxWidget.value, false);
    playlistAudioQuality = 'spoken';
  }

  await IntegrationTestUtil.verifyPlaylistInfoDialogContent(
    tester: tester,
    playlistTitle: playlistTitle,
    playlistDownloadAudioSortFilterParmsName: 'default',
    playlistPlayAudioSortFilterParmsName: 'default',
    playlistAudioQuality: playlistAudioQuality,
  );
}

void _verifyRestoredPlaylistAndAudio({
  required WidgetTester tester,
  required String selectedPlaylistTitle,
  required List<String> playlistsTitles,
  required List<String> audioTitles,
  required List<String> audioSubTitles,
}) {
  // Verify the selected playlist
  IntegrationTestUtil.verifyPlaylistSelection(
    tester: tester,
    playlistTitle: selectedPlaylistTitle,
  );

  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
    tester: tester,
    audioSubTitlesAcceptableLst: audioSubTitles,
    firstAudioListTileIndex: playlistsTitles.length,
  );
}

/// Returns the added [pictureFilePathName]
Future<String> _addPictureToAudioExecutingAudioListItemMenu({
  required WidgetTester tester,
  required MockFilePicker mockFilePicker,
  required String pictureFileName,
  required String pictureSourcePath,
  required int pictureFileSize,
  required String audioForPictureTitle,
}) async {
  String pictureFilePathName =
      "$pictureSourcePath${path.separator}$pictureFileName";

  mockFilePicker.setSelectedFiles([
    PlatformFile(
        name: pictureFileName,
        path: pictureFilePathName,
        size: pictureFileSize),
  ]);

  // Now we want to tap the popup menu of the Audio ListTile

  // First, find the Audio sublist ListTile Text widget
  Finder audioForPictureTitleTextWidgetFinder = find.text(audioForPictureTitle);

  // Then obtain the Audio ListTile widget enclosing the Text widget by
  // finding its ancestor
  Finder audioForPictureListTileWidgetFinder = find.ancestor(
    of: audioForPictureTitleTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the Audio ListTile and tap
  // on it
  Finder audioForPictureListTileLeadingMenuIconButton = find.descendant(
    of: audioForPictureListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(audioForPictureListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Now find the Add Picture popup menu item and tap on it
  Finder addPictureMenuItem =
      find.byKey(const Key("popup_menu_add_audio_picture"));

  await tester.tap(addPictureMenuItem);
  await tester.pumpAndSettle(const Duration(microseconds: 200));

  return pictureFilePathName;
}

/// Returns the added [pictureFilePathName]
Future<String> _addPictureToAudioExecutingAudioPlayerViewLeftAppbarMenu({
  required WidgetTester tester,
  required MockFilePicker mockFilePicker,
  required String pictureFileName,
  required String pictureSourcePath,
  required int pictureFileSize,
}) async {
  String pictureFilePathName =
      "$pictureSourcePath${path.separator}$pictureFileName";

  mockFilePicker.setSelectedFiles([
    PlatformFile(
        name: pictureFileName,
        path: pictureFilePathName,
        size: pictureFileSize),
  ]);

  // Now we want to tap on the audio player view left appbar
  // menu and then tapp on the 'Add Audio Picture' popup menu
  // item

  await IntegrationTestUtil.typeOnAppbarMenuItem(
    tester: tester,
    appbarMenuKeyStr: 'popup_menu_add_audio_picture',
  );

  return pictureFilePathName;
}

Future<void> _removeAudioPictureExecutingAudioListItemMenu({
  required WidgetTester tester,
  required String picturedAudioTitle,
}) async {
  // Tapping the popup menu of the Audio ListTile

  // First, find the Audio sublist ListTile Text widget
  Finder audioForPictureTitleTextWidgetFinder = find.text(picturedAudioTitle);

  // Then obtain the Audio ListTile widget enclosing the Text widget by
  // finding its ancestor
  Finder audioForPictureListTileWidgetFinder = find.ancestor(
    of: audioForPictureTitleTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the Audio ListTile and tap
  // on it
  Finder audioForPictureListTileLeadingMenuIconButton = find.descendant(
    of: audioForPictureListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(audioForPictureListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Find the Remove Audio Picture popup menu item and tap on it
  Finder addPictureMenuItem =
      find.byKey(const Key("popup_menu_remove_audio_picture"));

  await tester.tap(addPictureMenuItem);
  await tester.pumpAndSettle(const Duration(microseconds: 200));
}

Future<void> _removeAudioPictureInAudioPlayerView({
  required WidgetTester tester,
  required String picturedAudioTitle,
}) async {
  // Tap on the audio player view left appbar menu. Then,
  // the Remove Audio Picture menu is selected.
  await IntegrationTestUtil.typeOnAppbarMenuItem(
    tester: tester,
    appbarMenuKeyStr: 'popup_menu_remove_audio_picture',
  );
}

Future<void> _changePlaylistRootPathAndSaveAppSettings({
  required WidgetTester tester,
  required MockFilePicker mockFilePicker,
  required String pathToSelectStr,
  required List<String> playlistTitlesOrderInModifiedDir,
  required String expectedSettingsContent,
  required String selectedPlaylistTitle,
  String confirmDialogTitleOne = '',
  String confirmDialogMessage = '',
  bool confirmOrCancelAction = true, // true: confirm, false: cancel
}) async {
  // Tap the appbar leading popup menu button Then, the
  // app settings dialog is opened.
  await IntegrationTestUtil.typeOnAppbarMenuItem(
    tester: tester,
    appbarMenuKeyStr: 'appBarMenuOpenSettingsDialog',
  );

  // Select the modified dir path. Tapping on the select directory
  // icon button does not open the directory picker dialog. Instead,
  // the FilePicker mock is used to simulate the selection of the
  // directory.

  // Setting the path value returned by the FilePicker mock.
  mockFilePicker.setPathToSelect(
    pathToSelectStr: pathToSelectStr,
  );

  await tester.tap(find.byKey(const Key('openDirectoryIconButton')));
  await tester.pumpAndSettle();

  // Find the Text using the Key
  final Finder textFinder = find.byKey(const Key('playlistsRootPathText'));

  // Retrieve the Text widget
  String text = tester.widget<Text>(textFinder).data ?? '';

  // Verify the selected directory path
  expect(
    text,
    pathToSelectStr,
  );

  // And tap on save button
  await tester.tap(find.byKey(const Key('saveButton')));
  await tester.pumpAndSettle(const Duration(milliseconds: 2000));

  if (confirmDialogTitleOne.isNotEmpty) {
    // Verify the ConfirmActionDialog which asks to the user if he wants
    // to restore the saved playlist titles order or keep the current
    // order
    await IntegrationTestUtil.verifyAndCloseConfirmActionDialog(
      tester: tester,
      confirmDialogTitleOne: confirmDialogTitleOne,
      confirmDialogMessage: confirmDialogMessage,
      confirmOrCancelAction: confirmOrCancelAction, // Confirm button is tapped
    );
  }

  // Verify the modified directory playlist titles

  IntegrationTestUtil.checkAudioOrPlaylistTitlesOrderInListTile(
    tester: tester,
    audioOrPlaylistTitlesOrderedLst: playlistTitlesOrderInModifiedDir,
  );

  // Verify the selected playlist
  IntegrationTestUtil.verifyPlaylistSelection(
    tester: tester,
    playlistTitle: selectedPlaylistTitle,
    modifiedPlaylistRootPath: pathToSelectStr,
  );

  // Ensure settings json file has been modified
  expect(
    File("$kApplicationPathWindowsTest${path.separator}$kSettingsFileName")
        .readAsStringSync(),
    expectedSettingsContent,
  );
}

Future<void> _verifyDatePickerTitleTranslation({
  required WidgetTester tester,
  required String datePickerTranslatedTitleStr,
  required String datePickerCancelButtonTranslatedStr,
}) async {
  await _openSortFilterThenDatePickerDialog(tester);

  // Verify the translated title in the DatePicker dialog
  expect(find.text(datePickerTranslatedTitleStr), findsOneWidget);

  // Now close the DatePicker dialog by tapping on the cancel button
  await tester.tap(find.text(datePickerCancelButtonTranslatedStr).last);
  await tester.pumpAndSettle();

  // Now close the audio sort filter dialog by tapping on its cancel
  // button
  await tester.tap(find.byKey(const Key('cancelSortFilterButton')));
  await tester.pumpAndSettle();
}

Future<void> _openSortFilterThenDatePickerDialog(WidgetTester tester) async {
  // Open the audio popup menu
  await tester.tap(find.byKey(const Key('audio_popup_menu_button')));
  await tester.pumpAndSettle();

  // Find the sort/filter audio menu item and tap on it to
  // open the audio sort filter dialog
  await tester
      .tap(find.byKey(const Key('define_sort_and_filter_audio_menu_item')));
  await tester.pumpAndSettle();

  // Now open the DatePicker dialog, but first scroll down the dialog so that
  // the date text fields are visible.

  await tester.drag(
    find.byType(AudioSortFilterDialog),
    const Offset(0, -300), // Negative value for vertical drag to scroll down
  );
  await tester.pumpAndSettle();

  // Find the DatePicker dialog icon button and tap on it to
  // open the dialog
  await tester.tap(find.byKey(const Key('startDownloadDateIconButton')));
  await tester.pumpAndSettle();
}

void _verifyEnglishInPlaylistDownloadView() {
  expect(find.text('Download Audio'), findsOneWidget);
  expect(find.text('Youtube Link or Search'), findsOneWidget);
  expect(find.text('default'), findsOneWidget);
  expect(find.text('Add'), findsOneWidget);
  expect(find.text('One'), findsOneWidget);
}

void _verifyFrenchInPlaylistDownloadView() {
  expect(find.text('Téléch. Audio'), findsOneWidget);
  expect(find.text('Lien Youtube ou recherche'), findsOneWidget);
  expect(find.text('défaut'), findsOneWidget);
  expect(find.text('Ajout'), findsOneWidget);
  expect(find.text('Un'), findsOneWidget);
}

Future<void> _testMovingOrCopyingFilteredAudio({
  required WidgetTester tester,
  required String sourcePlaylistTitle,
  required String targetPlaylistTitle,
  required String sortFilterParmName,
  required bool isMove, // true: move, false: copy
  required int movedOrCopiedAudioNumber,
  required int commentedAudioNumber,
  required int unmovedOrUncopiedAudioNumber,
}) async {
  // Now test moving the filtered audio

  String playlistSubMenuKeyStr;

  if (isMove) {
    playlistSubMenuKeyStr = 'popup_menu_move_filtered_audio';
  } else {
    playlistSubMenuKeyStr = 'popup_menu_copy_filtered_audio';
  }

  // Open the move or copy filtered audio dialog by clicking first on
  // the 'Filtered Audio Actions ...' playlist menu item and then
  // on the 'Move/Copy Filtered Audio to Playlist ...' sub-menu item
  await IntegrationTestUtil.typeOnPlaylistSubMenuItem(
    tester: tester,
    playlistTitle: sourcePlaylistTitle,
    playlistSubMenuKeyStr: playlistSubMenuKeyStr,
  );

  // Select the target 'temp' playlist

  // Check the value of the select one playlist AlertDialog
  // dialog title
  Text alertDialogTitle = tester
      .widget(find.byKey(const Key('playlistOneSelectableDialogTitleKey')));
  expect(alertDialogTitle.data, 'Select a Playlist');

  // Find the RadioListTile target playlist to which the audio
  // will be moved or copied

  Finder radioListTile = find
      .ancestor(
        of: find.text(targetPlaylistTitle),
        matching: find.byType(ListTile),
      )
      .last;

  // Tap the target playlist RadioListTile to select it
  await tester.tap(radioListTile);
  await tester.pumpAndSettle();

  // Now find the confirm button and tap on it
  await tester.tap(find.byKey(const Key('confirmButton')));
  await tester.pumpAndSettle();

  // Verifying the confirm warning title

  Text moveFilteredAudioConfirmWarningTitleWidget =
      tester.widget<Text>(find.byKey(const Key('warningDialogTitle')));

  expect(moveFilteredAudioConfirmWarningTitleWidget.data, 'CONFIRMATION');

  // Verifying the confirm warning message

  Text moveFilteredAudioConfirmWarningMessageWidget =
      tester.widget<Text>(find.byKey(const Key('warningDialogMessage')));

  if (isMove) {
    expect(moveFilteredAudioConfirmWarningMessageWidget.data,
        'Applying Sort/Filter parms "$sortFilterParmName", from Youtube playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle", $movedOrCopiedAudioNumber audio(s) were moved from which $commentedAudioNumber were commented, and $unmovedOrUncopiedAudioNumber audio(s) were unmoved.');
  } else {
    // copying
    expect(moveFilteredAudioConfirmWarningMessageWidget.data,
        'Applying Sort/Filter parms "$sortFilterParmName", from Youtube playlist "$sourcePlaylistTitle" to local playlist "$targetPlaylistTitle", $movedOrCopiedAudioNumber audio(s) were copied from which $commentedAudioNumber were commented, and $unmovedOrUncopiedAudioNumber audio(s) were not copied.');
  }

  // Now find the ok button of the confirm dialog and tap on it
  await tester.tap(find.byKey(const Key('warningDialogOkButton')));
  await tester.pumpAndSettle();
}

Playlist loadPlaylist(String playListOneName) {
  return JsonDataService.loadFromFile(
      jsonPathFileName:
          "$kApplicationPathWindowsTest${path.separator}$playListOneName${path.separator}$playListOneName.json",
      type: Playlist);
}

/// This code is used in integation tests for two purposes:
///   1/ for executing the expect that the playlist checkbox is checked code,
///   2/ for tapping on  the playlist checkbox.
/// The two boolean parameters define what this method does.
Future<void> _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox({
  required WidgetTester tester,
  required String playlistToSelectTitle,
  required bool verifyIfCheckboxIsChecked,
  required bool tapOnCheckbox,
}) async {
  Finder playlistToSelectListTileTextWidgetFinder =
      find.text(playlistToSelectTitle);

  // Then obtain the Playlist ListTile widget enclosing the Text widget
  // by finding its ancestor
  Finder playlistToSelectListTileWidgetFinder = find.ancestor(
    of: playlistToSelectListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the Checkbox widget located in the Playlist ListTile
  // and tap on it to select the playlist
  Finder playlistToSelectListTileCheckboxWidgetFinder = find.descendant(
    of: playlistToSelectListTileWidgetFinder,
    matching: find.byKey(const Key('playlist_checkbox_key')),
  );

  // Verify that the Playlist ListTile checkbox is checked
  if (verifyIfCheckboxIsChecked) {
    final Checkbox checkboxWidget =
        tester.widget<Checkbox>(playlistToSelectListTileCheckboxWidgetFinder);

    expect(checkboxWidget.value!, true);
  }

  // Tap the ListTile Playlist checkbox to select it: This ensure
  // another bug was solved
  if (tapOnCheckbox) {
    await tester.tap(playlistToSelectListTileCheckboxWidgetFinder);
    await tester.pumpAndSettle();
  }
}

Future<void> _onAudioPlayerViewCheckOrTapOnPlaylistCheckbox({
  required WidgetTester tester,
  required String playlistDownloadViewCurrentlySelectedPlaylistTitle,
  required String playlistToSelectTitleInAudioPlayerView,
}) async {
  // Go to the audio player view
  Finder appScreenNavigationButton =
      find.byKey(const ValueKey('audioPlayerViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
    tester: tester,
  );

  // Verify that the playlist download view currently selected playlist is
  // also selected in the playlist download view.

  // Tap on audio player view playlist button to display the playlists
  await tester.tap(find.byKey(const Key('playlist_toggle_button')));
  await tester.pumpAndSettle();

  // Find the currently selected playlist ListTile Text widget
  Finder playlistDownloadViewCurrentlySelectedPlaylistListTileTextWidgetFinder =
      find.text(playlistDownloadViewCurrentlySelectedPlaylistTitle);

  // Then obtain the playlist ListTile widget enclosing the Text widget
  // by finding its ancestor
  Finder playlistDownloadViewCurrentlySelectedPlaylistListTileWidgetFinder =
      find.ancestor(
    of: playlistDownloadViewCurrentlySelectedPlaylistListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the Checkbox widget located in the playlist ListTile
  // and verify that it is checked

  Finder
      playlistDownloadViewCurrentlySelectedPlaylistListTileCheckboxWidgetFinder =
      find.descendant(
    of: playlistDownloadViewCurrentlySelectedPlaylistListTileWidgetFinder,
    matching: find.byType(Checkbox),
  );

  final Checkbox checkboxWidget = tester.widget<Checkbox>(
      playlistDownloadViewCurrentlySelectedPlaylistListTileCheckboxWidgetFinder);

  expect(checkboxWidget.value!, true);

  // Select the passed playlistToSelectTitle playlist

  await IntegrationTestUtil.selectPlaylist(
    tester: tester,
    playlistToSelectTitle: playlistToSelectTitleInAudioPlayerView,
  );

  // Now we go back to the PlayListDownloadView in order to
  // verify the scrolled selected playlist
  appScreenNavigationButton =
      find.byKey(const ValueKey('playlistDownloadViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle();
}

Future<void> _selectNewAudioInAudioPlayerViewAndReturnToPlaylistDownloadView({
  required WidgetTester tester,
  required String currentAudioTitle,
  required String newAudioTitle,
  double offsetValue = 0.0,
}) async {
  // Go to audio player view to select another audio
  Finder appScreenNavigationButton =
      find.byKey(const ValueKey('audioPlayerViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle();

  // Now we open the AudioPlayableListDialog by tapping on the
  // audio title
  await tester.tap(find.text("$currentAudioTitle\n0:10"));
  await tester.pumpAndSettle();

  // Select an Audio in the AudioPlayableListDialog
  await IntegrationTestUtil.selectAudioInAudioPlayableDialog(
    tester: tester,
    audioToSelectTitle: newAudioTitle,
    offsetValue: offsetValue, // scrolling down may be necessary in order to
    //                           find the audioToSelectTitle
  );

  // Return to playlist download view
  appScreenNavigationButton =
      find.byKey(const ValueKey('playlistDownloadViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle();
}

Future<void> _selectDateFormat({
  required WidgetTester tester,
  required String dateFormatToSelectLowCase,
  required String dateFormatToSelect,
  required String previouslySelectedDateFormat,
}) async {
  await tester.tap(find.byKey(const Key('appBarRightPopupMenu')));
  await tester.pumpAndSettle();

  // Open the date format selection dialog
  await tester.tap(find.byKey(const Key('appBarMenuDateFormat')));
  await tester.pumpAndSettle();

  // Check the value of the date format selection dialog title
  Text alertDialogTitle =
      tester.widget(find.byKey(const Key('dateFormatSelectionDialogTitleKey')));
  expect(alertDialogTitle.data, 'Select the Application Date Format');

  // Find the RadioListTile date format to select

  Finder radioListTile = find.ancestor(
    of: find.textContaining(dateFormatToSelectLowCase),
    matching: find.byType(ListTile),
  );
  // Tap the target dateformat RadioListTile to select it
  await tester.tap(radioListTile);
  await tester.pumpAndSettle();

  await _verifyApplicationSettingsDateFormatValue(
    dateFormatValue: previouslySelectedDateFormat,
  );

  // Now find the confirm button and tap on it
  await tester.tap(find.byKey(const Key('confirmButton')));
  await tester.pumpAndSettle();

  await _verifyApplicationSettingsDateFormatValue(
    dateFormatValue: dateFormatToSelect,
  );
}

Future<void> _verifyApplicationSettingsDateFormatValue({
  required String dateFormatValue,
}) async {
  SettingsDataService settingsDataService = SettingsDataService(
    sharedPreferences: MockSharedPreferences(),
  );

  await settingsDataService.loadSettingsFromFile(
      settingsJsonPathFileName:
          "$kApplicationPathWindowsTest${Platform.pathSeparator}$kSettingsFileName");

  expect(
      settingsDataService.get(
          settingType: SettingType.formatOfDate,
          settingSubType: FormatOfDate.formatOfDate),
      dateFormatValue);
}

Future<void> _verifyDateFormatApplication({
  required WidgetTester tester,
  required List<String> audioSubTitles,
  required List<String> audioSubTitlesWithAudioDownloadDuration,
  required List<String> audioSubTitlesWithAudioRemainingDuration,
  required List<String> audioSubTitlesLastListenedDateTimeDescending,
  required List<String> audioSubTitlesTitleAsc,
  required List<String> audioSubTitlesVideoUploadDate,
  required List<String> audioSubTitlesWithAudioDownloadSpeed,
  required String playlistTitle,
  required String videoUploadDate,
  required audioDownloadDateTime,
  required String playlistLastDownloadDateTime,
  required String commentCreationDate,
  required String commentUpdateDate,
  required String datePickerDateStr,
  required String savePlaylistsAudioMp3DateFormat,
  required String savePlaylistsAudioMp3OldestDate,
  required String latestAudioDownloadDate,
}) async {
  IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
    tester: tester,
    audioSubTitlesAcceptableLst: audioSubTitles,
  );

  // Now we want to tap the popup menu of the Audio ListTile
  // "Jancovici m'explique l’importance des ordres de grandeur
  // face au changement climatique",

  const String audioTitle =
      "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique";

  // First, find the Audio sublist ListTile Text widget
  Finder targetAudioListTileTextWidgetFinder = find.text(audioTitle);

  // Then obtain the Audio ListTile widget enclosing the Text widget by
  // finding its ancestor
  Finder targetAudioListTileWidgetFinder = find.ancestor(
    of: targetAudioListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the Audio ListTile and tap
  // on it
  Finder targetAudioListTileLeadingMenuIconButton = find.descendant(
    of: targetAudioListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(targetAudioListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Now find the popup menu item and tap on it
  final Finder popupDisplayAudioInfoMenuItemFinder =
      find.byKey(const Key("popup_menu_display_audio_info"));

  await tester.tap(popupDisplayAudioInfoMenuItemFinder);
  await tester.pumpAndSettle();

  // Now verifying the display audio info audio copied dialog
  // elements

  // Verify the video upload date of the audio

  final Text videoUploadDateTextWidget =
      tester.widget<Text>(find.byKey(const Key('videoUploadDateKey')));

  expect(
    videoUploadDateTextWidget.data,
    videoUploadDate,
  );

  // Verify the audio download date time of the audio

  final Text audioDownloadDateTimeTextWidget =
      tester.widget<Text>(find.byKey(const Key('audioDownloadDateTimeKey')));

  expect(
    audioDownloadDateTimeTextWidget.data,
    audioDownloadDateTime,
  );

  // Now find the close button of the audio info dialog
  // and tap on it
  await tester.tap(find.byKey(const Key('audio_info_close_button_key')));
  await tester.pumpAndSettle();

  // Tap the 'Toggle List' button to display the list of playlist's.
  await tester.tap(find.byKey(const Key('playlist_toggle_button')));
  await tester.pumpAndSettle();

  // Find the playlist whose audio are commented

  // First, find the Playlist ListTile Text widget. Two exist:
  // "S8 audio" under the 'Youtube Link or Search' text field and
  // "S8 audio" as PlaylistItem
  final Finder playlistToExamineInfoTextWidgetFinder =
      find.text(playlistTitle).at(1);

  // Then obtain the Playlist ListTile widget enclosing the Text widget
  // by finding its ancestor
  final Finder playlistWithCommentedAudioListTileWidgetFinder = find.ancestor(
    of: playlistToExamineInfoTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the playlist and tap on it
  final Finder playlistListTileLeadingMenuIconButton = find.descendant(
    of: playlistWithCommentedAudioListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(playlistListTileLeadingMenuIconButton);
  await tester.pumpAndSettle(); // Wait for popup menu to appear

  // Now find the playlist info popup menu item and tap on it
  // to open the PlaylistInfoDialog
  final Finder popupPlaylistInfoMenuItem =
      find.byKey(const Key("popup_menu_display_playlist_info"));

  await tester.tap(popupPlaylistInfoMenuItem);
  await tester.pumpAndSettle();

  // Verify the playlist last download date time

  final Text playlistLastDownloadDateTimeTextWidget = tester
      .widget<Text>(find.byKey(const Key('playlist_last_download_date_time')));

  expect(
    playlistLastDownloadDateTimeTextWidget.data,
    playlistLastDownloadDateTime,
  );

  // Now find the ok button of the playlist info dialog
  // and tap on it
  await tester.tap(find.byKey(const Key('playlist_info_ok_button_key')));
  await tester.pumpAndSettle();

  // Tap the 'Toggle List' button to hide the list of playlist's.
  await tester.tap(find.byKey(const Key('playlist_toggle_button')));
  await tester.pumpAndSettle();

  // Now, selecting 'audio downl dur' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'audio downl dur',
    audioSubTitles: audioSubTitlesWithAudioDownloadDuration,
  );

  // Now, selecting 'audio remai. duration' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'audio remai. duration',
    audioSubTitles: audioSubTitlesWithAudioRemainingDuration,
  );

  // Now, selecting 'desc listened' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'desc listened',
    audioSubTitles: audioSubTitlesLastListenedDateTimeDescending,
  );

  // Now, selecting 'Title asc' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'Title asc',
    audioSubTitles: audioSubTitlesTitleAsc,
  );

  // Now, selecting 'video upl date' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'video upl date',
    audioSubTitles: audioSubTitlesVideoUploadDate,
  );

  // Now, selecting 'downl speed' dropdown button item to
  // apply this sort/filter parms
  await _selectApplyAndVerifySortFilterParms(
    tester: tester,
    sortFilterParms: 'downl speed',
    audioSubTitles: audioSubTitlesWithAudioDownloadSpeed,
  );

  // Reset 'default' sort/filter parm

  final Finder dropDownButtonFinder =
      find.byKey(const Key('sort_filter_parms_dropdown_button'));

  final Finder dropDownButtonTextFinder = find.descendant(
    of: dropDownButtonFinder,
    matching: find.byType(Text),
  );

  // Tap on the current dropdown button item to open the dropdown
  // button items list
  await tester.tap(dropDownButtonTextFinder);
  await tester.pumpAndSettle();

  // And select the 'default' sort/filter item
  final Finder defaultDropDownTextFinder = find.text('default');
  await tester.tap(defaultDropDownTextFinder);
  await tester.pumpAndSettle();

  // Verifying the comment date format

  // First, find the Audio sublist ListTile Text widget
  targetAudioListTileTextWidgetFinder = find.text(audioTitle);

  // Then obtain the Audio ListTile widget enclosing the Text widget by
  // finding its ancestor
  targetAudioListTileWidgetFinder = find.ancestor(
    of: targetAudioListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now find the leading menu icon button of the Audio ListTile and tap
  // on it
  targetAudioListTileLeadingMenuIconButton = find.descendant(
    of: targetAudioListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(targetAudioListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Now find the popup menu item and tap on it
  final Finder popupDisplayAudioCommentMenuItemFinder =
      find.byKey(const Key("popup_menu_audio_comment"));

  await tester.tap(popupDisplayAudioCommentMenuItemFinder);
  await tester.pumpAndSettle();

  expect(find.text(commentCreationDate), findsOneWidget);
  expect(find.text(commentUpdateDate), findsOneWidget);

  // Now close the comment list dialog
  await tester.tap(find.byKey(const Key('closeDialogTextButton')));
  await tester.pumpAndSettle();

  // Now verify the date picker date format usage in the
  // start download date field

  await _openSortFilterThenDatePickerDialog(tester);

  // Confirm the date picker dialog
  final Finder confirmButton = find.text('OK');
  await tester.tap(confirmButton);
  await tester.pumpAndSettle();

  // Verify the set date displayed in the start download date text
  // field
  final Finder selectedDateText =
      find.byKey(const Key('startDownloadDateTextField'));
  expect(
    tester.widget<TextField>(selectedDateText).controller!.text,
    datePickerDateStr,
  );

  // Now close the audio sort filter dialog by tapping on its cancel
  // button
  await tester.tap(find.byKey(const Key('cancelSortFilterButton')));
  await tester.pumpAndSettle();

  // Now verify the date format on the 'Set the Download Date dialog'.
  // On the left appbar menu, tap on the 'Save Playlists Audio's MP3
  // to ZIP File ...' menu.

  // Replace the platform instance with your mock
  MockFilePicker mockFilePicker = MockFilePicker();
  FilePicker.platform = mockFilePicker;

  // Setting the path value returned by the FilePicker mock.
  mockFilePicker.setPathToSelect(
    pathToSelectStr: kApplicationPathWindowsTest,
  );

  // Tap the appbar leading popup menu button Then, the 'Save
  // Playlists Audio's MP3 to ZIP File' menu is selected.
  await IntegrationTestUtil.typeOnAppbarMenuItem(
    tester: tester,
    appbarMenuKeyStr: 'appBarMenuSavePlaylistsAudioMp3FilesToZip',
  );

  expect(find.text('Date/time $savePlaylistsAudioMp3DateFormat hh:mm'),
      findsOneWidget);
  expect(find.text('$savePlaylistsAudioMp3OldestDate 09:45'), findsOneWidget);

  await tester.tap(find.byKey(const Key('setValueToTargetCancelButton')));
  await tester.pumpAndSettle();

  // Tap the appbar leading popup menu button Then, the
  // 'Get last Audio download Date' menu is selected.
  await IntegrationTestUtil.typeOnAppbarMenuItem(
    tester: tester,
    appbarMenuKeyStr: 'appBarMenuObtainMostRecentAudioDownloadDateTime',
  );

  expect(
      find.text(
          'This is the latest audio download date/time: $latestAudioDownloadDate 16:55.'),
      findsOneWidget);

  await tester.tap(find.byKey(const Key('warningDialogOkButton')));
  await tester.pumpAndSettle();
}

Future<void> _selectApplyAndVerifySortFilterParms({
  required WidgetTester tester,
  required String sortFilterParms,
  required List<String> audioSubTitles,
}) async {
  final Finder dropDownButtonFinder =
      find.byKey(const Key('sort_filter_parms_dropdown_button'));

  final Finder dropDownButtonTextFinder = find.descendant(
    of: dropDownButtonFinder,
    matching: find.byType(Text),
  );

  // Tap on the current dropdown button item to open the dropdown
  // button items list
  await tester.tap(dropDownButtonTextFinder);
  await tester.pumpAndSettle();

  // And select the sortFilterParms sort/filter item
  final Finder titleAscDropDownTextFinder = find.text(sortFilterParms);
  await tester.tap(titleAscDropDownTextFinder);
  await tester.pumpAndSettle();

  // Verify the audio sub-titles order in the list tile which correspond
  // to the sortFilterParms sort order selected parms
  IntegrationTestUtil.checkAudioSubTitlesOrderInListTile(
    tester: tester,
    audioSubTitlesAcceptableLst: audioSubTitles,
  );
}

Future<void> _rewindPlaylistAfterPlayThenPauseAnAudio({
  required WidgetTester tester,
  required Finder appScreenNavigationButton,
  required bool doExpandPlaylistList,
  required String playlistToRewindTitle,
  required String audioToPlayTitle,
  required String audioToPlayTitleAndDuration,
  String? otherAudioTitleToTapOnBeforeRewinding,
  String? otherAudioTitleToTapOnBeforeRewindingDuration,
  int audioRewindedNumber = 1,
}) async {
  // Now play then pause audioToPlayTitle

  Finder audioToPlayTitleFinder = find.text(audioToPlayTitle);

  // This opens the play audio view
  await tester.tap(audioToPlayTitleFinder);
  await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
    tester: tester,
  );

  // Now play the audio and wait 5 seconds
  await tester.tap(find.byIcon(Icons.play_arrow));
  await tester.pumpAndSettle();

  await Future.delayed(const Duration(seconds: 5));
  await tester.pumpAndSettle();

  // Now pause the audio
  final Finder pauseIconFinder = find.byIcon(Icons.pause);
  await tester.tap(pauseIconFinder);
  await tester.pumpAndSettle();

  // Go back to playlist download view
  appScreenNavigationButton =
      find.byKey(const ValueKey('playlistDownloadViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  if (doExpandPlaylistList) {
    // Tap the 'Toggle List' button to display the list of playlist's.
    await tester.tap(find.byKey(const Key('playlist_toggle_button')));
    await tester.pumpAndSettle();
  }

  if (otherAudioTitleToTapOnBeforeRewinding != null) {
    // Simply click on another audio so that the playlist current
    // audio is no longer the last played and paused audio. This verify
    // the correction of a rewind playlist audio to start position bug
    Finder audioToPlayTitleFinder =
        find.text(otherAudioTitleToTapOnBeforeRewinding);

    await tester.tap(audioToPlayTitleFinder);
    await IntegrationTestUtil.pumpAndSettleDueToAudioPlayers(
      tester: tester,
    );

    // Go back to playlist download view
    appScreenNavigationButton =
        find.byKey(const ValueKey('playlistDownloadViewIconButton'));
    await tester.tap(appScreenNavigationButton);
    await tester.pumpAndSettle(const Duration(milliseconds: 200));
  }

  // Rewind all playlist audio to start position
  await _tapOnRewindPlaylistAudioToStartPositionMenu(
    tester: tester,
    playlistToRewindTitle: playlistToRewindTitle,
    numberOfRewindedAudio: audioRewindedNumber,
  );

  // Return to audio player view to verify the playlist current
  // audio title audio position set to start
  appScreenNavigationButton =
      find.byKey(const ValueKey('audioPlayerViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  Finder currentAudioTitleFinder;

  currentAudioTitleFinder = find.text(audioToPlayTitleAndDuration);

  expect(
    currentAudioTitleFinder,
    findsOneWidget,
  );

  // Verify the current audio position
  Text audioPositionText = tester
      .widget<Text>(find.byKey(const Key('audioPlayerViewAudioPosition')));
  expect(audioPositionText.data, '0:00');

  // Go back to playlist download view
  appScreenNavigationButton =
      find.byKey(const ValueKey('playlistDownloadViewIconButton'));
  await tester.tap(appScreenNavigationButton);
  await tester.pumpAndSettle();
}

Future<void> _tapOnRewindPlaylistAudioToStartPositionMenu({
  required WidgetTester tester,
  required String playlistToRewindTitle,
  required int numberOfRewindedAudio,
}) async {
  // Find the playlist to rewind audio ListTile

  // First, find the Playlist ListTile Text widget
  final Finder youtubePlaylistToRewindListTileTextWidgetFinder =
      find.text(playlistToRewindTitle);

  // Then obtain the Playlist ListTile widget enclosing the Text widget
  // by finding its ancestor
  final Finder youtubePlaylistToRewindListTileWidgetFinder = find.ancestor(
    of: youtubePlaylistToRewindListTileTextWidgetFinder,
    matching: find.byType(ListTile),
  );

  // Now test rewinding the playlist audio to start position

  // Find the playlist leading menu icon button
  final Finder firstPlaylistListTileLeadingMenuIconButton = find.descendant(
    of: youtubePlaylistToRewindListTileWidgetFinder,
    matching: find.byIcon(Icons.menu),
  );

  // Tap the leading menu icon button to open the popup menu
  await tester.tap(firstPlaylistListTileLeadingMenuIconButton);
  await tester.pumpAndSettle();

  // Now find the 'Rewind Audio to Start' playlist popup menu item
  // and tap on it
  final Finder popupDeletePlaylistMenuItem =
      find.byKey(const Key("popup_menu_rewind_audio_to_start"));

  await tester.tap(popupDeletePlaylistMenuItem);
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  await IntegrationTestUtil.verifyWarningDisplayAndCloseIt(
    tester: tester,
    warningDialogMessage:
        "$numberOfRewindedAudio playlist audio's were repositioned to start and the first listenable audio was selected.",
    isWarningConfirming: true,
  );
}

Future<void> _tapOnSetAudioQualityMenu({
  required WidgetTester tester,
  required String playlistToModifyTitle,
  required bool setMusicQuality, // true: set music quality,
  //                                 false: set spoken quality
}) async {
  // Tap on the set audio quality playlist popup menu
  await IntegrationTestUtil.typeOnPlaylistMenuItem(
    tester: tester,
    playlistTitle: playlistToModifyTitle,
    playlistMenuKeyStr: 'popup_menu_set_audio_quality',
  );

  await IntegrationTestUtil.verifySetValueToTargetDialog(
    tester: tester,
    dialogTitle: 'Playlist Audio Quality',
    dialogMessage: 'Select audio quality',
  );

  if (setMusicQuality) {
    // Tap on the 'musical' quality checkbox to select it
    await tester.tap(find.byKey(const Key('checkbox_1_key')));
    await tester.pumpAndSettle();
  } else {
    // Tap on the 'spoken' quality checkbox to select it
    await tester.tap(find.byKey(const Key('checkbox_0_key')));
    await tester.pumpAndSettle();
  }

  // And click on the 'OK' button to confirm the selection
  await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
  await tester.pumpAndSettle();
}

Future<void> _tapOnDownloadURLsFromTextFileMenu({
  required WidgetTester tester,
  required String playlistToDownloadInTitle,
  required bool initialSpokenCheckboxState, // true: spoken checkbox is checked,
  required bool initialMusicCheckboxState, // true: music checkbox is checked,
  required bool setMusicQuality, // true: set music quality,
  //                                false: set spoken quality
  bool uncheckAllCheckboxes = false, // true: uncheck all checkboxes
}) async {
  // Tap on the set audio quality playlist popup menu
  await IntegrationTestUtil.typeOnPlaylistMenuItem(
    tester: tester,
    playlistTitle: playlistToDownloadInTitle,
    playlistMenuKeyStr: 'popup_menu_download_video_urls_in_playlist',
  );

  // Check the value of the AlertDialog dialog title and check the
  // value of the AlertDialog dialog text
  await IntegrationTestUtil.verifySetValueToTargetDialog(
    tester: tester,
    dialogTitle:
        "Download video audio to playlist \"$playlistToDownloadInTitle\"",
    dialogMessage: "Downloading 2 audio's in selected quality.",
  );

  // Verify the checkbox state
  final Checkbox checkboxZeroWidget =
      tester.widget<Checkbox>(find.byKey(const Key('checkbox_0_key')));
  expect(checkboxZeroWidget.value, initialSpokenCheckboxState);

  final Checkbox checkboxOneWidget =
      tester.widget<Checkbox>(find.byKey(const Key('checkbox_1_key')));
  expect(checkboxOneWidget.value, initialMusicCheckboxState);

  if (setMusicQuality) {
    // Tap on the 'musical' quality checkbox to select it
    await tester.tap(find.byKey(const Key('checkbox_1_key')));
    await tester.pumpAndSettle();
  } else {
    // Tap on the 'spoken' quality checkbox to select it
    await tester.tap(find.byKey(const Key('checkbox_0_key')));
    await tester.pumpAndSettle();
  }

  if (uncheckAllCheckboxes) {
    // Uncheck all checkboxes. This will cause tapping on the
    // 'OK' button to not close the dialog
    if (!setMusicQuality) {
      await tester.tap(find.byKey(const Key('checkbox_0_key')));
    } else {
      await tester.tap(find.byKey(const Key('checkbox_1_key')));
    }

    await tester.pumpAndSettle();
  }

  // And click on the 'OK' button to confirm the selection
  await tester.tap(find.byKey(const Key('setValueToTargetOkButton')));
  await tester.pumpAndSettle();
}

void _verifyAllNowUnplayedAudioPlayPauseIconColor({
  required WidgetTester tester,
  required List<String> audioTitles,
}) {
  for (String audioTitle in audioTitles) {
    IntegrationTestUtil.validateInkWellButton(
      tester: tester,
      audioTitle: audioTitle,
      expectedIcon: Icons.play_arrow,
      expectedIconColor: kDarkAndLightEnabledIconColor, // not played icon color
      expectedIconBackgroundColor: Colors.black,
    );
  }
}

String _extractZipFileName(String confirmationMessage) {
  final RegExp zipFileRegex =
      RegExp(r'audioLearn_\d{4}-\d{2}-\d{2}_\d{2}_\d{2}_\d{2}\.zip');
  final Match? match = zipFileRegex.firstMatch(confirmationMessage);
  return match?.group(0) ?? '';
}

String _extractMp3ZipFileName({
  required String confirmationMessage,
  required String zipStartFileName,
}) {
  final RegExp mp3ZipRegex = RegExp(
      '${zipStartFileName}_mp3_from_\\d{4}-\\d{2}-\\d{2}_\\d{2}_\\d{2}_\\d{2}_on_\\d{4}-\\d{2}-\\d{2}_\\d{2}_\\d{2}_\\d{2}\\.zip');
  final Match? match = mp3ZipRegex.firstMatch(confirmationMessage);
  return match?.group(0) ?? '';
}

String _extractDuration(String displayText) {
  final RegExp durationRegex = RegExp(r'\d{1,2}:\d{2}(?::\d{2})?');
  final Match? match = durationRegex.firstMatch(displayText);
  return match?.group(0) ?? '';
}

Future<List<String>> _enteringFirstAndSecondLetterOfLocalPlaylistSearchWord({
  required WidgetTester tester,
}) async {
  // Now enter the first letter of the search word
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    'a',
  );
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  // Verify that the search icon button is now enabled but inactive
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledInactive,
  );

  // Ensure that since the search icon button was not yet pressed,
  // the displayed playlist list is the same as the one before entering
  // the first letter of the search word.

  List<String> playlistsTitles = [
    "S8 audio",
    "local",
    "local_2",
  ];

  List<String> audioTitles = [
    "La résilience insulaire par Fiona Roche",
    "Le Secret de la RÉSILIENCE révélé par Boris Cyrulnik",
    "Les besoins artificiels par R.Keucheyan",
    "3 fois où un économiste m'a ouvert les yeux (Giraud, Lefournier, Porcher)",
  ];

  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  // Enter the second letter of the 'al' search word. The crazy integration
  // test does not always update the test field. To fix this bug, first
  // select the text field and then enter the text.

  // Select the text field
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();

  // Enter the second letter of the 'al' search word
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    'al',
  );
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  // Verify that the search icon button is now enabled but inactive
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledInactive,
  );

  // Ensure that since the search icon button was not yet pressed,
  // the displayed playlist list is the same as the one before entering
  // the first letter of the search word.
  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  // Now tap on the search icon button
  await tester.tap(find.byKey(const Key('search_icon_button')));
  await tester.pumpAndSettle();

  // Verify that the search icon button is now enabled and active
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledActive,
  );

  // Now verify the order of the reduced playlist titles

  playlistsTitles = [
    "local",
    "local_2",
  ];

  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  return playlistsTitles;
}

Future<List<String>> enteringFirstAndSecondLetterOfYoutubePlaylistSearchWord({
  required WidgetTester tester,
}) async {
  // Now enter the first letter of the search word
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    'S',
  );
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  // Verify that the search icon button is now enabled but inactive
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledInactive,
  );

  // Ensure that since the search icon button was not yet pressed,
  // the displayed playlist list is the same as the one before entering
  // the first letter of the search word.

  List<String> playlistsTitles = [
    "S8 audio",
    "local",
    "local_2",
  ];

  List<String> audioTitles = [
    "Really short video",
    "Jancovici m'explique l’importance des ordres de grandeur face au changement climatique",
    "La résilience insulaire par Fiona Roche",
    "Les besoins artificiels par R.Keucheyan",
  ];

  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  // Enter the second letter of the 'al' search word. The crazy integration
  // test does not always update the test field. To fix this bug, first
  // select the text field and then enter the text.

  // Select the text field
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();

  // Enter the second letter of the 'al' search word
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    'S8',
  );
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  // Verify that the search icon button is now enabled but inactive
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledInactive,
  );

  // Ensure that since the search icon button was not yet pressed,
  // the displayed playlist list is the same as the one before entering
  // the first letter of the search word.
  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  // Now tap on the search icon button
  await tester.tap(find.byKey(const Key('search_icon_button')));
  await tester.pumpAndSettle();

  // Verify that the search icon button is now enabled and active
  IntegrationTestUtil.validateSearchIconButton(
    tester: tester,
    searchIconButtonState: SearchIconButtonState.enabledActive,
  );

  // Now verify the order of the reduced playlist titles

  playlistsTitles = [
    "S8 audio",
  ];

  IntegrationTestUtil.checkPlaylistAndAudioTitlesOrderInListTile(
    tester: tester,
    playlistTitlesOrderedLst: playlistsTitles,
    audioTitlesOrderedLst: audioTitles,
  );

  return playlistsTitles;
}

Map _loadSettingsMap() {
  final String settingsJsonStr =
      File("$kApplicationPathWindowsTest${path.separator}$kSettingsFileName")
          .readAsStringSync();

  Map settingsMap = jsonDecode(settingsJsonStr);

  return settingsMap;
}

Future<void> _executeSearchWordScrollTest({
  required WidgetTester tester,
  required String playlistTitle,
  double scrollUpOrDownPlaylistsList = 0,
}) async {
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    '',
  );

  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  if (scrollUpOrDownPlaylistsList != 0) {
    // Scrolling up or down the playlist list
    // Find the audio list widget using its key
    final listFinder = find.byKey(const Key('expandable_playlist_list'));
    // Perform the scroll action
    await tester.drag(
      listFinder,
      Offset(0, scrollUpOrDownPlaylistsList),
    );
    await tester.pumpAndSettle();
  }

  // Select the playlist
  await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
    tester: tester,
    playlistToSelectTitle: playlistTitle,
    verifyIfCheckboxIsChecked: false,
    tapOnCheckbox: true,
  );

  // Now enter the '_1' search word
  await tester.tap(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
  );
  await tester.pumpAndSettle();
  await tester.enterText(
    find.byKey(
      const Key('youtubeUrlOrSearchTextField'),
    ),
    '_1',
  );
  await tester.pumpAndSettle(const Duration(milliseconds: 200));

  // Now tap on the search icon button
  await tester.tap(find.byKey(const Key('search_icon_button')));
  await tester.pumpAndSettle();

  // Verify that the playlist is correctly scrolled so that it is
  // visible
  await _onPlaylistDownloadViewCheckOrTapOnPlaylistCheckbox(
    tester: tester,
    playlistToSelectTitle: playlistTitle,
    verifyIfCheckboxIsChecked: true,
    tapOnCheckbox: false,
  );
}
